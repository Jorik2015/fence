<tag><description>    <![CDATA[
<p>List filters are able to be preloaded/backed by an
Ext.data.Store to load their options the first time they are shown.
ListFilter utilizes the <a href="output/Ext.ux.menu.ListMenu.html" ext:cls="Ext.ux.menu.ListMenu">Ext.ux.menu.ListMenu</a>
component.</p>

<p>Although not shown here, this class accepts all configuration
options for <a href="output/Ext.ux.menu.ListMenu.html" ext:cls="Ext.ux.menu.ListMenu">Ext.ux.menu.ListMenu</a>.</p>

<p><b><u>Example Usage:</u></b></p>

<pre><code><b>var</b> filters = <b>new</b> Ext.ux.grid.GridFilters({
    ...
    filters: [{
        type: <em>'list'</em>,
        dataIndex: <em>'size'</em>,
        phpMode: true,
        <i>// options will be used as data to implicitly creates an ArrayStore
</i>
        options: [<em>'extra small'</em>, <em>'small'</em>, <em>'medium'</em>, <em>'large'</em>, <em>'extra large'</em>]
    }]
});</code>
</pre>
]]></description><name>listfilter</name><tag-class></tag-class><body-content>JSP</body-content><attribute>	<description>        <![CDATA[Indicates the initial status of the filter(defaults to false).]]>    </description>	<name>active</name>	<required>false</required></attribute><attribute>	<description>        <![CDATA[The <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> dataIndex of the fieldthis filter represents. The dataIndex does not actually have to
exist in the store.]]>    </description>	<name>dataIndex</name>	<required>false</required></attribute><attribute>	<description>        <![CDATA[<p>A config object containing one or more event handlers to be
added to this object during initialization. This should be a valid
listeners config object as specified in the <a href="output/Ext.util.Observable.html#Ext.util.Observable-addListener" ext:member="addListener" ext:cls="Ext.util.Observable">addListener</a> example for attaching
multiple handlers at once.</p>

<br>
<p><b><u>DOM events from ExtJs <a href="output/Ext.Component.html" ext:cls="Ext.Component">Components</a></u></b></p>

<br>
<p>While <i>some</i> ExtJs Component classes export selected DOM
events (e.g. "click", "mouseover" etc), this is usually only done
when extra value can be added. For example the <a href="output/Ext.DataView.html" ext:cls="Ext.DataView">DataView</a>'s <b><code><a href="output/Ext.DataView.html#Ext.DataView-click" ext:member="click" ext:cls="Ext.DataView">click</a></code></b>
event passing the node clicked on. To access DOM events directly
from a Component's HTMLElement, listeners must be added to the
<i><a href="output/Ext.Component.html#Ext.Component-getEl" ext:member="getEl" ext:cls="Ext.Component">Element</a></i> after
the Component has been rendered. A plugin can simplify this
step:</p>

<pre><code><i>// Plugin is configured <b>with</b> a listeners config object.</i>
<i>// The Component is appended to the argument list of all handler functions.</i>
Ext.DomObserver = Ext.extend(Object, {
    constructor: <b>function</b>(config) {
        this.listeners = config.listeners ? config.listeners : config;
    },

    <i>// Component passes itself into plugin's init method</i>
    init: <b>function</b>(c) {
        <b>var</b> p, l = this.listeners;
        <b>for</b> (p <b>in</b> l) {
            <b>if</b> (Ext.isFunction(l[p])) {
                l[p] = this.createHandler(l[p], c);
            } <b>else</b> {
                l[p].fn = this.createHandler(l[p].fn, c);
            }
        }

        <i>// Add the listeners to the Element immediately following the render call</i>
        c.render = c.render.<a href="output/Function.html#Function-createSequence" ext:member="createSequence" ext:cls="Function">createSequence</a>(<b>function</b>() {
            <b>var</b> e = c.getEl();
            <b>if</b> (e) {
                e.on(l);
            }
        });
    },

    createHandler: <b>function</b>(fn, c) {
        <b>return</b> <b>function</b>(e) {
            fn.call(this, e, c);
        };
    }
});

<b>var</b> combo = <b>new</b> Ext.form.ComboBox({

    <i>// Collapse combo when its element is clicked on</i>
    plugins: [ <b>new</b> Ext.DomObserver({
        click: <b>function</b>(evt, comp) {
            comp.collapse();
        }
    })],
    store: myStore,
    typeAhead: true,
    mode: <em>'local'</em>,
    triggerAction: <em>'all'</em>
});</code>
</pre>

<br>
<br>
]]>    </description>	<name>listeners</name>	<required>false</required></attribute><attribute>	<description>        <![CDATA[<p><code>data</code> to be used to implicitly create a data store
to back this list when the data source is <b>local</b>. If the data
for the list is remote, use the <code><a href="output/Ext.ux.grid.filter.ListFilter.html#Ext.ux.grid.filter.ListFilter-store" ext:member="store" ext:cls="Ext.ux.grid.filter.ListFilter">store</a></code> config
instead.</p>

<br>
<p>Each item within the provided array may be in one of the
following formats:</p>

<div class="mdetail-params">
<ul>
<li><b>Array</b> : 

<pre><code>options: [
    [11, <em>'extra small'</em>], 
    [18, <em>'small'</em>],
    [22, <em>'medium'</em>],
    [35, <em>'large'</em>],
    [44, <em>'extra large'</em>]
]</code>
</pre>
</li>

<li><b>Object</b> : 

<pre><code>labelField: <em>'name'</em>, <i>// override <b>default</b> of <em>'text'</em>
</i>
options: [
    {id: 11, name:<em>'extra small'</em>}, 
    {id: 18, name:<em>'small'</em>}, 
    {id: 22, name:<em>'medium'</em>}, 
    {id: 35, name:<em>'large'</em>}, 
    {id: 44, name:<em>'extra large'</em>} 
]</code>
</pre>
</li>

<li><b>String</b> : 

<pre><code>options: [<em>'extra small'</em>, <em>'small'</em>, <em>'medium'</em>, <em>'large'</em>, <em>'extra large'</em>]</code>
</pre>
</li>
</ul>
</div>
]]>    </description>	<name>options</name>	<required>false</required></attribute><attribute>	<description>        <![CDATA[<p>Adjust the format of this filter. Defaults to false.</p>

<br>
<p>When GridFilters <code>@cfg encode = false</code> (default):</p>

<pre><code><i>// phpMode == false (<b>default</b>):
</i>
filter[0][data][type] list
filter[0][data][value] value1
filter[0][data][value] value2
filter[0][field] prod 

<i>// phpMode == true:
</i>
filter[0][data][type] list
filter[0][data][value] value1, value2
filter[0][field] prod</code>
</pre>

When GridFilters <code>@cfg encode = true</code>: 

<pre><code><i>// phpMode == false (<b>default</b>):
</i>
filter : [{<em>"type"</em>:<em>"list"</em>,<em>"value"</em>:[<em>"small"</em>,<em>"medium"</em>],<em>"field"</em>:<em>"size"</em>}]

<i>// phpMode == true:
</i>
filter : [{<em>"type"</em>:<em>"list"</em>,<em>"value"</em>:<em>"small,medium"</em>,<em>"field"</em>:<em>"size"</em>}]</code>
</pre>
]]>    </description>	<name>phpMode</name>	<required>false</required></attribute><attribute>	<description>        <![CDATA[The <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> this list should use asits data source when the data source is <b>remote</b>. If the data
for the list is local, use the <code><a href="output/Ext.ux.grid.filter.ListFilter.html#Ext.ux.grid.filter.ListFilter-options" ext:member="options" ext:cls="Ext.ux.grid.filter.ListFilter">options</a></code> config
instead.]]>    </description>	<name>store</name>	<required>false</required></attribute><attribute>	<description>        <![CDATA[Number of milliseconds to wait after userinteraction to fire an update. Only supported by filters: 'list',
'numeric', and 'string'. Defaults to 500.]]>    </description>	<name>updateBuffer</name>	<required>false</required></attribute></tag>