package ext.data;

import java.io.Serializable;

import javax.el.ELContext;
import javax.el.ELException;
import javax.el.MethodExpression;
import javax.el.MethodInfo;
import javax.el.ValueExpression;
import javax.faces.FacesException;
import javax.faces.component.ActionSource;
import javax.faces.component.ActionSource2;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.el.MethodBinding;
import javax.faces.event.AbortProcessingException;
import javax.faces.event.ActionEvent;
import javax.faces.event.ActionListener;
import javax.faces.event.FacesEvent;
import javax.faces.event.PhaseId;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.ParseConfigMode;
import ext.annotation.PersistenceMode;
import ext.annotation.ReferenceMode;
import ext.annotation.XType;
import ext.base.MethodBindingMethodExpressionAdapter;
import ext.base.MethodExpressionMethodBindingAdapter;
import ext.util.Observable;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * The Store class encapsulates a client side cache of <a
 * href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Record</a>
 * objects which provide input data for Components such as the <a
 * href="output/Ext.grid.GridPanel.html"
 * ext:cls="Ext.grid.GridPanel">GridPanel</a>, the <a
 * href="output/Ext.form.ComboBox.html"
 * ext:cls="Ext.form.ComboBox">ComboBox</a>, or the <a
 * href="output/Ext.DataView.html" ext:cls="Ext.DataView">DataView</a>.
 * </p>
 * 
 * <p>
 * <u>Retrieving Data</u>
 * </p>
 * 
 * <p>
 * A Store object may access a data object using:
 * </p>
 * 
 * <div class="mdetail-params">
 * <ul>
 * <li><a href="output/Ext.data.Store.html#Ext.data.Store-proxy"
 * ext:member="proxy" ext:cls="Ext.data.Store">configured implementation</a> of
 * <a href="output/Ext.data.DataProxy.html"
 * ext:cls="Ext.data.DataProxy">DataProxy</a></li>
 * 
 * <li><a href="output/Ext.data.Store.html#Ext.data.Store-data"
 * ext:member="data" ext:cls="Ext.data.Store">data</a> to automatically pass in
 * data</li>
 * 
 * <li><a href="output/Ext.data.Store.html#Ext.data.Store-loadData"
 * ext:member="loadData" ext:cls="Ext.data.Store">loadData</a> to manually pass
 * in data</li>
 * </ul>
 * </div>
 * 
 * <br>
 * <br>
 * 
 * 
 * <p>
 * <u>Reading Data</u>
 * </p>
 * 
 * <p>
 * A Store object has no inherent knowledge of the format of the data object (it
 * could be an Array, XML, or JSON). A Store object uses an appropriate <a
 * href="output/Ext.data.Store.html#Ext.data.Store-reader" ext:member="reader"
 * ext:cls="Ext.data.Store">configured implementation</a> of a <a
 * href="output/Ext.data.DataReader.html"
 * ext:cls="Ext.data.DataReader">DataReader</a> to create <a
 * href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Record</a>
 * instances from the data object.
 * </p>
 * 
 * <p>
 * <u>Store Types</u>
 * </p>
 * 
 * <p>
 * There are several implementations of Store available which are customized for
 * use with a specific DataReader implementation. Here is an example using an
 * ArrayStore which implicitly creates a reader commensurate to an Array data
 * object.
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myStore = &lt;b&gt;new&lt;/b&gt; Ext.data.ArrayStore({
 *     fields: [&lt;em&gt;'fullname'&lt;/em&gt;, &lt;em&gt;'first'&lt;/em&gt;],
 *     idIndex: 0 &lt;i&gt;// id &lt;b&gt;for&lt;/b&gt; each record will be the first element&lt;/i&gt;
 * });&lt;/code&gt;
 * </pre>
 * 
 * <p>
 * For custom implementations create a basic <a
 * href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a>
 * configured as needed:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;i&gt;// create a &lt;a href=&quot;output/Ext.data.Record.html&quot; ext:cls=&quot;Ext.data.Record&quot;&gt;Record&lt;/a&gt; constructor:&lt;/i&gt;
 * &lt;b&gt;var&lt;/b&gt; rt = Ext.data.Record.create([
 *     {name: &lt;em&gt;'fullname'&lt;/em&gt;},
 *     {name: &lt;em&gt;'first'&lt;/em&gt;}
 * ]);
 * &lt;b&gt;var&lt;/b&gt; myStore = &lt;b&gt;new&lt;/b&gt; Ext.data.Store({
 *     &lt;i&gt;// explicitly create reader&lt;/i&gt;
 *     reader: &lt;b&gt;new&lt;/b&gt; Ext.data.ArrayReader(
 *         {
 *             idIndex: 0  &lt;i&gt;// id &lt;b&gt;for&lt;/b&gt; each record will be the first element&lt;/i&gt;
 *         },
 *         rt &lt;i&gt;// recordType&lt;/i&gt;
 *     )
 * });&lt;/code&gt;
 * </pre>
 * 
 * <p>
 * Load some data into store (note the data object is an array which corresponds
 * to the reader):
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myData = [
 *     [1, &lt;em&gt;'Fred Flintstone'&lt;/em&gt;, &lt;em&gt;'Fred'&lt;/em&gt;],  &lt;i&gt;// note that id &lt;b&gt;for&lt;/b&gt; the record is the first element&lt;/i&gt;
 *     [2, &lt;em&gt;'Barney Rubble'&lt;/em&gt;, &lt;em&gt;'Barney'&lt;/em&gt;]
 * ];
 * myStore.loadData(myData);&lt;/code&gt;
 * </pre>
 * 
 * <p>
 * Records are cached and made available through accessor functions. An example
 * of adding a record to the store:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; defaultData = {
 *     fullname: &lt;em&gt;'Full Name'&lt;/em&gt;,
 *     first: &lt;em&gt;'First Name'&lt;/em&gt;
 * };
 * &lt;b&gt;var&lt;/b&gt; recId = 100; &lt;i&gt;// provide unique id &lt;b&gt;for&lt;/b&gt; the record&lt;/i&gt;
 * &lt;b&gt;var&lt;/b&gt; r = &lt;b&gt;new&lt;/b&gt; myStore.recordType(defaultData, ++recId); &lt;i&gt;// create &lt;b&gt;new&lt;/b&gt; record&lt;/i&gt;
 * myStore.&lt;a href=&quot;output/Ext.data.Store.html#Ext.data.Store-insert&quot; ext:member=&quot;insert&quot; ext:cls=&quot;Ext.data.Store&quot;&gt;insert&lt;/a&gt;(0, r); &lt;i&gt;// insert a &lt;b&gt;new&lt;/b&gt; record into the store (also see &lt;a href=&quot;output/Ext.data.Store.html#Ext.data.Store-add&quot; ext:member=&quot;add&quot; ext:cls=&quot;Ext.data.Store&quot;&gt;add&lt;/a&gt;)&lt;/i&gt;&lt;/code&gt;
 * </pre>
 */
@SuppressWarnings("deprecation")
@XType("store")
@InstanceOf("Ext.data.Store")
@ParseConfigMode(ui = false, name = "store", pmode = PersistenceMode.ParentProperty, rmode = ReferenceMode.Var)
public class Store extends Observable implements ActionSource2, Serializable {
	private static final long serialVersionUID = -4482790345148380119L;
	public static final String COMPONENT_TYPE = "Ext.data.Store";
	public static final String COMPONENT_FAMILY = "Ext.data.Store";

	/**
	 * <p>
	 * Create a new {@link Store} instance with default property values.
	 * </p>
	 */
	public Store() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	@Override
	@ClientConfig(name = "storeId")
	public String getId() {
		return super.getId();
	}

	private Boolean autoDestroy;

	/**
	 * <tt>true</tt> to destroy the store when thecomponent the store is bound
	 * to is destroyed (defaults to <tt>false</tt>).
	 * 
	 * <p>
	 * <b>Note</b>: this should be set to true when using stores that are bound
	 * to only 1 component.
	 * </p>
	 */
	public Boolean getAutoDestroy() {
		if (null != this.autoDestroy) {
			return this.autoDestroy;
		}
		ValueExpression _ve = getValueExpression("autoDestroy");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoDestroy</code> property.
	 * </p>
	 */
	public void setAutoDestroy(Boolean autoDestroy) {
		this.autoDestroy = autoDestroy;
		this.handleConfig("autoDestroy", autoDestroy);
	}

	private Boolean autoLoad;

	/**
	 * If
	 * <tt><a href="output/Ext.data.Store.html#Ext.data.Store-data" ext:member="data" ext:cls="Ext.data.Store">data</a></tt>
	 * is notspecified, and if <tt>autoLoad</tt> is <tt>true</tt> or an
	 * <tt>Object</tt>, this store's <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load"
	 * ext:cls="Ext.data.Store">load</a> method is automatically called after
	 * creation. If the value of <tt>autoLoad</tt> is an <tt>Object</tt>, this
	 * <tt>Object</tt> will be passed to the store's <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load"
	 * ext:cls="Ext.data.Store">load</a> method.
	 */
	public Boolean getAutoLoad() {
		if (null != this.autoLoad) {
			return this.autoLoad;
		}
		ValueExpression _ve = getValueExpression("autoLoad");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoLoad</code> property.
	 * </p>
	 */
	public void setAutoLoad(Boolean autoLoad) {
		this.autoLoad = autoLoad;
		this.handleConfig("autoLoad", autoLoad);
	}

	private Boolean autoSave;

	/**
	 * <p>
	 * Defaults to <tt>true</tt> causing the store to automatically <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-save" ext:member="save"
	 * ext:cls="Ext.data.Store">save</a> records to the server when a record is
	 * modified (ie: becomes 'dirty'). Specify <tt>false</tt> to manually call
	 * <a href="output/Ext.data.Store.html#Ext.data.Store-save"
	 * ext:member="save" ext:cls="Ext.data.Store">save</a> to send all
	 * modifiedRecords to the server.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: each CRUD action will be sent as a separate request.
	 * </p>
	 */
	public Boolean getAutoSave() {
		if (null != this.autoSave) {
			return this.autoSave;
		}
		ValueExpression _ve = getValueExpression("autoSave");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoSave</code> property.
	 * </p>
	 */
	public void setAutoSave(Boolean autoSave) {
		this.autoSave = autoSave;
		this.handleConfig("autoSave", autoSave);
	}

	private Object baseParams;

	/**
	 * <p>
	 * An object containing properties which are to be sent as parameters for
	 * <i>every</i> HTTP request.
	 * </p>
	 * 
	 * <p>
	 * Parameters are encoded as standard HTTP parameters using <a
	 * href="output/Ext.html#Ext-urlEncode" ext:member="urlEncode"
	 * ext:cls="Ext">Ext.urlEncode</a>.
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: <code>baseParams</code> may be superseded by any
	 * <code>params</code> specified in a
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load" ext:cls="Ext.data.Store">load</a></code>
	 * request, see
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load" ext:cls="Ext.data.Store">load</a></code>
	 * for more details.
	 * </p>
	 * 
	 * This property may be modified after creation using the
	 * 
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-setBaseParam" ext:member="setBaseParam" ext:cls="Ext.data.Store">setBaseParam</a></code>
	 * method.
	 */
	@ClientConfig(JsonMode.Object)
	public Object getBaseParams() {
		if (null != this.baseParams) {
			return this.baseParams;
		}
		ValueExpression _ve = getValueExpression("baseParams");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>baseParams</code> property.
	 * </p>
	 */
	public void setBaseParams(Object baseParams) {
		this.baseParams = baseParams;
		this.handleConfig("baseParams", baseParams);
	}

	private Boolean batch;

	/**
	 * <p>
	 * Defaults to <tt>true</tt> (unless
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-restful" ext:member="restful" ext:cls="Ext.data.Store">restful</a>:true</code>
	 * ). Multiple requests for each CRUD action (CREATE, READ, UPDATE and
	 * DESTROY) will be combined and sent as one transaction. Only applies when
	 * 
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-autoSave" ext:member="autoSave" ext:cls="Ext.data.Store">autoSave</a></code>
	 * is set to <tt>false</tt>.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * If Store is RESTful, the DataProxy is also RESTful, and a unique
	 * transaction is generated for each record.
	 * </p>
	 */
	public Boolean getBatch() {
		if (null != this.batch) {
			return this.batch;
		}
		ValueExpression _ve = getValueExpression("batch");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>batch</code> property.
	 * </p>
	 */
	public void setBatch(Boolean batch) {
		this.batch = batch;
		this.handleConfig("batch", batch);
	}

	private Object data;

	/**
	 * An inline data object readable by the
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-reader" ext:member="reader" ext:cls="Ext.data.Store">reader</a></code>
	 * .Typically this option, or the
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-url" ext:member="url" ext:cls="Ext.data.Store">url</a></code>
	 * option will be specified.
	 */
	@ClientConfig(JsonMode.Object)
	public Object getData() {
		if (null != this.data) {
			return this.data;
		}
		ValueExpression _ve = getValueExpression("data");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>data</code> property.
	 * </p>
	 */
	public void setData(Object data) {
		this.data = data;
		this.handleConfig("data", data);
	}

	private Object defaultParamNames;

	/**
	 * Provides the default values for the <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-paramNames"
	 * ext:member="paramNames" ext:cls="Ext.data.Store">paramNames</a>property.
	 * To globally modify the parameters for all stores, this object should be
	 * changed on the store prototype.
	 */
	@ClientConfig(JsonMode.Object)
	public Object getDefaultParamNames() {
		if (null != this.defaultParamNames) {
			return this.defaultParamNames;
		}
		ValueExpression _ve = getValueExpression("defaultParamNames");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>defaultParamNames</code> property.
	 * </p>
	 */
	public void setDefaultParamNames(Object defaultParamNames) {
		this.defaultParamNames = defaultParamNames;
		this.handleConfig("defaultParamNames", defaultParamNames);
	}

	private Object paramNames;

	/**
	 * <p>
	 * An object containing properties which specify the names of the paging and
	 * sorting parameters passed to remote servers when loading blocks of data.
	 * By default, this object takes the following form:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{
	 *     start : &lt;em&gt;'start'&lt;/em&gt;,  &lt;i&gt;// The parameter name which specifies the start row&lt;/i&gt;
	 *     limit : &lt;em&gt;'limit'&lt;/em&gt;,  &lt;i&gt;// The parameter name which specifies number of rows to &lt;b&gt;return&lt;/b&gt;&lt;/i&gt;
	 *     sort : &lt;em&gt;'sort'&lt;/em&gt;,    &lt;i&gt;// The parameter name which specifies the column to sort on&lt;/i&gt;
	 *     dir : &lt;em&gt;'dir'&lt;/em&gt;       &lt;i&gt;// The parameter name which specifies the sort direction&lt;/i&gt;
	 * }&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * The server must produce the requested data block upon receipt of these
	 * parameter names. If different parameter names are required, this property
	 * can be overriden using a configuration property.
	 * </p>
	 * 
	 * <p>
	 * A <a href="output/Ext.PagingToolbar.html"
	 * ext:cls="Ext.PagingToolbar">PagingToolbar</a> bound to this Store uses
	 * this property to determine the parameter names to use in its <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load"
	 * ext:cls="Ext.data.Store">requests</a>.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getParamNames() {
		if (null != this.paramNames) {
			return this.paramNames;
		}
		ValueExpression _ve = getValueExpression("paramNames");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>paramNames</code> property.
	 * </p>
	 */
	public void setParamNames(Object paramNames) {
		this.paramNames = paramNames;
		this.handleConfig("paramNames", paramNames);
	}

	private Object proxy;

	/**
	 * The <a href="output/Ext.data.DataProxy.html"
	 * ext:cls="Ext.data.DataProxy">DataProxy</a> object which providesaccess to
	 * a data object. See
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-url" ext:member="url" ext:cls="Ext.data.Store">url</a></code>
	 * .
	 */
	@ClientConfig(JsonMode.Object)
	public Object getProxy() {
		if (null != this.proxy) {
			return this.proxy;
		}
		ValueExpression _ve = getValueExpression("proxy");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>proxy</code> property.
	 * </p>
	 */
	public void setProxy(Object proxy) {
		this.proxy = proxy;
		this.handleConfig("proxy", proxy);
	}

	private Boolean pruneModifiedRecords;

	/**
	 * <tt>true</tt> to clear all modified recordinformation each time the store
	 * is loaded or when a record is removed (defaults to <tt>false</tt>). See
	 * <a href="output/Ext.data.Store.html#Ext.data.Store-getModifiedRecords"
	 * ext:member="getModifiedRecords"
	 * ext:cls="Ext.data.Store">getModifiedRecords</a> for the accessor method
	 * to retrieve the modified records.
	 */
	public Boolean getPruneModifiedRecords() {
		if (null != this.pruneModifiedRecords) {
			return this.pruneModifiedRecords;
		}
		ValueExpression _ve = getValueExpression("pruneModifiedRecords");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>pruneModifiedRecords</code> property.
	 * </p>
	 */
	public void setPruneModifiedRecords(Boolean pruneModifiedRecords) {
		this.pruneModifiedRecords = pruneModifiedRecords;
		this.handleConfig("pruneModifiedRecords", pruneModifiedRecords);
	}

	private Object reader;

	/**
	 * The <a href="output/Ext.data.DataReader.html"
	 * ext:cls="Ext.data.DataReader">Reader</a> object which processes thedata
	 * object and returns an Array of <a href="output/Ext.data.Record.html"
	 * ext:cls="Ext.data.Record">Ext.data.Record</a> objects which are cached
	 * keyed by their <b>
	 * <tt><a href="output/Ext.data.Record.html#Ext.data.Record-id" ext:member="id" ext:cls="Ext.data.Record">id</a></tt>
	 * </b> property.
	 */
	@ClientConfig(JsonMode.Object)
	public Object getReader() {
		if (null != this.reader) {
			return this.reader;
		}
		ValueExpression _ve = getValueExpression("reader");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>reader</code> property.
	 * </p>
	 */
	public void setReader(Object reader) {
		this.reader = reader;
		this.handleConfig("reader", reader);
	}

	private Boolean remoteSort;

	/**
	 * <tt>true</tt> if sorting is to be handled byrequesting the
	 * <tt><a href="output/Ext.data.Store.html#Ext.data.Store-proxy" ext:member="proxy" ext:cls="Ext.data.Store">Proxy</a></tt>
	 * to provide a refreshed version of the data object in sorted order, as
	 * opposed to sorting the Record cache in place (defaults to <tt>false</tt>
	 * ).
	 * 
	 * <p>
	 * If <tt>remoteSort</tt> is <tt>true</tt>, then clicking on a <a
	 * href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">Grid
	 * Column</a>'s <a href="output/Ext.grid.Column.html#Ext.grid.Column-header"
	 * ext:member="header" ext:cls="Ext.grid.Column">header</a> causes the
	 * current page to be requested from the server appending the following two
	 * parameters to the <b>
	 * <tt><a href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load" ext:cls="Ext.data.Store">params</a></tt>
	 * </b>:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><b><tt>sort</tt></b> : String
	 * 
	 * <p class="sub-desc">
	 * The <tt>name</tt> (as specified in the Record's <a
	 * href="output/Ext.data.Field.html" ext:cls="Ext.data.Field">Field
	 * definition</a>) of the field to sort on.
	 * </p>
	 * </li>
	 * 
	 * <li><b><tt>dir</tt></b> : String
	 * 
	 * <p class="sub-desc">
	 * The direction of the sort, 'ASC' or 'DESC' (case-sensitive).
	 * </p>
	 * </li>
	 * </ul>
	 * </div>
	 * 
	 * <br>
	 * <br>
	 */
	public Boolean getRemoteSort() {
		if (null != this.remoteSort) {
			return this.remoteSort;
		}
		ValueExpression _ve = getValueExpression("remoteSort");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>remoteSort</code> property.
	 * </p>
	 */
	public void setRemoteSort(Boolean remoteSort) {
		this.remoteSort = remoteSort;
		this.handleConfig("remoteSort", remoteSort);
	}

	private Boolean restful;

	/**
	 * Defaults to <tt>false</tt>. Set to <tt>true</tt>to have the Store and the
	 * set Proxy operate in a RESTful manner. The store will automatically
	 * generate GET, POST, PUT and DELETE requests to the server. The HTTP
	 * method used for any given CRUD action is described in <a
	 * href="output/Ext.data.Api.html#Ext.data.Api-restActions"
	 * ext:member="restActions"
	 * ext:cls="Ext.data.Api">Ext.data.Api.restActions</a>. For additional
	 * information see <a
	 * href="output/Ext.data.DataProxy.html#Ext.data.DataProxy-restful"
	 * ext:member="restful"
	 * ext:cls="Ext.data.DataProxy">Ext.data.DataProxy.restful</a>.
	 * 
	 * <p>
	 * <b>Note</b>: if
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-restful" ext:member="restful" ext:cls="Ext.data.Store">restful</a>:true</code>
	 * <code>batch</code> will internally be set to <tt>false</tt>.
	 * </p>
	 */
	public Boolean getRestful() {
		if (null != this.restful) {
			return this.restful;
		}
		ValueExpression _ve = getValueExpression("restful");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>restful</code> property.
	 * </p>
	 */
	public void setRestful(Boolean restful) {
		this.restful = restful;
		this.handleConfig("restful", restful);
	}

	private Object sortInfo;

	/**
	 * A config object to specify the sort order in therequest of a Store's <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load"
	 * ext:cls="Ext.data.Store">load</a> operation. Note that for local sorting,
	 * the <tt>direction</tt> property is case-sensitive. See also <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-remoteSort"
	 * ext:member="remoteSort" ext:cls="Ext.data.Store">remoteSort</a> and <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-paramNames"
	 * ext:member="paramNames" ext:cls="Ext.data.Store">paramNames</a>. For
	 * example:
	 * 
	 * <pre>
	 * &lt;code&gt;sortInfo: {
	 *     field: &lt;em&gt;'fieldName'&lt;/em&gt;,
	 *     direction: &lt;em&gt;'ASC'&lt;/em&gt; &lt;i&gt;// or &lt;em&gt;'DESC'&lt;/em&gt; (&lt;b&gt;case&lt;/b&gt; sensitive &lt;b&gt;for&lt;/b&gt; local sorting)&lt;/i&gt;
	 * }&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getSortInfo() {
		if (null != this.sortInfo) {
			return this.sortInfo;
		}
		ValueExpression _ve = getValueExpression("sortInfo");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>sortInfo</code> property.
	 * </p>
	 */
	public void setSortInfo(Object sortInfo) {
		this.sortInfo = sortInfo;
		this.handleConfig("sortInfo", sortInfo);
	}

	private String storeId;

	/**
	 * If passed, the id to use to register with the<b><a
	 * href="output/Ext.StoreMgr.html" ext:cls="Ext.StoreMgr">StoreMgr</a></b>.
	 * 
	 * <p>
	 * <b>Note</b>: if a (deprecated)
	 * <tt><a href="output/Ext.data.Store.html#Ext.data.Store-id" ext:member="id" ext:cls="Ext.data.Store">id</a></tt>
	 * is specified it will supersede the <tt>storeId</tt> assignment.
	 * </p>
	 */
	public String getStoreId() {
		if (null != this.storeId) {
			return this.storeId;
		}
		ValueExpression _ve = getValueExpression("storeId");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>storeId</code> property.
	 * </p>
	 */
	public void setStoreId(String storeId) {
		this.storeId = storeId;
		this.handleConfig("storeId", storeId);
	}

	private String url;

	/**
	 * If a
	 * <tt><a href="output/Ext.data.Store.html#Ext.data.Store-proxy" ext:member="proxy" ext:cls="Ext.data.Store">proxy</a></tt>
	 * is notspecified the <tt>url</tt> will be used to implicitly configure a
	 * <a href="output/Ext.data.HttpProxy.html"
	 * ext:cls="Ext.data.HttpProxy">HttpProxy</a> if an <tt>url</tt> is
	 * specified. Typically this option, or the
	 * <code><a href="output/Ext.data.Store.html#Ext.data.Store-data" ext:member="data" ext:cls="Ext.data.Store">data</a></code>
	 * option will be specified.
	 */
	public String getUrl() {
		if (null != this.url) {
			return this.url;
		}
		ValueExpression _ve = getValueExpression("url");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>url</code> property.
	 * </p>
	 */
	public void setUrl(String url) {
		this.url = url;
		this.handleConfig("url", url);
	}

	private Object writer;

	/**
	 * <p>
	 * The <a href="output/Ext.data.DataWriter.html"
	 * ext:cls="Ext.data.DataWriter">Writer</a> object which processes a record
	 * object for being written to the server-side database.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * When a writer is installed into a Store the <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-add" ext:member="add"
	 * ext:cls="Ext.data.Store">add</a>, <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-remove"
	 * ext:member="remove" ext:cls="Ext.data.Store">remove</a>, and <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-update"
	 * ext:member="update" ext:cls="Ext.data.Store">update</a> events on the
	 * store are monitored in order to remotely <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-createRecords"
	 * ext:member="createRecords" ext:cls="Ext.data.Store">create records</a>,
	 * <a href="output/Ext.data.Store.html#Ext.data.Store-destroyRecord"
	 * ext:member="destroyRecord" ext:cls="Ext.data.Store">destroy records</a>,
	 * or <a href="output/Ext.data.Store.html#Ext.data.Store-updateRecord"
	 * ext:member="updateRecord" ext:cls="Ext.data.Store">update records</a>.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * The proxy for this store will relay any <a
	 * href="output/Ext.data.Store.html#Ext.data.Store-writexception"
	 * ext:member="writexception" ext:cls="Ext.data.Store">writexception</a>
	 * events to this store.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Sample implementation:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; writer = &lt;b&gt;new&lt;/b&gt; &lt;a href=&quot;output/Ext.data.JsonWriter.html&quot; ext:cls=&quot;Ext.data.JsonWriter&quot;&gt;Ext.data.JsonWriter&lt;/a&gt;({
	 *     encode: true,
	 *     writeAllFields: true &lt;i&gt;// write all fields, not just those that changed&lt;/i&gt;
	 * });
	 * 
	 * &lt;i&gt;// Typical Store collecting the Proxy, Reader and Writer together.&lt;/i&gt;
	 * &lt;b&gt;var&lt;/b&gt; store = &lt;b&gt;new&lt;/b&gt; Ext.data.Store({
	 *     storeId: &lt;em&gt;'user'&lt;/em&gt;,
	 *     root: &lt;em&gt;'records'&lt;/em&gt;,
	 *     proxy: proxy,
	 *     reader: reader,
	 *     writer: writer,     &lt;i&gt;// &lt;-- plug a DataWriter into the store just as you would a Reader&lt;/i&gt;
	 *     paramsAsHash: true,
	 *     autoSave: false    &lt;i&gt;// &lt;-- false to delay executing create, update, destroy requests&lt;/i&gt;
	 *                         &lt;i&gt;//     until specifically told to &lt;b&gt;do&lt;/b&gt; so.&lt;/i&gt;
	 * });&lt;/code&gt;
	 * </pre>
	 * 
	 * <br>
	 * <br>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getWriter() {
		if (null != this.writer) {
			return this.writer;
		}
		ValueExpression _ve = getValueExpression("writer");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>writer</code> property.
	 * </p>
	 */
	public void setWriter(Object writer) {
		this.writer = writer;
		this.handleConfig("writer", writer);
	}

	// =========================================================
	// -------------------------------------------------
	// ActionSource/ActionSource2 Properties

	/**
	 * {@inheritDoc}
	 * 
	 * @deprecated This has been replaced by {@link #getActionExpression}.
	 */
	public MethodBinding getAction() {
		MethodBinding result = null;
		MethodExpression me;

		if (null != (me = getActionExpression())) {
			// if the MethodExpression is an instance of our private
			// wrapper class.
			if (me.getClass()
					.equals(MethodExpressionMethodBindingAdapter.class)) {
				result = ((MethodExpressionMethodBindingAdapter) me)
						.getWrapped();
			} else {
				result = new MethodBindingMethodExpressionAdapter(me);
			}
		}
		return result;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @deprecated This has been replaced by
	 *             {@link #setActionExpression(javax.el.MethodExpression)}.
	 */
	public void setAction(MethodBinding action) {
		MethodExpressionMethodBindingAdapter adapter;
		if (null != action) {
			adapter = new MethodExpressionMethodBindingAdapter(action);
			setActionExpression(adapter);
		} else {
			setActionExpression(null);
		}
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @deprecated Use {@link #getActionListeners} instead.
	 */
	public MethodBinding getActionListener() {
		return this.methodBindingActionListener;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @deprecated This has been replaced by
	 *             {@link #addActionListener(javax.faces.event.ActionListener)}.
	 */
	public void setActionListener(MethodBinding actionListener) {
		this.methodBindingActionListener = actionListener;
	}

	/**
	 * <p>
	 * The immediate flag.
	 * </p>
	 */
	private Boolean immediate;

	public boolean isImmediate() {

		if (this.immediate != null) {
			return (this.immediate);
		}
		ValueExpression ve = getValueExpression("immediate");
		if (ve != null) {
			try {
				return (Boolean.TRUE.equals(ve.getValue(getFacesContext()
						.getELContext())));
			} catch (ELException e) {
				throw new FacesException(e);
			}
		} else {
			return (false);
		}

	}

	public void setImmediate(boolean immediate) {
		this.immediate = immediate;
	}

	private MethodBinding methodBindingActionListener = null;

	// ---------------------------------------------------- ActionSource /
	// ActionSource2 Methods

	/**
	 * <p>
	 * The {@link MethodExpression} that, when invoked, yields the literal
	 * outcome value.
	 * </p>
	 */
	private MethodExpression actionExpression = null;

	public MethodExpression getActionExpression() {
		return actionExpression;
	}

	/**
	 * <p>
	 * Override the <code>UICommand</code> method to wrap the argument
	 * <code>MethodExpression</code> so that any return value it may yield from
	 * invocation is ignored and <code>null</code> is returned instead.
	 * </p>
	 */
	public void setActionExpression(final MethodExpression actionExpression) {
		MethodExpression me = new MethodExpression() {
			private static final long serialVersionUID = -2814853297324284566L;

			public boolean equals(Object other) {
				return actionExpression.equals(other);
			}

			public String getExpressionString() {
				return actionExpression.getExpressionString();
			}

			public int hashCode() {
				return actionExpression.hashCode();
			}

			public boolean isLiteralText() {
				return actionExpression.isLiteralText();
			}

			public MethodInfo getMethodInfo(ELContext context) {
				return actionExpression.getMethodInfo(context);
			}

			public Object invoke(ELContext context, Object[] params) {
				return actionExpression.invoke(context, params);
			}
		};
		this.actionExpression = me;
	}

	public void addActionListener(ActionListener listener) {
		addFacesListener(listener);
	}

	public ActionListener[] getActionListeners() {
		ActionListener al[] = (ActionListener[]) getFacesListeners(ActionListener.class);
		return (al);
	}

	/**
	 * @throws NullPointerException
	 *             {@inheritDoc}
	 */
	public void removeActionListener(ActionListener listener) {
		removeFacesListener(listener);
	}

	// ----------------------------------------------------- UIComponent Methods

	/**
	 * <p>
	 * In addition to to the default {@link UIComponent#broadcast} processing,
	 * pass the {@link ActionEvent} being broadcast to the method referenced by
	 * <code>actionListener</code> (if any), and to the default
	 * {@link ActionListener} registered on the
	 * {@link javax.faces.application.Application}.
	 * </p>
	 * 
	 * @param event
	 *            {@link FacesEvent} to be broadcast
	 * 
	 * @throws AbortProcessingException
	 *             Signal the JavaServer Faces implementation that no further
	 *             processing on the current event should be performed
	 * @throws IllegalArgumentException
	 *             if the implementation class of this {@link FacesEvent} is not
	 *             supported by this component
	 * @throws NullPointerException
	 *             if <code>event</code> is <code>null</code>
	 */
	public void broadcast(FacesEvent event) throws AbortProcessingException {
		// Perform standard superclass processing (including calling our
		// ActionListeners)
		super.broadcast(event);

		if (event instanceof ActionEvent) {
			FacesContext context = getFacesContext();

			// Notify the specified action listener method (if any)
			MethodBinding mb = getActionListener();
			if (mb != null) {
				mb.invoke(context, new Object[] { event });
			}

			// Invoke the default ActionListener
			ActionListener listener = context.getApplication()
					.getActionListener();
			if (listener != null) {
				listener.processAction((ActionEvent) event);
			}
		}
	}

	/**
	 * <p>
	 * Intercept <code>queueEvent</code> and, for {@link ActionEvent}s, mark the
	 * phaseId for the event to be <code>PhaseId.APPLY_REQUEST_VALUES</code> if
	 * the <code>immediate</code> flag is true,
	 * <code>PhaseId.INVOKE_APPLICATION</code> otherwise.
	 * </p>
	 */

	public void queueEvent(FacesEvent e) {
		UIComponent c = e.getComponent();
		if (e instanceof ActionEvent && c instanceof ActionSource) {
			if (((ActionSource) c).isImmediate()) {
				e.setPhaseId(PhaseId.APPLY_REQUEST_VALUES);
			} else {
				e.setPhaseId(PhaseId.INVOKE_APPLICATION);
			}
		}
		super.queueEvent(e);
	}

	// ================================================================

	// =action custom==================================================
	private Object beanAction;

	@ClientConfig(value = JsonMode.Ignore)
	public Object getBeanAction() {
		if (null != this.beanAction) {
			return this.beanAction;
		}
		ValueExpression _ve = getValueExpression("beanAction");
		if (_ve != null) {
			return  _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	public void setBeanAction(Object beanAction) {
		this.beanAction = beanAction;
	}

	private String beanMethod;

	@ClientConfig(value = JsonMode.Ignore)
	public String getBeanMethod() {
		if (null != this.beanMethod) {
			return this.beanMethod;
		}
		ValueExpression _ve = getValueExpression("beanMethod");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	public void setBeanMethod(String beanMethod) {
		this.beanMethod = beanMethod;
	}
	
	private String beanClass;

	@ClientConfig(value = JsonMode.Ignore)
	public String getBeanClass() {
		if (null != this.beanClass) {
			return this.beanClass;
		}
		ValueExpression _ve = getValueExpression("beanClass");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	public void setBeanClass(String beanClass) {
		this.beanClass = beanClass;
	}

	private Integer totalCount;

	@ClientConfig(value = JsonMode.Ignore)
	public Integer getTotalCount() {
		if (null != this.totalCount) {
			return this.totalCount;
		}
		ValueExpression _ve = getValueExpression("totalCount");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	public void setTotalCount(Integer totalCount) {
		this.totalCount = totalCount;
	}

	// ================================================================

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[25];
		}
		_values[0] = super.saveState(_context);
		_values[1] = autoDestroy;
		_values[2] = autoLoad;
		_values[3] = autoSave;
		_values[4] = baseParams;
		_values[5] = batch;
		_values[6] = data;
		_values[7] = defaultParamNames;
		_values[8] = paramNames;
		_values[9] = proxy;
		_values[10] = pruneModifiedRecords;
		_values[11] = reader;
		_values[12] = remoteSort;
		_values[13] = restful;
		_values[14] = sortInfo;
		_values[15] = storeId;
		_values[16] = url;
		_values[17] = writer;

		_values[18] = saveAttachedState(_context, methodBindingActionListener);
		_values[19] = saveAttachedState(_context, actionExpression);
		_values[20] = immediate;

		_values[21] = beanAction;
		_values[22] = beanMethod;
		_values[23] = beanClass;
		_values[24] = totalCount;
		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.autoDestroy = (Boolean) _values[1];
		this.handleConfig("autoDestroy", this.autoDestroy);
		this.autoLoad = (Boolean) _values[2];
		this.handleConfig("autoLoad", this.autoLoad);
		this.autoSave = (Boolean) _values[3];
		this.handleConfig("autoSave", this.autoSave);
		this.baseParams = (Object) _values[4];
		this.handleConfig("baseParams", this.baseParams);
		this.batch = (Boolean) _values[5];
		this.handleConfig("batch", this.batch);
		this.data = (Object) _values[6];
		this.handleConfig("data", this.data);
		this.defaultParamNames = (Object) _values[7];
		this.handleConfig("defaultParamNames", this.defaultParamNames);
		this.paramNames = (Object) _values[8];
		this.handleConfig("paramNames", this.paramNames);
		this.proxy = (Object) _values[9];
		this.handleConfig("proxy", this.proxy);
		this.pruneModifiedRecords = (Boolean) _values[10];
		this.handleConfig("pruneModifiedRecords", this.pruneModifiedRecords);
		this.reader = (Object) _values[11];
		this.handleConfig("reader", this.reader);
		this.remoteSort = (Boolean) _values[12];
		this.handleConfig("remoteSort", this.remoteSort);
		this.restful = (Boolean) _values[13];
		this.handleConfig("restful", this.restful);
		this.sortInfo = (Object) _values[14];
		this.handleConfig("sortInfo", this.sortInfo);
		this.storeId = (String) _values[15];
		this.handleConfig("storeId", this.storeId);
		this.url = (String) _values[16];
		this.handleConfig("url", this.url);
		this.writer = (Object) _values[17];
		this.handleConfig("writer", this.writer);

		methodBindingActionListener = (MethodBinding) restoreAttachedState(
				_context, _values[18]);
		actionExpression = (MethodExpression) restoreAttachedState(_context,
				_values[19]);
		immediate = (Boolean) _values[20];

		this.beanAction =  _values[21];
		this.beanMethod = (String) _values[22];
		this.beanClass = (String) _values[23];
		this.totalCount = (Integer) _values[24];
	}
}