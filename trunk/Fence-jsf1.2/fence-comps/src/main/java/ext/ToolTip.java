package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;

/**
 *Note:This java code is auto generated by abner,do not edit it. A standard
 * tooltip implementation for providing additional information when hovering
 * over a target element.
 */
@InstanceOf("Ext.ToolTip")
public class ToolTip extends Tip {
	public static final String COMPONENT_TYPE = "Ext.ToolTip";
	public static final String COMPONENT_FAMILY = "Ext.ToolTip";

	/**
	 * <p>
	 * Create a new {@link ToolTip} instance with default property values.
	 * </p>
	 */
	public ToolTip() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Integer anchorOffset;

	/**
	 * A numeric pixel value used to offset the defaultposition of the anchor
	 * arrow (defaults to 0). When the anchor position is on the top or bottom
	 * of the tooltip, anchorOffset will be used as a horizontal offset.
	 * Likewise, when the anchor position is on the left or right side,
	 * anchorOffset will be used as a vertical offset.
	 */
	public Integer getAnchorOffset() {
		if (null != this.anchorOffset) {
			return this.anchorOffset;
		}
		ValueExpression _ve = getValueExpression("anchorOffset");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>anchorOffset</code> property.
	 * </p>
	 */
	public void setAnchorOffset(Integer anchorOffset) {
		this.anchorOffset = anchorOffset;
		this.handleConfig("anchorOffset", anchorOffset);
	}

	private Boolean anchorToTarget;

	/**
	 * True to anchor the tooltip to the target element,false to anchor it
	 * relative to the mouse coordinates (defaults to true). When anchorToTarget
	 * is true, use <a href="output/Ext.ToolTip.html#Ext.ToolTip-defaultAlign"
	 * ext:member="defaultAlign" ext:cls="Ext.ToolTip">defaultAlign</a> to
	 * control tooltip alignment to the target element. When anchorToTarget is
	 * false, use <a href="output/Ext.ToolTip.html#Ext.ToolTip-anchorPosition"
	 * ext:member="anchorPosition" ext:cls="Ext.ToolTip">anchorPosition</a>
	 * instead to control alignment.
	 */
	public Boolean getAnchorToTarget() {
		if (null != this.anchorToTarget) {
			return this.anchorToTarget;
		}
		ValueExpression _ve = getValueExpression("anchorToTarget");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>anchorToTarget</code> property.
	 * </p>
	 */
	public void setAnchorToTarget(Boolean anchorToTarget) {
		this.anchorToTarget = anchorToTarget;
		this.handleConfig("anchorToTarget", anchorToTarget);
	}

	private Boolean autoHide;

	/**
	 * True to automatically hide the tooltip after themouse exits the target
	 * element or after the <a
	 * href="output/Ext.ToolTip.html#Ext.ToolTip-dismissDelay"
	 * ext:member="dismissDelay" ext:cls="Ext.ToolTip">dismissDelay</a> has
	 * expired if set (defaults to true). If <a href="output/closable.html"
	 * ext:cls="closable">closable</a> = true a close tool button will be
	 * rendered into the tooltip header.
	 */
	public Boolean getAutoHide() {
		if (null != this.autoHide) {
			return this.autoHide;
		}
		ValueExpression _ve = getValueExpression("autoHide");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoHide</code> property.
	 * </p>
	 */
	public void setAutoHide(Boolean autoHide) {
		this.autoHide = autoHide;
		this.handleConfig("autoHide", autoHide);
	}

	private String delegate;

	/**
	 * <p>
	 * Optional. A <a href="output/Ext.DomQuery.html"
	 * ext:cls="Ext.DomQuery">DomQuery</a> selector which allows selection of
	 * individual elements within the <a
	 * href="output/Ext.ToolTip.html#Ext.ToolTip-target" ext:member="target"
	 * ext:cls="Ext.ToolTip">target</a> element to trigger showing and hiding
	 * the ToolTip as the mouse moves within the target.
	 * </p>
	 * 
	 * <p>
	 * When specified, the child element of the target which caused a show event
	 * is placed into the <a
	 * href="output/Ext.ToolTip.html#Ext.ToolTip-triggerElement"
	 * ext:member="triggerElement" ext:cls="Ext.ToolTip">triggerElement</a>
	 * property before the ToolTip is shown.
	 * </p>
	 * 
	 * <p>
	 * This may be useful when a Component has regular, repeating elements in
	 * it, each of which need a Tooltip which contains information specific to
	 * that element. For example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myGrid = &lt;b&gt;new&lt;/b&gt; Ext.grid.gridPanel(gridConfig);
	 * myGrid.on(&lt;em&gt;'render'&lt;/em&gt;, &lt;b&gt;function&lt;/b&gt;(grid) {
	 *     &lt;b&gt;var&lt;/b&gt; store = grid.getStore();  &lt;i&gt;// Capture the Store.
	 * &lt;/i&gt;
	 *     &lt;b&gt;var&lt;/b&gt; view = grid.getView();    &lt;i&gt;// Capture the GridView.
	 * &lt;/i&gt;
	 *     myGrid.tip = &lt;b&gt;new&lt;/b&gt; Ext.ToolTip({
	 *         target: view.mainBody,    &lt;i&gt;// The overall target element.
	 * &lt;/i&gt;
	 *         delegate: &lt;em&gt;'.x-grid3-row'&lt;/em&gt;, &lt;i&gt;// Each grid row causes its own seperate show and hide.
	 * &lt;/i&gt;
	 *         trackMouse: true,         &lt;i&gt;// Moving within the row should not hide the tip.
	 * &lt;/i&gt;
	 *         renderTo: document.body,  &lt;i&gt;// Render immediately so that tip.body can be referenced prior to the first show.
	 * &lt;/i&gt;
	 *         listeners: {              &lt;i&gt;// Change content dynamically depending on which element triggered the show.
	 * &lt;/i&gt;
	 *             beforeshow: &lt;b&gt;function&lt;/b&gt; updateTipBody(tip) {
	 *                 &lt;b&gt;var&lt;/b&gt; rowIndex = view.findRowIndex(tip.triggerElement);
	 *                 tip.body.dom.innerHTML = &lt;em&gt;&quot;Over Record ID &quot;&lt;/em&gt; + store.getAt(rowIndex).id;
	 *             }
	 *         }
	 *     });
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public String getDelegate() {
		if (null != this.delegate) {
			return this.delegate;
		}
		ValueExpression _ve = getValueExpression("delegate");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>delegate</code> property.
	 * </p>
	 */
	public void setDelegate(String delegate) {
		this.delegate = delegate;
		this.handleConfig("delegate", delegate);
	}

	private Integer dismissDelay;

	/**
	 * Delay in milliseconds before the tooltipautomatically hides (defaults to
	 * 5000). To disable automatic hiding, set dismissDelay = 0.
	 */
	public Integer getDismissDelay() {
		if (null != this.dismissDelay) {
			return this.dismissDelay;
		}
		ValueExpression _ve = getValueExpression("dismissDelay");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>dismissDelay</code> property.
	 * </p>
	 */
	public void setDismissDelay(Integer dismissDelay) {
		this.dismissDelay = dismissDelay;
		this.handleConfig("dismissDelay", dismissDelay);
	}

	private Integer hideDelay;

	/**
	 * Delay in milliseconds after the mouse exits thetarget element but before
	 * the tooltip actually hides (defaults to 200). Set to 0 for the tooltip to
	 * hide immediately.
	 */
	public Integer getHideDelay() {
		if (null != this.hideDelay) {
			return this.hideDelay;
		}
		ValueExpression _ve = getValueExpression("hideDelay");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideDelay</code> property.
	 * </p>
	 */
	public void setHideDelay(Integer hideDelay) {
		this.hideDelay = hideDelay;
		this.handleConfig("hideDelay", hideDelay);
	}

	private Object mouseOffset;

	/**
	 * An XY offset from the mouse position where thetooltip should be shown
	 * (defaults to [15,18]).
	 */
	@ClientConfig(JsonMode.Array)
	public Object getMouseOffset() {
		if (null != this.mouseOffset) {
			return this.mouseOffset;
		}
		ValueExpression _ve = getValueExpression("mouseOffset");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>mouseOffset</code> property.
	 * </p>
	 */
	public void setMouseOffset(Object mouseOffset) {
		this.mouseOffset = mouseOffset;
		this.handleConfig("mouseOffset", mouseOffset);
	}

	private Integer showDelay;

	/**
	 * Delay in milliseconds before the tooltipdisplays after the mouse enters
	 * the target element (defaults to 500)
	 */
	public Integer getShowDelay() {
		if (null != this.showDelay) {
			return this.showDelay;
		}
		ValueExpression _ve = getValueExpression("showDelay");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>showDelay</code> property.
	 * </p>
	 */
	public void setShowDelay(Integer showDelay) {
		this.showDelay = showDelay;
		this.handleConfig("showDelay", showDelay);
	}

	private Object target;

	/**
	 * The target HTMLElement, Ext.Element or id tomonitor for mouseover events
	 * to trigger showing this ToolTip.
	 */
	public Object getTarget() {
		if (null != this.target) {
			return this.target;
		}
		ValueExpression _ve = getValueExpression("target");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>target</code> property.
	 * </p>
	 */
	public void setTarget(Object target) {
		this.target = target;
		this.handleConfig("target", target);
	}

	private Boolean trackMouse;

	/**
	 * True to have the tooltip follow the mouse as itmoves over the target
	 * element (defaults to false).
	 */
	public Boolean getTrackMouse() {
		if (null != this.trackMouse) {
			return this.trackMouse;
		}
		ValueExpression _ve = getValueExpression("trackMouse");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>trackMouse</code> property.
	 * </p>
	 */
	public void setTrackMouse(Boolean trackMouse) {
		this.trackMouse = trackMouse;
		this.handleConfig("trackMouse", trackMouse);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[11];
		}
		_values[0] = super.saveState(_context);
		_values[1] = anchorOffset;
		_values[2] = anchorToTarget;
		_values[3] = autoHide;
		_values[4] = delegate;
		_values[5] = dismissDelay;
		_values[6] = hideDelay;
		_values[7] = mouseOffset;
		_values[8] = showDelay;
		_values[9] = target;
		_values[10] = trackMouse;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.anchorOffset = (Integer) _values[1];
		this.handleConfig("anchorOffset", this.anchorOffset);
		this.anchorToTarget = (Boolean) _values[2];
		this.handleConfig("anchorToTarget", this.anchorToTarget);
		this.autoHide = (Boolean) _values[3];
		this.handleConfig("autoHide", this.autoHide);
		this.delegate = (String) _values[4];
		this.handleConfig("delegate", this.delegate);
		this.dismissDelay = (Integer) _values[5];
		this.handleConfig("dismissDelay", this.dismissDelay);
		this.hideDelay = (Integer) _values[6];
		this.handleConfig("hideDelay", this.hideDelay);
		this.mouseOffset = (Object) _values[7];
		this.handleConfig("mouseOffset", this.mouseOffset);
		this.showDelay = (Integer) _values[8];
		this.handleConfig("showDelay", this.showDelay);
		this.target = (Object) _values[9];
		this.handleConfig("target", this.target);
		this.trackMouse = (Boolean) _values[10];
		this.handleConfig("trackMouse", this.trackMouse);

	}
}