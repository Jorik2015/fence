package ext.form;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it. Provides a
 * convenient wrapper for TextFields that adds a clickable trigger button (looks
 * like a combobox by default). The trigger has no default action, so you must
 * assign a function to implement the trigger click handler by overriding <a
 * href="output/Ext.form.TriggerField.html#Ext.form.TriggerField-onTriggerClick"
 * ext:member="onTriggerClick"
 * ext:cls="Ext.form.TriggerField">onTriggerClick</a>. You can create a
 * TriggerField directly, as it renders exactly like a combobox for which you
 * can provide a custom implementation. For example:
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; trigger = &lt;b&gt;new&lt;/b&gt; Ext.form.TriggerField();
 * trigger.onTriggerClick = myTriggerFn;
 * trigger.applyToMarkup(&lt;em&gt;'my-field'&lt;/em&gt;);&lt;/code&gt;
 * </pre>
 * 
 * However, in general you will most likely want to use TriggerField as the base
 * class for a reusable component. <a href="output/Ext.form.DateField.html"
 * ext:cls="Ext.form.DateField">Ext.form.DateField</a> and <a
 * href="output/Ext.form.ComboBox.html"
 * ext:cls="Ext.form.ComboBox">Ext.form.ComboBox</a> are perfect examples of
 * this.
 */
@XType("trigger")
@InstanceOf("Ext.form.TriggerField")
public class TriggerField extends TextField {
	public static final String COMPONENT_TYPE = "Ext.form.TriggerField";
	public static final String COMPONENT_FAMILY = "Ext.form.TriggerField";

	/**
	 * <p>
	 * Create a new {@link TriggerField} instance with default property values.
	 * </p>
	 */
	public TriggerField() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String autoCreate;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element spec, or true for a default
	 * element spec. Used to create the <a
	 * href="output/Ext.Component.html#Ext.Component-getEl" ext:member="getEl"
	 * ext:cls="Ext.Component">Element</a> which will encapsulate this
	 * Component. See
	 * <tt><a href="output/Ext.Component.html#Ext.Component-autoEl" ext:member="autoEl" ext:cls="Ext.Component">autoEl</a></tt>
	 * for details. Defaults to:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{tag: &lt;em&gt;&quot;input&quot;&lt;/em&gt;, type: &lt;em&gt;&quot;text&quot;&lt;/em&gt;, size: &lt;em&gt;&quot;16&quot;&lt;/em&gt;, autocomplete: &lt;em&gt;&quot;off&quot;&lt;/em&gt;}&lt;/code&gt;
	 * </pre>
	 */
	public String getAutoCreate() {
		if (null != this.autoCreate) {
			return this.autoCreate;
		}
		ValueExpression _ve = getValueExpression("autoCreate");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoCreate</code> property.
	 * </p>
	 */
	public void setAutoCreate(String autoCreate) {
		this.autoCreate = autoCreate;
		this.handleConfig("autoCreate", autoCreate);
	}

	private Boolean editable;

	/**
	 * <tt>false</tt> to prevent the user from typingtext directly into the
	 * field, the field will only respond to a click on the trigger to set the
	 * value. (defaults to <tt>true</tt>)
	 */
	public Boolean getEditable() {
		if (null != this.editable) {
			return this.editable;
		}
		ValueExpression _ve = getValueExpression("editable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>editable</code> property.
	 * </p>
	 */
	public void setEditable(Boolean editable) {
		this.editable = editable;
		this.handleConfig("editable", editable);
	}

	private Boolean hideTrigger;

	/**
	 * <tt>true</tt> to hide the trigger element anddisplay only the base text
	 * field (defaults to <tt>false</tt>)
	 */
	public Boolean getHideTrigger() {
		if (null != this.hideTrigger) {
			return this.hideTrigger;
		}
		ValueExpression _ve = getValueExpression("hideTrigger");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideTrigger</code> property.
	 * </p>
	 */
	public void setHideTrigger(Boolean hideTrigger) {
		this.hideTrigger = hideTrigger;
		this.handleConfig("hideTrigger", hideTrigger);
	}

	private String triggerClass;

	/**
	 * An additional CSS class used to style the triggerbutton. The trigger will
	 * always get the class <tt>'x-form-trigger'</tt> by default and <tt>triggerClass</tt> will be
	 * <b>appended</b> if specified.
	 */
	public String getTriggerClass() {
		if (null != this.triggerClass) {
			return this.triggerClass;
		}
		ValueExpression _ve = getValueExpression("triggerClass");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>triggerClass</code> property.
	 * </p>
	 */
	public void setTriggerClass(String triggerClass) {
		this.triggerClass = triggerClass;
		this.handleConfig("triggerClass", triggerClass);
	}

	private Object triggerConfig;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> config object specifying the
	 * structure of the trigger element for this Field. (Optional).
	 * </p>
	 * 
	 * <p>
	 * Specify this when you need a customized element to act as the trigger
	 * button for a TriggerField.
	 * </p>
	 * 
	 * <p>
	 * Note that when using this option, it is the developer's responsibility to
	 * ensure correct sizing, positioning and appearance of the trigger.
	 * Defaults to:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{tag: &lt;em&gt;&quot;img&quot;&lt;/em&gt;, src: Ext.BLANK_IMAGE_URL, cls: &lt;em&gt;&quot;x-form-trigger &quot;&lt;/em&gt; + this.triggerClass}&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getTriggerConfig() {
		if (null != this.triggerConfig) {
			return this.triggerConfig;
		}
		ValueExpression _ve = getValueExpression("triggerConfig");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>triggerConfig</code> property.
	 * </p>
	 */
	public void setTriggerConfig(Object triggerConfig) {
		this.triggerConfig = triggerConfig;
		this.handleConfig("triggerConfig", triggerConfig);
	}

	private String wrapFocusClass;

	/**
	 * The class added to the to the wrap of thetrigger element. Defaults to
	 * <tt>x-trigger-wrap-focus</tt>.
	 */
	public String getWrapFocusClass() {
		if (null != this.wrapFocusClass) {
			return this.wrapFocusClass;
		}
		ValueExpression _ve = getValueExpression("wrapFocusClass");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>wrapFocusClass</code> property.
	 * </p>
	 */
	public void setWrapFocusClass(String wrapFocusClass) {
		this.wrapFocusClass = wrapFocusClass;
		this.handleConfig("wrapFocusClass", wrapFocusClass);
	}
	
	private Object onTriggerClick;

	@ClientConfig(JsonMode.Function)
	public Object getOnTriggerClick() {
		if (null != this.onTriggerClick) {
			return this.onTriggerClick;
		}
		ValueExpression _ve = getValueExpression("onTriggerClick");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	public void setOnTriggerClick(Object onTriggerClick) {
		this.onTriggerClick = onTriggerClick;
		this.handleConfig("onTriggerClick", onTriggerClick);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[8];
		}
		_values[0] = super.saveState(_context);
		_values[1] = autoCreate;
		_values[2] = editable;
		_values[3] = hideTrigger;
		_values[4] = triggerClass;
		_values[5] = triggerConfig;
		_values[6] = wrapFocusClass;
		_values[7] = onTriggerClick;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.autoCreate = (String) _values[1];
		this.handleConfig("autoCreate", this.autoCreate);
		this.editable = (Boolean) _values[2];
		this.handleConfig("editable", this.editable);
		this.hideTrigger = (Boolean) _values[3];
		this.handleConfig("hideTrigger", this.hideTrigger);
		this.triggerClass = (String) _values[4];
		this.handleConfig("triggerClass", this.triggerClass);
		this.triggerConfig = (Object) _values[5];
		this.handleConfig("triggerConfig", this.triggerConfig);
		this.wrapFocusClass = (String) _values[6];
		this.handleConfig("wrapFocusClass", this.wrapFocusClass);
		this.onTriggerClick =  _values[7];
		this.handleConfig("onTriggerClick", this.onTriggerClick);

	}
}