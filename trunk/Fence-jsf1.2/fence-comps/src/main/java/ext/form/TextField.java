package ext.form;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * Basic text field. Can be used as a direct replacement for traditional text
 * inputs, or as the base class for more sophisticated input controls (like <a
 * href="output/Ext.form.TextArea.html"
 * ext:cls="Ext.form.TextArea">Ext.form.TextArea</a> and <a
 * href="output/Ext.form.ComboBox.html"
 * ext:cls="Ext.form.ComboBox">Ext.form.ComboBox</a>).
 * </p>
 * 
 * <p>
 * <b><u>Validation</u></b>
 * </p>
 * 
 * <p>
 * Field validation is processed in a particular order. If validation fails at
 * any particular step the validation routine halts.
 * </p>
 * 
 * <div class="mdetail-params">
 * <ul>
 * <li><b>1. Field specific validator</b>
 * 
 * <div class="sub-desc">
 * <p>
 * If a field is configured with a
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-validator" ext:member="validator" ext:cls="Ext.form.TextField">validator</a></code>
 * function, it will be passed the current field value. The
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-validator" ext:member="validator" ext:cls="Ext.form.TextField">validator</a></code>
 * function is expected to return boolean <tt>true</tt> if the value is valid or
 * return a string to represent the invalid message if invalid.
 * </p>
 * </div></li>
 * 
 * <li><b>2. Built in Validation</b>
 * 
 * <div class="sub-desc">
 * <p>
 * Basic validation is affected with the following configuration properties:
 * </p>
 * 
 * <pre>
 * &lt;u&gt;Validation&lt;/u&gt;    &lt;u&gt;Invalid Message&lt;/u&gt;
 * &lt;code&gt;&lt;a href=&quot;output/Ext.form.TextField.html#Ext.form.TextField-allowBlank&quot; ext:member=&quot;allowBlank&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;allowBlank&lt;/a&gt;    &lt;a href=&quot;output/Ext.form.TextField.html#Ext.form.TextField-emptyText&quot; ext:member=&quot;emptyText&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;emptyText&lt;/a&gt;&lt;/code&gt;
 * &lt;code&gt;&lt;a href=&quot;output/Ext.form.TextField.html#Ext.form.TextField-minLength&quot; ext:member=&quot;minLength&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;minLength&lt;/a&gt;     &lt;a href=&quot;output/Ext.form.TextField.html#Ext.form.TextField-minLengthText&quot; ext:member=&quot;minLengthText&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;minLengthText&lt;/a&gt;&lt;/code&gt;
 * &lt;code&gt;&lt;a href=&quot;output/Ext.form.TextField.html#Ext.form.TextField-maxLength&quot; ext:member=&quot;maxLength&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;maxLength&lt;/a&gt;     &lt;a href=&quot;output/Ext.form.TextField.html#Ext.form.TextField-maxLengthText&quot; ext:member=&quot;maxLengthText&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;maxLengthText&lt;/a&gt;&lt;/code&gt;
 * </pre>
 * 
 * </div></li>
 * 
 * <li><b>3. Preconfigured Validation Types (VTypes)</b>
 * 
 * <div class="sub-desc">
 * <p>
 * Using VTypes offers a convenient way to reuse validation. If a field is
 * configured with a
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-vtype" ext:member="vtype" ext:cls="Ext.form.TextField">vtype</a></code>
 * , the corresponding <a href="output/Ext.form.VTypes.html"
 * ext:cls="Ext.form.VTypes">VTypes</a> validation function will be used for
 * validation. If invalid, either the field's
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-vtypeText" ext:member="vtypeText" ext:cls="Ext.form.TextField">vtypeText</a></code>
 * or the VTypes vtype Text property will be used for the invalid message.
 * Keystrokes on the field will be filtered according to the VTypes vtype Mask
 * property.
 * </p>
 * </div></li>
 * 
 * <li><b>4. Field specific regex test</b>
 * 
 * <div class="sub-desc">
 * <p>
 * Each field may also specify a
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-regex" ext:member="regex" ext:cls="Ext.form.TextField">regex</a></code>
 * test. The invalid message for this test is configured with
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-regexText" ext:member="regexText" ext:cls="Ext.form.TextField">regexText</a></code>
 * .
 * </p>
 * </div></li>
 * 
 * <li><b>Alter Validation Behavior</b>
 * 
 * <div class="sub-desc">
 * <p>
 * Validation behavior for each field can be configured:
 * </p>
 * 
 * <ul>
 * <li>
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-invalidText" ext:member="invalidText" ext:cls="Ext.form.TextField">invalidText</a></code>
 * : the default validation message to show if any validation step above does
 * not provide a message when invalid</li>
 * 
 * <li>
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-maskRe" ext:member="maskRe" ext:cls="Ext.form.TextField">maskRe</a></code>
 * : filter out keystrokes before any validation occurs</li>
 * 
 * <li>
 * 
 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-stripCharsRe" ext:member="stripCharsRe" ext:cls="Ext.form.TextField">stripCharsRe</a></code>
 * : filter characters after being typed in, but before being validated</li>
 * 
 * <li>
 * <code><a href="output/Ext.form.Field.html#Ext.form.Field-invalidClass" ext:member="invalidClass" ext:cls="Ext.form.Field">invalidClass</a></code>
 * : alternate style when invalid</li>
 * 
 * <li>
 * <code><a href="output/Ext.form.Field.html#Ext.form.Field-validateOnBlur" ext:member="validateOnBlur" ext:cls="Ext.form.Field">validateOnBlur</a></code>,
 * <code><a href="output/Ext.form.Field.html#Ext.form.Field-validationDelay" ext:member="validationDelay" ext:cls="Ext.form.Field">validationDelay</a></code>
 * , and
 * 
 * <code><a href="output/Ext.form.Field.html#Ext.form.Field-validationEvent" ext:member="validationEvent" ext:cls="Ext.form.Field">validationEvent</a></code>
 * : modify how/when validation is triggered</li>
 * </ul>
 * </div></li>
 * </ul>
 * </div>
 */
@XType("textfield")
@InstanceOf("Ext.form.TextField")
public class TextField extends Field {
	public static final String COMPONENT_TYPE = "Ext.form.TextField";
	public static final String COMPONENT_FAMILY = "Ext.form.TextField";

	/**
	 * <p>
	 * Create a new {@link TextField} instance with default property values.
	 * </p>
	 */
	public TextField() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean allowBlank;

	/**
	 * Specify <tt>false</tt> to validate that thevalue's length is &gt; 0
	 * (defaults to <tt>true</tt>)
	 */
	public Boolean getAllowBlank() {
		if (null != this.allowBlank) {
			return this.allowBlank;
		}
		ValueExpression _ve = getValueExpression("allowBlank");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>allowBlank</code> property.
	 * </p>
	 */
	public void setAllowBlank(Boolean allowBlank) {
		this.allowBlank = allowBlank;
		this.handleConfig("allowBlank", allowBlank);
	}

	private String blankText;

	/**
	 * The error text to display if the <b>
	 * <tt><a href="output/Ext.form.TextField.html#Ext.form.TextField-allowBlank" ext:member="allowBlank" ext:cls="Ext.form.TextField">allowBlank</a></tt>
	 * </b> validationfails (defaults to <tt>'This field is required'</tt>)
	 */
	public String getBlankText() {
		if (null != this.blankText) {
			return this.blankText;
		}
		ValueExpression _ve = getValueExpression("blankText");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>blankText</code> property.
	 * </p>
	 */
	public void setBlankText(String blankText) {
		this.blankText = blankText;
		this.handleConfig("blankText", blankText);
	}

	private Boolean disableKeyFilter;

	/**
	 * Specify <tt>true</tt> to disable input keystrokefiltering (defaults to
	 * <tt>false</tt>)
	 */
	public Boolean getDisableKeyFilter() {
		if (null != this.disableKeyFilter) {
			return this.disableKeyFilter;
		}
		ValueExpression _ve = getValueExpression("disableKeyFilter");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>disableKeyFilter</code> property.
	 * </p>
	 */
	public void setDisableKeyFilter(Boolean disableKeyFilter) {
		this.disableKeyFilter = disableKeyFilter;
		this.handleConfig("disableKeyFilter", disableKeyFilter);
	}

	private String emptyClass;

	/**
	 * The CSS class to apply to an empty field to stylethe <b>
	 * <tt><a href="output/Ext.form.TextField.html#Ext.form.TextField-emptyText" ext:member="emptyText" ext:cls="Ext.form.TextField">emptyText</a></tt>
	 * </b> (defaults to <tt>'x-form-empty-field'</tt>). This class is automatically added and removed as
	 * needed depending on the current field value.
	 */
	public String getEmptyClass() {
		if (null != this.emptyClass) {
			return this.emptyClass;
		}
		ValueExpression _ve = getValueExpression("emptyClass");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>emptyClass</code> property.
	 * </p>
	 */
	public void setEmptyClass(String emptyClass) {
		this.emptyClass = emptyClass;
		this.handleConfig("emptyClass", emptyClass);
	}

	private String emptyText;

	/**
	 * The default text to place into an empty field(defaults to <tt>null</tt>).
	 * <b>Note</b>: that this value will be submitted to the server if this
	 * field is enabled and configured with a <a
	 * href="output/Ext.form.TextField.html#Ext.form.TextField-name"
	 * ext:member="name" ext:cls="Ext.form.TextField">name</a>.
	 */
	public String getEmptyText() {
		if (null != this.emptyText) {
			return this.emptyText;
		}
		ValueExpression _ve = getValueExpression("emptyText");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>emptyText</code> property.
	 * </p>
	 */
	public void setEmptyText(String emptyText) {
		this.emptyText = emptyText;
		this.handleConfig("emptyText", emptyText);
	}

	private Boolean enableKeyEvents;

	/**
	 * <tt>true</tt> to enable the proxying of keyevents for the HTML input
	 * field (defaults to <tt>false</tt>)
	 */
	public Boolean getEnableKeyEvents() {
		if (null != this.enableKeyEvents) {
			return this.enableKeyEvents;
		}
		ValueExpression _ve = getValueExpression("enableKeyEvents");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>enableKeyEvents</code> property.
	 * </p>
	 */
	public void setEnableKeyEvents(Boolean enableKeyEvents) {
		this.enableKeyEvents = enableKeyEvents;
		this.handleConfig("enableKeyEvents", enableKeyEvents);
	}

	private Boolean grow;

	/**
	 * <tt>true</tt> if this field should automaticallygrow and shrink to its
	 * content (defaults to <tt>false</tt>)
	 */
	public Boolean getGrow() {
		if (null != this.grow) {
			return this.grow;
		}
		ValueExpression _ve = getValueExpression("grow");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>grow</code> property.
	 * </p>
	 */
	public void setGrow(Boolean grow) {
		this.grow = grow;
		this.handleConfig("grow", grow);
	}

	private Integer growMax;

	/**
	 * The maximum width to allow when
	 * <code><b><a href="output/Ext.form.TextField.html#Ext.form.TextField-grow" ext:member="grow" ext:cls="Ext.form.TextField">grow</a></b> =true</code>
	 * (defaults to <tt>800</tt>)
	 */
	public Integer getGrowMax() {
		if (null != this.growMax) {
			return this.growMax;
		}
		ValueExpression _ve = getValueExpression("growMax");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>growMax</code> property.
	 * </p>
	 */
	public void setGrowMax(Integer growMax) {
		this.growMax = growMax;
		this.handleConfig("growMax", growMax);
	}

	private Integer growMin;

	/**
	 * The minimum width to allow when
	 * <code><b><a href="output/Ext.form.TextField.html#Ext.form.TextField-grow" ext:member="grow" ext:cls="Ext.form.TextField">grow</a></b> =true</code>
	 * (defaults to <tt>30</tt>)
	 */
	public Integer getGrowMin() {
		if (null != this.growMin) {
			return this.growMin;
		}
		ValueExpression _ve = getValueExpression("growMin");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>growMin</code> property.
	 * </p>
	 */
	public void setGrowMin(Integer growMin) {
		this.growMin = growMin;
		this.handleConfig("growMin", growMin);
	}

	private String maskRe;

	/**
	 * An input mask regular expression that will beused to filter keystrokes
	 * that do not match (defaults to <tt>null</tt>)
	 */
	@ClientConfig(JsonMode.Object)
	public String getMaskRe() {
		if (null != this.maskRe) {
			return this.maskRe;
		}
		ValueExpression _ve = getValueExpression("maskRe");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maskRe</code> property.
	 * </p>
	 */
	public void setMaskRe(String maskRe) {
		this.maskRe = maskRe;
		this.handleConfig("maskRe", maskRe);
	}

	private Integer maxLength;

	/**
	 * Maximum input field length allowed by validation(defaults to
	 * Number.MAX_VALUE). This behavior is intended to provide instant feedback
	 * to the user by improving usability to allow pasting and editing or
	 * overtyping and back tracking. To restrict the maximum number of
	 * characters that can be entered into the field use
	 * <tt><b><a href="output/Ext.form.Field.html#Ext.form.Field-autoCreate" ext:member="autoCreate" ext:cls="Ext.form.Field">autoCreate</a></b></tt>
	 * to add any attributes you want to a field, for example:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myField = &lt;b&gt;new&lt;/b&gt; Ext.form.NumberField({
	 *     id: &lt;em&gt;'mobile'&lt;/em&gt;,
	 *     anchor:&lt;em&gt;'90%'&lt;/em&gt;,
	 *     fieldLabel: &lt;em&gt;'Mobile'&lt;/em&gt;,
	 *     maxLength: 16, &lt;i&gt;// &lt;b&gt;for&lt;/b&gt; validation&lt;/i&gt;
	 *     autoCreate: {tag: &lt;em&gt;'input'&lt;/em&gt;, type: &lt;em&gt;'text'&lt;/em&gt;, size: &lt;em&gt;'20'&lt;/em&gt;, autocomplete: &lt;em&gt;'off'&lt;/em&gt;, maxlength: &lt;em&gt;'10'&lt;/em&gt;}
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public Integer getMaxLength() {
		if (null != this.maxLength) {
			return this.maxLength;
		}
		ValueExpression _ve = getValueExpression("maxLength");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maxLength</code> property.
	 * </p>
	 */
	public void setMaxLength(Integer maxLength) {
		this.maxLength = maxLength;
		this.handleConfig("maxLength", maxLength);
	}

	private String maxLengthText;

	/**
	 * Error text to display if the <b>
	 * 
	 * <tt><a href="output/Ext.form.TextField.html#Ext.form.TextField-maxLength" ext:member="maxLength" ext:cls="Ext.form.TextField">maximumlength</a></tt>
	 * </b> validation fails (defaults to <tt>'The maximum
length for this field is {maxLength}'</tt>)
	 */
	public String getMaxLengthText() {
		if (null != this.maxLengthText) {
			return this.maxLengthText;
		}
		ValueExpression _ve = getValueExpression("maxLengthText");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maxLengthText</code> property.
	 * </p>
	 */
	public void setMaxLengthText(String maxLengthText) {
		this.maxLengthText = maxLengthText;
		this.handleConfig("maxLengthText", maxLengthText);
	}

	private Integer minLength;

	/**
	 * Minimum input field length required (defaults to<tt>0</tt>)
	 */
	public Integer getMinLength() {
		if (null != this.minLength) {
			return this.minLength;
		}
		ValueExpression _ve = getValueExpression("minLength");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>minLength</code> property.
	 * </p>
	 */
	public void setMinLength(Integer minLength) {
		this.minLength = minLength;
		this.handleConfig("minLength", minLength);
	}

	private String minLengthText;

	/**
	 * Error text to display if the <b>
	 * 
	 * <tt><a href="output/Ext.form.TextField.html#Ext.form.TextField-minLength" ext:member="minLength" ext:cls="Ext.form.TextField">minimumlength</a></tt>
	 * </b> validation fails (defaults to <tt>'The minimum
length for this field is {minLength}'</tt>)
	 */
	public String getMinLengthText() {
		if (null != this.minLengthText) {
			return this.minLengthText;
		}
		ValueExpression _ve = getValueExpression("minLengthText");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>minLengthText</code> property.
	 * </p>
	 */
	public void setMinLengthText(String minLengthText) {
		this.minLengthText = minLengthText;
		this.handleConfig("minLengthText", minLengthText);
	}

	private String regex;

	/**
	 * A JavaScript RegExp object to be tested againstthe field value during
	 * validation (defaults to <tt>null</tt>). If the test fails, the field will
	 * be marked invalid using <b>
	 * <tt><a href="output/Ext.form.TextField.html#Ext.form.TextField-regexText" ext:member="regexText" ext:cls="Ext.form.TextField">regexText</a></tt>
	 * </b>.
	 */
	@ClientConfig(JsonMode.Object)
	public String getRegex() {
		if (null != this.regex) {
			return this.regex;
		}
		ValueExpression _ve = getValueExpression("regex");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>regex</code> property.
	 * </p>
	 */
	public void setRegex(String regex) {
		this.regex = regex;
		this.handleConfig("regex", regex);
	}

	private String regexText;

	/**
	 * The error text to display if <b>
	 * <tt><a href="output/Ext.form.TextField.html#Ext.form.TextField-regex" ext:member="regex" ext:cls="Ext.form.TextField">regex</a></tt>
	 * </b>is used and the test fails during validation (defaults to <tt>''</tt>)
	 */
	public String getRegexText() {
		if (null != this.regexText) {
			return this.regexText;
		}
		ValueExpression _ve = getValueExpression("regexText");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>regexText</code> property.
	 * </p>
	 */
	public void setRegexText(String regexText) {
		this.regexText = regexText;
		this.handleConfig("regexText", regexText);
	}

	private Boolean selectOnFocus;

	/**
	 * <tt>true</tt> to automatically select anyexisting field text when the
	 * field receives input focus (defaults to <tt>false</tt>)
	 */
	public Boolean getSelectOnFocus() {
		if (null != this.selectOnFocus) {
			return this.selectOnFocus;
		}
		ValueExpression _ve = getValueExpression("selectOnFocus");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>selectOnFocus</code> property.
	 * </p>
	 */
	public void setSelectOnFocus(Boolean selectOnFocus) {
		this.selectOnFocus = selectOnFocus;
		this.handleConfig("selectOnFocus", selectOnFocus);
	}

	private String stripCharsRe;

	/**
	 * A JavaScript RegExp object used to stripunwanted content from the value
	 * before validation (defaults to <tt>null</tt>).
	 */
	@ClientConfig(JsonMode.Object)
	public String getStripCharsRe() {
		if (null != this.stripCharsRe) {
			return this.stripCharsRe;
		}
		ValueExpression _ve = getValueExpression("stripCharsRe");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>stripCharsRe</code> property.
	 * </p>
	 */
	public void setStripCharsRe(String stripCharsRe) {
		this.stripCharsRe = stripCharsRe;
		this.handleConfig("stripCharsRe", stripCharsRe);
	}

	private Object validator_;

	/**
	 * A custom validation function to be called duringfield validation
	 * (defaults to <tt>null</tt>). If specified, this function will be called
	 * first, allowing the developer to override the default validation process.
	 * This function will be passed the current field value and expected to
	 * return boolean <tt>true</tt> if the value is valid or a string error
	 * message if invalid.
	 */
	@ClientConfig(value = JsonMode.Function, name = "validator")
	public Object getValidator_() {
		if (null != this.validator_) {
			return this.validator_;
		}
		ValueExpression _ve = getValueExpression("validator_");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>validator</code> property.
	 * </p>
	 */
	public void setValidator(Object validator_) {
		this.validator_ = validator_;
		this.handleConfig("validator_", validator_);
	}

	private String vtype;

	/**
	 * A validation type name as defined in <a
	 * href="output/Ext.form.VTypes.html"
	 * ext:cls="Ext.form.VTypes">Ext.form.VTypes</a> (defaults to<tt>null</tt>)
	 */
	public String getVtype() {
		if (null != this.vtype) {
			return this.vtype;
		}
		ValueExpression _ve = getValueExpression("vtype");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>vtype</code> property.
	 * </p>
	 */
	public void setVtype(String vtype) {
		this.vtype = vtype;
		this.handleConfig("vtype", vtype);
	}

	private String vtypeText;

	/**
	 * A custom error message to display in place of thedefault message provided
	 * for the <b>
	 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-vtype" ext:member="vtype" ext:cls="Ext.form.TextField">vtype</a></code>
	 * </b> currently set for this field (defaults to <tt>''</tt>). <b>Note</b>: only
	 * applies if <b>
	 * <code><a href="output/Ext.form.TextField.html#Ext.form.TextField-vtype" ext:member="vtype" ext:cls="Ext.form.TextField">vtype</a></code>
	 * </b> is set, else ignored.
	 */
	public String getVtypeText() {
		if (null != this.vtypeText) {
			return this.vtypeText;
		}
		ValueExpression _ve = getValueExpression("vtypeText");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>vtypeText</code> property.
	 * </p>
	 */
	public void setVtypeText(String vtypeText) {
		this.vtypeText = vtypeText;
		this.handleConfig("vtypeText", vtypeText);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[22];
		}
		_values[0] = super.saveState(_context);
		_values[1] = allowBlank;
		_values[2] = blankText;
		_values[3] = disableKeyFilter;
		_values[4] = emptyClass;
		_values[5] = emptyText;
		_values[6] = enableKeyEvents;
		_values[7] = grow;
		_values[8] = growMax;
		_values[9] = growMin;
		_values[10] = maskRe;
		_values[11] = maxLength;
		_values[12] = maxLengthText;
		_values[13] = minLength;
		_values[14] = minLengthText;
		_values[15] = regex;
		_values[16] = regexText;
		_values[17] = selectOnFocus;
		_values[18] = stripCharsRe;
		_values[19] = validator_;
		_values[20] = vtype;
		_values[21] = vtypeText;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.allowBlank = (Boolean) _values[1];
		this.handleConfig("allowBlank", this.allowBlank);
		this.blankText = (String) _values[2];
		this.handleConfig("blankText", this.blankText);
		this.disableKeyFilter = (Boolean) _values[3];
		this.handleConfig("disableKeyFilter", this.disableKeyFilter);
		this.emptyClass = (String) _values[4];
		this.handleConfig("emptyClass", this.emptyClass);
		this.emptyText = (String) _values[5];
		this.handleConfig("emptyText", this.emptyText);
		this.enableKeyEvents = (Boolean) _values[6];
		this.handleConfig("enableKeyEvents", this.enableKeyEvents);
		this.grow = (Boolean) _values[7];
		this.handleConfig("grow", this.grow);
		this.growMax = (Integer) _values[8];
		this.handleConfig("growMax", this.growMax);
		this.growMin = (Integer) _values[9];
		this.handleConfig("growMin", this.growMin);
		this.maskRe = (String) _values[10];
		this.handleConfig("maskRe", this.maskRe);
		this.maxLength = (Integer) _values[11];
		this.handleConfig("maxLength", this.maxLength);
		this.maxLengthText = (String) _values[12];
		this.handleConfig("maxLengthText", this.maxLengthText);
		this.minLength = (Integer) _values[13];
		this.handleConfig("minLength", this.minLength);
		this.minLengthText = (String) _values[14];
		this.handleConfig("minLengthText", this.minLengthText);
		this.regex = (String) _values[15];
		this.handleConfig("regex", this.regex);
		this.regexText = (String) _values[16];
		this.handleConfig("regexText", this.regexText);
		this.selectOnFocus = (Boolean) _values[17];
		this.handleConfig("selectOnFocus", this.selectOnFocus);
		this.stripCharsRe = (String) _values[18];
		this.handleConfig("stripCharsRe", this.stripCharsRe);
		this.validator_ = (Object) _values[19];
		this.handleConfig("validator", this.validator_);
		this.vtype = (String) _values[20];
		this.handleConfig("vtype", this.vtype);
		this.vtypeText = (String) _values[21];
		this.handleConfig("vtypeText", this.vtypeText);

	}
}