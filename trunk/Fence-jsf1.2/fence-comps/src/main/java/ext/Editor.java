package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it. A base editor
 * field that handles displaying/hiding on demand and has some built-in sizing
 * and event handling logic.
 */
@XType("editor")
@InstanceOf("Ext.Editor")
public class Editor extends Component {
	public static final String COMPONENT_TYPE = "Ext.Editor";
	public static final String COMPONENT_FAMILY = "Ext.Editor";

	/**
	 * <p>
	 * Create a new {@link Editor} instance with default property values.
	 * </p>
	 */
	public Editor() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String alignment;

	/**
	 * The position to align to (see <a
	 * href="output/Ext.Element.html#Ext.Element-alignTo" ext:member="alignTo"
	 * ext:cls="Ext.Element">Ext.Element.alignTo</a>for more details, defaults
	 * to "c-c?").
	 */
	public String getAlignment() {
		if (null != this.alignment) {
			return this.alignment;
		}
		ValueExpression _ve = getValueExpression("alignment");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>alignment</code> property.
	 * </p>
	 */
	public void setAlignment(String alignment) {
		this.alignment = alignment;
		this.handleConfig("alignment", alignment);
	}

	private Boolean allowBlur;

	/**
	 * True to <a href="output/Ext.Editor.html#Ext.Editor-completeEdit"
	 * ext:member="completeEdit" ext:cls="Ext.Editor">complete the
	 * editingprocess</a> if in edit mode when the field is blurred. Defaults to
	 * <tt>false</tt>.
	 */
	public Boolean getAllowBlur() {
		if (null != this.allowBlur) {
			return this.allowBlur;
		}
		ValueExpression _ve = getValueExpression("allowBlur");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>allowBlur</code> property.
	 * </p>
	 */
	public void setAllowBlur(Boolean allowBlur) {
		this.allowBlur = allowBlur;
		this.handleConfig("allowBlur", allowBlur);
	}

	private Boolean autoSize;

	/**
	 * True for the editor to automatically adopt thesize of the element being
	 * edited, "width" to adopt the width only, or "height" to adopt the height
	 * only (defaults to false)
	 */
	public Boolean getAutoSize() {
		if (null != this.autoSize) {
			return this.autoSize;
		}
		ValueExpression _ve = getValueExpression("autoSize");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoSize</code> property.
	 * </p>
	 */
	public void setAutoSize(Boolean autoSize) {
		this.autoSize = autoSize;
		this.handleConfig("autoSize", autoSize);
	}

	private Boolean cancelOnEsc;

	/**
	 * True to cancel the edit when the escape key ispressed (defaults to false)
	 */
	public Boolean getCancelOnEsc() {
		if (null != this.cancelOnEsc) {
			return this.cancelOnEsc;
		}
		ValueExpression _ve = getValueExpression("cancelOnEsc");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>cancelOnEsc</code> property.
	 * </p>
	 */
	public void setCancelOnEsc(Boolean cancelOnEsc) {
		this.cancelOnEsc = cancelOnEsc;
		this.handleConfig("cancelOnEsc", cancelOnEsc);
	}

	private Boolean completeOnEnter;

	/**
	 * True to complete the edit when the enter key ispressed (defaults to
	 * false)
	 */
	public Boolean getCompleteOnEnter() {
		if (null != this.completeOnEnter) {
			return this.completeOnEnter;
		}
		ValueExpression _ve = getValueExpression("completeOnEnter");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>completeOnEnter</code> property.
	 * </p>
	 */
	public void setCompleteOnEnter(Boolean completeOnEnter) {
		this.completeOnEnter = completeOnEnter;
		this.handleConfig("completeOnEnter", completeOnEnter);
	}

	private Boolean constrain;

	/**
	 * True to constrain the editor to theviewport
	 */
	public Boolean getConstrain() {
		if (null != this.constrain) {
			return this.constrain;
		}
		ValueExpression _ve = getValueExpression("constrain");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>constrain</code> property.
	 * </p>
	 */
	public void setConstrain(Boolean constrain) {
		this.constrain = constrain;
		this.handleConfig("constrain", constrain);
	}

	private Object field;

	/**
	 * The Field object (or descendant) or configobject for field
	 */
	@ClientConfig(JsonMode.Object)
	public Object getField() {
		if (null != this.field) {
			return this.field;
		}
		ValueExpression _ve = getValueExpression("field");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>field</code> property.
	 * </p>
	 */
	public void setField(Object field) {
		this.field = field;
		this.handleConfig("field", field);
	}

	private Boolean hideEl;

	/**
	 * False to keep the bound element visible whilethe editor is displayed
	 * (defaults to true)
	 */
	public Boolean getHideEl() {
		if (null != this.hideEl) {
			return this.hideEl;
		}
		ValueExpression _ve = getValueExpression("hideEl");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideEl</code> property.
	 * </p>
	 */
	public void setHideEl(Boolean hideEl) {
		this.hideEl = hideEl;
		this.handleConfig("hideEl", hideEl);
	}

	private Boolean ignoreNoChange;

	/**
	 * True to skip the edit completion process (nosave, no events fired) if the
	 * user completes an edit and the value has not changed (defaults to false).
	 * Applies only to string values - edits for other data types will never be
	 * ignored.
	 */
	public Boolean getIgnoreNoChange() {
		if (null != this.ignoreNoChange) {
			return this.ignoreNoChange;
		}
		ValueExpression _ve = getValueExpression("ignoreNoChange");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>ignoreNoChange</code> property.
	 * </p>
	 */
	public void setIgnoreNoChange(Boolean ignoreNoChange) {
		this.ignoreNoChange = ignoreNoChange;
		this.handleConfig("ignoreNoChange", ignoreNoChange);
	}

	private Boolean revertInvalid;

	/**
	 * True to automatically revert the field value andcancel the edit when the
	 * user completes an edit and the field validation fails (defaults to true)
	 */
	public Boolean getRevertInvalid() {
		if (null != this.revertInvalid) {
			return this.revertInvalid;
		}
		ValueExpression _ve = getValueExpression("revertInvalid");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>revertInvalid</code> property.
	 * </p>
	 */
	public void setRevertInvalid(Boolean revertInvalid) {
		this.revertInvalid = revertInvalid;
		this.handleConfig("revertInvalid", revertInvalid);
	}

	private Boolean shadow;

	/**
	 * "sides" for sides/bottom only, "frame" for 4-wayshadow, and "drop" for
	 * bottom-right shadow (defaults to "frame")
	 */
	public Boolean getShadow() {
		if (null != this.shadow) {
			return this.shadow;
		}
		ValueExpression _ve = getValueExpression("shadow");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>shadow</code> property.
	 * </p>
	 */
	public void setShadow(Boolean shadow) {
		this.shadow = shadow;
		this.handleConfig("shadow", shadow);
	}

	private Boolean swallowKeys;

	/**
	 * Handle the keydown/keypress events so they don'tpropagate (defaults to
	 * true)
	 */
	public Boolean getSwallowKeys() {
		if (null != this.swallowKeys) {
			return this.swallowKeys;
		}
		ValueExpression _ve = getValueExpression("swallowKeys");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>swallowKeys</code> property.
	 * </p>
	 */
	public void setSwallowKeys(Boolean swallowKeys) {
		this.swallowKeys = swallowKeys;
		this.handleConfig("swallowKeys", swallowKeys);
	}

	private Boolean updateEl;

	/**
	 * True to update the innerHTML of the boundelement when the update
	 * completes (defaults to false)
	 */
	public Boolean getUpdateEl() {
		if (null != this.updateEl) {
			return this.updateEl;
		}
		ValueExpression _ve = getValueExpression("updateEl");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>updateEl</code> property.
	 * </p>
	 */
	public void setUpdateEl(Boolean updateEl) {
		this.updateEl = updateEl;
		this.handleConfig("updateEl", updateEl);
	}

	private Object value;

	/**
	 * The data value of the underlying field (defaultsto "")
	 */
	@ClientConfig(JsonMode.Object)
	public Object getValue() {
		if (null != this.value) {
			return this.value;
		}
		ValueExpression _ve = getValueExpression("value");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>value</code> property.
	 * </p>
	 */
	public void setValue(Object value) {
		this.value = value;
		this.handleConfig("value", value);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[15];
		}
		_values[0] = super.saveState(_context);
		_values[1] = alignment;
		_values[2] = allowBlur;
		_values[3] = autoSize;
		_values[4] = cancelOnEsc;
		_values[5] = completeOnEnter;
		_values[6] = constrain;
		_values[7] = field;
		_values[8] = hideEl;
		_values[9] = ignoreNoChange;
		_values[10] = revertInvalid;
		_values[11] = shadow;
		_values[12] = swallowKeys;
		_values[13] = updateEl;
		_values[14] = value;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.alignment = (String) _values[1];
		this.handleConfig("alignment", this.alignment);
		this.allowBlur = (Boolean) _values[2];
		this.handleConfig("allowBlur", this.allowBlur);
		this.autoSize = (Boolean) _values[3];
		this.handleConfig("autoSize", this.autoSize);
		this.cancelOnEsc = (Boolean) _values[4];
		this.handleConfig("cancelOnEsc", this.cancelOnEsc);
		this.completeOnEnter = (Boolean) _values[5];
		this.handleConfig("completeOnEnter", this.completeOnEnter);
		this.constrain = (Boolean) _values[6];
		this.handleConfig("constrain", this.constrain);
		this.field = (Object) _values[7];
		this.handleConfig("field", this.field);
		this.hideEl = (Boolean) _values[8];
		this.handleConfig("hideEl", this.hideEl);
		this.ignoreNoChange = (Boolean) _values[9];
		this.handleConfig("ignoreNoChange", this.ignoreNoChange);
		this.revertInvalid = (Boolean) _values[10];
		this.handleConfig("revertInvalid", this.revertInvalid);
		this.shadow = (Boolean) _values[11];
		this.handleConfig("shadow", this.shadow);
		this.swallowKeys = (Boolean) _values[12];
		this.handleConfig("swallowKeys", this.swallowKeys);
		this.updateEl = (Boolean) _values[13];
		this.handleConfig("updateEl", this.updateEl);
		this.value = (Object) _values[14];
		this.handleConfig("value", this.value);

	}
}