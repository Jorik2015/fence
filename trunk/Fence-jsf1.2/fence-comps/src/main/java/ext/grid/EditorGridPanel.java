package ext.grid;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * This class extends the <a href="output/Ext.grid.GridPanel.html"
 * ext:cls="Ext.grid.GridPanel">GridPanel Class</a> to provide cell editing on
 * selected <a href="output/Ext.grid.Column.html"
 * ext:cls="Ext.grid.Column">columns</a>. The editable columns are specified by
 * providing an <a
 * href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-editor"
 * ext:member="editor" ext:cls="Ext.grid.ColumnModel">editor</a> in the <a
 * href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">column
 * configuration</a>.
 * </p>
 * 
 * <p>
 * Editability of columns may be controlled programatically by inserting an
 * implementation of <a
 * href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-isCellEditable"
 * ext:member="isCellEditable" ext:cls="Ext.grid.ColumnModel">isCellEditable</a>
 * into the <a href="output/Ext.grid.ColumnModel.html"
 * ext:cls="Ext.grid.ColumnModel">ColumnModel</a>.
 * </p>
 * 
 * <p>
 * Editing is performed on the value of the <i>field</i> specified by the
 * column's
 * <tt><a href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-dataIndex" ext:member="dataIndex" ext:cls="Ext.grid.ColumnModel">dataIndex</a></tt>
 * in the backing <a href="output/Ext.data.Store.html"
 * ext:cls="Ext.data.Store">Store</a> (so if you are using a <a
 * href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-setRenderer"
 * ext:member="setRenderer" ext:cls="Ext.grid.ColumnModel">renderer</a> in order
 * to display transformed data, this must be accounted for).
 * </p>
 * 
 * <p>
 * If a value-to-description mapping is used to render a column, then a <a
 * href="output/Ext.form.Field.html#Ext.form.Field-ComboBox"
 * ext:member="ComboBox" ext:cls="Ext.form.Field">ComboBox</a> which uses the
 * same <a href="output/Ext.form.Field.html#Ext.form.Field-valueField"
 * ext:member="valueField" ext:cls="Ext.form.Field">value</a>-to-<a
 * href="output/Ext.form.Field.html#Ext.form.Field-displayFieldField"
 * ext:member="displayFieldField" ext:cls="Ext.form.Field">description</a>
 * mapping would be an appropriate editor.
 * </p>
 * 
 * If there is a more complex mismatch between the visible data in the grid, and
 * the editable data in the <a href="output/Edt.data.Store.html"
 * ext:cls="Edt.data.Store">Store</a>, then code to transform the data both
 * before and after editing can be injected using the <a href=
 * "output/Ext.grid.EditorGridPanel.html#Ext.grid.EditorGridPanel-beforeedit"
 * ext:member="beforeedit" ext:cls="Ext.grid.EditorGridPanel">beforeedit</a> and
 * <a href=
 * "output/Ext.grid.EditorGridPanel.html#Ext.grid.EditorGridPanel-afteredit"
 * ext:member="afteredit" ext:cls="Ext.grid.EditorGridPanel">afteredit</a>
 * events.
 */
@XType("editorgrid")
@InstanceOf("Ext.grid.EditorGridPanel")
public class EditorGridPanel extends GridPanel {
	public static final String COMPONENT_TYPE = "Ext.grid.EditorGridPanel";
	public static final String COMPONENT_FAMILY = "Ext.grid.EditorGridPanel";

	/**
	 * <p>
	 * Create a new {@link EditorGridPanel} instance with default property
	 * values.
	 * </p>
	 */
	public EditorGridPanel() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean autoEncode;

	/**
	 * True to automatically HTML encode and decodevalues pre and post edit
	 * (defaults to false)
	 */
	public Boolean getAutoEncode() {
		if (null != this.autoEncode) {
			return this.autoEncode;
		}
		ValueExpression _ve = getValueExpression("autoEncode");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoEncode</code> property.
	 * </p>
	 */
	public void setAutoEncode(Boolean autoEncode) {
		this.autoEncode = autoEncode;
		this.handleConfig("autoEncode", autoEncode);
	}

	private Integer clicksToEdit;

	/**
	 * <p>
	 * The number of clicks on a cell required to display the cell's editor
	 * (defaults to 2).
	 * </p>
	 * 
	 * <p>
	 * Setting this option to 'auto' means that mousedown <i>on the selected
	 * cell</i> starts editing that cell.
	 * </p>
	 */
	public Integer getClicksToEdit() {
		if (null != this.clicksToEdit) {
			return this.clicksToEdit;
		}
		ValueExpression _ve = getValueExpression("clicksToEdit");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>clicksToEdit</code> property.
	 * </p>
	 */
	public void setClicksToEdit(Integer clicksToEdit) {
		this.clicksToEdit = clicksToEdit;
		this.handleConfig("clicksToEdit", clicksToEdit);
	}

	private Boolean forceValidation;

	/**
	 * True to force validation even if the value isunmodified (defaults to
	 * false)
	 */
	public Boolean getForceValidation() {
		if (null != this.forceValidation) {
			return this.forceValidation;
		}
		ValueExpression _ve = getValueExpression("forceValidation");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>forceValidation</code> property.
	 * </p>
	 */
	public void setForceValidation(Boolean forceValidation) {
		this.forceValidation = forceValidation;
		this.handleConfig("forceValidation", forceValidation);
	}

	private Object selModel;

	/**
	 * Any subclass of AbstractSelectionModel that willprovide the selection
	 * model for the grid (defaults to <a
	 * href="output/Ext.grid.CellSelectionModel.html"
	 * ext:cls="Ext.grid.CellSelectionModel">Ext.grid.CellSelectionModel</a> if
	 * not specified).
	 */
	@ClientConfig(JsonMode.Object)
	public Object getSelModel() {
		if (null != this.selModel) {
			return this.selModel;
		}
		ValueExpression _ve = getValueExpression("selModel");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>selModel</code> property.
	 * </p>
	 */
	public void setSelModel(Object selModel) {
		this.selModel = selModel;
		this.handleConfig("selModel", selModel);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[5];
		}
		_values[0] = super.saveState(_context);
		_values[1] = autoEncode;
		_values[2] = clicksToEdit;
		_values[3] = forceValidation;
		_values[4] = selModel;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.autoEncode = (Boolean) _values[1];
		this.handleConfig("autoEncode", this.autoEncode);
		this.clicksToEdit = (Integer) _values[2];
		this.handleConfig("clicksToEdit", this.clicksToEdit);
		this.forceValidation = (Boolean) _values[3];
		this.handleConfig("forceValidation", this.forceValidation);
		this.selModel = (Object) _values[4];
		this.handleConfig("selModel", this.selModel);

	}
}