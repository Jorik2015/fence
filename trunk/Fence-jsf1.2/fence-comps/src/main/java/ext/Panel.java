package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * Panel is a container that has specific functionality and structural
 * components that make it the perfect building block for application-oriented
 * user interfaces.
 * </p>
 * 
 * <p>
 * Panels are, by virtue of their inheritance from <a
 * href="output/Ext.Container.html" ext:cls="Ext.Container">Ext.Container</a>,
 * capable of being configured with a <a
 * href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 * ext:cls="Ext.Container">layout</a>, and containing child Components.
 * </p>
 * 
 * <p>
 * When either specifying child <a
 * href="output/Ext.Component.html#Ext.Component-items" ext:member="items"
 * ext:cls="Ext.Component">items</a> of a Panel, or dynamically <a
 * href="output/Ext.Container.html#Ext.Container-add" ext:member="add"
 * ext:cls="Ext.Container">adding</a> Components to a Panel, remember to
 * consider how you wish the Panel to arrange those child elements, and whether
 * those child elements need to be sized using one of Ext's built-in
 * 
 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt>
 * schemes. By default, Panels use the <a
 * href="output/Ext.layout.ContainerLayout.html"
 * ext:cls="Ext.layout.ContainerLayout">ContainerLayout</a> scheme. This simply
 * renders child components, appending them one after the other inside the
 * Container, and <b>does not apply any sizing</b> at all.
 * </p>
 * 
 * <p>
 * A Panel may also contain <a href="output/Ext.Panel.html#Ext.Panel-bbar"
 * ext:member="bbar" ext:cls="Ext.Panel">bottom</a> and <a
 * href="output/Ext.Panel.html#Ext.Panel-tbar" ext:member="tbar"
 * ext:cls="Ext.Panel">top</a> toolbars, along with separate <a
 * href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header"
 * ext:cls="Ext.Panel">header</a>, <a
 * href="output/Ext.Panel.html#Ext.Panel-footer" ext:member="footer"
 * ext:cls="Ext.Panel">footer</a> and <a
 * href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body"
 * ext:cls="Ext.Panel">body</a> sections (see <a
 * href="output/Ext.Panel.html#Ext.Panel-frame" ext:member="frame"
 * ext:cls="Ext.Panel">frame</a> for additional information).
 * </p>
 * 
 * <p>
 * Panel also provides built-in <a
 * href="output/Ext.Panel.html#Ext.Panel-collapsible" ext:member="collapsible"
 * ext:cls="Ext.Panel">expandable and collapsible behavior</a>, along with a
 * variety of <a href="output/Ext.Panel.html#Ext.Panel-tools" ext:member="tools"
 * ext:cls="Ext.Panel">prebuilt tool buttons</a> that can be wired up to provide
 * other customized behavior. Panels can be easily dropped into any <a
 * href="output/Ext.Container.html" ext:cls="Ext.Container">Container</a> or
 * layout, and the layout and rendering pipeline is <a
 * href="output/Ext.Container.html#Ext.Container-add" ext:member="add"
 * ext:cls="Ext.Container">completely managed by the framework</a>.
 * </p>
 */
@XType("panel")
@InstanceOf("Ext.Panel")
public class Panel extends Container {
	public static final String COMPONENT_TYPE = "Ext.Panel";
	public static final String COMPONENT_FAMILY = "Ext.Panel";

	/**
	 * <p>
	 * Create a new {@link Panel} instance with default property values.
	 * </p>
	 */
	public Panel() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean animCollapse;

	/**
	 * <tt>true</tt> to animate the transition when thepanel is collapsed,
	 * <tt>false</tt> to skip the animation (defaults to <tt>true</tt> if the <a
	 * href="output/Ext.Fx.html" ext:cls="Ext.Fx">Ext.Fx</a> class is available,
	 * otherwise <tt>false</tt>).
	 */
	public Boolean getAnimCollapse() {
		if (null != this.animCollapse) {
			return this.animCollapse;
		}
		ValueExpression _ve = getValueExpression("animCollapse");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>animCollapse</code> property.
	 * </p>
	 */
	public void setAnimCollapse(Boolean animCollapse) {
		this.animCollapse = animCollapse;
		this.handleConfig("animCollapse", animCollapse);
	}

	private Object applyTo;

	/**
	 * <p>
	 * The id of the node, a DOM node or an existing Element corresponding to a
	 * DIV that is already present in the document that specifies some
	 * panel-specific structural markup. When <tt>applyTo</tt> is used,
	 * constituent parts of the panel can be specified by CSS class name within
	 * the main element, and the panel will automatically create those
	 * components from that markup. Any required components not specified in the
	 * markup will be autogenerated if necessary.
	 * </p>
	 * 
	 * <p>
	 * The following class names are supported (baseCls will be replaced by <a
	 * href="output/Ext.Panel.html#Ext.Panel-baseCls" ext:member="baseCls"
	 * ext:cls="Ext.Panel">baseCls</a>):
	 * </p>
	 * 
	 * <ul>
	 * <li>baseCls + '-header'</li>
	 * 
	 * <li>baseCls + '-header-text'</li>
	 * 
	 * <li>baseCls + '-bwrap'</li>
	 * 
	 * <li>baseCls + '-tbar'</li>
	 * 
	 * <li>baseCls + '-body'</li>
	 * 
	 * <li>baseCls + '-bbar'</li>
	 * 
	 * <li>baseCls + '-footer'</li>
	 * </ul>
	 * 
	 * <p>
	 * Using this config, a call to render() is not required. If applyTo is
	 * specified, any value passed for <a
	 * href="output/Ext.Panel.html#Ext.Panel-renderTo" ext:member="renderTo"
	 * ext:cls="Ext.Panel">renderTo</a> will be ignored and the target element's
	 * parent node will automatically be used as the panel's container.
	 * </p>
	 */
	public Object getApplyTo() {
		if (null != this.applyTo) {
			return this.applyTo;
		}
		ValueExpression _ve = getValueExpression("applyTo");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>applyTo</code> property.
	 * </p>
	 */
	public void setApplyTo(Object applyTo) {
		this.applyTo = applyTo;
		this.handleConfig("applyTo", applyTo);
	}

	private Boolean autoHeight;

	/**
	 * <tt>true</tt> to use height:'auto',<tt>false</tt> to use fixed height
	 * (defaults to <tt>false</tt>). <b>Note</b>: Setting
	 * <tt>autoHeight:true</tt> means that the browser will manage the panel's
	 * height based on its contents, and that Ext will not manage it at all. If
	 * the panel is within a layout that manages dimensions (<tt>fit</tt>,
	 * <tt>border</tt>, etc.) then setting <tt>autoHeight:true</tt> can cause
	 * issues with scrolling and will not generally work as expected since the
	 * panel will take on the height of its contents rather than the height
	 * required by the Ext layout.
	 */
	public Boolean getAutoHeight() {
		if (null != this.autoHeight) {
			return this.autoHeight;
		}
		ValueExpression _ve = getValueExpression("autoHeight");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoHeight</code> property.
	 * </p>
	 */
	public void setAutoHeight(Boolean autoHeight) {
		this.autoHeight = autoHeight;
		this.handleConfig("autoHeight", autoHeight);
	}

	private Object autoLoad;

	/**
	 * A valid url spec according to the Updater <a
	 * href="output/Ext.Updater.html#Ext.Updater-update" ext:member="update"
	 * ext:cls="Ext.Updater">Ext.Updater.update</a>method. If autoLoad is not
	 * null, the panel will attempt to load its contents immediately upon
	 * render.
	 * 
	 * <p>
	 * The URL will become the default URL for this panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body"
	 * ext:cls="Ext.Panel">body</a> element, so it may be <a
	 * href="output/Ext.Element.html#Ext.Element-refresh" ext:member="refresh"
	 * ext:cls="Ext.Element">refresh</a>ed at any time.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getAutoLoad() {
		if (null != this.autoLoad) {
			return this.autoLoad;
		}
		ValueExpression _ve = getValueExpression("autoLoad");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoLoad</code> property.
	 * </p>
	 */
	public void setAutoLoad(Object autoLoad) {
		this.autoLoad = autoLoad;
		this.handleConfig("autoLoad", autoLoad);
	}

	private Boolean autoScroll;

	/**
	 * <tt>true</tt> to use overflow:'auto' on thepanel's body element and show
	 * scroll bars automatically when necessary, <tt>false</tt> to clip any
	 * overflowing content (defaults to <tt>false</tt>).
	 */
	public Boolean getAutoScroll() {
		if (null != this.autoScroll) {
			return this.autoScroll;
		}
		ValueExpression _ve = getValueExpression("autoScroll");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoScroll</code> property.
	 * </p>
	 */
	public void setAutoScroll(Boolean autoScroll) {
		this.autoScroll = autoScroll;
		this.handleConfig("autoScroll", autoScroll);
	}

	private String baseCls;

	/**
	 * The base CSS class to apply to this panel'selement (defaults to <tt>'x-panel'</tt>).
	 * 
	 * <p>
	 * Another option available by default is to specify <tt>'x-plain'</tt> which strips all
	 * styling except for required attributes for Ext layouts to function (e.g.
	 * overflow:hidden). See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-unstyled" ext:member="unstyled" ext:cls="Ext.Panel">unstyled</a></tt>
	 * also.
	 * </p>
	 */
	public String getBaseCls() {
		if (null != this.baseCls) {
			return this.baseCls;
		}
		ValueExpression _ve = getValueExpression("baseCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>baseCls</code> property.
	 * </p>
	 */
	public void setBaseCls(String baseCls) {
		this.baseCls = baseCls;
		this.handleConfig("baseCls", baseCls);
	}

	private Object bbar;

	/**
	 * <p>
	 * The bottom toolbar of the panel. This can be a <a
	 * href="output/Ext.Toolbar.html" ext:cls="Ext.Toolbar">Ext.Toolbar</a>
	 * object, a toolbar config, or an array of buttons/button configs to be
	 * added to the toolbar. Note that this is not available as a property after
	 * render. To access the bottom toolbar after render, use <a
	 * href="output/Ext.Panel.html#Ext.Panel-getBottomToolbar"
	 * ext:member="getBottomToolbar" ext:cls="Ext.Panel">getBottomToolbar</a>.
	 * </p>
	 * 
	 * <p>
	 * <b>Note:</b> Although a Toolbar may contain Field components, these will
	 * <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's
	 * toolbars are not part of the standard Container-&gt;Component hierarchy,
	 * and so are not scanned to collect form items. However, the values
	 * <b>will</b> be submitted because form submission parameters are collected
	 * from the DOM tree.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getBbar() {
		if (null != this.bbar) {
			return this.bbar;
		}
		ValueExpression _ve = getValueExpression("bbar");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bbar</code> property.
	 * </p>
	 */
	public void setBbar(Object bbar) {
		this.bbar = bbar;
		this.handleConfig("bbar", bbar);
	}

	private Object bbarCfg;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element specification object
	 * specifying the element structure of this Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-bbar" ext:member="bbar"
	 * ext:cls="Ext.Panel">bbar</a> Element. See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg" ext:cls="Ext.Panel">bodyCfg</a></tt>
	 * also.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getBbarCfg() {
		if (null != this.bbarCfg) {
			return this.bbarCfg;
		}
		ValueExpression _ve = getValueExpression("bbarCfg");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bbarCfg</code> property.
	 * </p>
	 */
	public void setBbarCfg(Object bbarCfg) {
		this.bbarCfg = bbarCfg;
		this.handleConfig("bbarCfg", bbarCfg);
	}

	private Boolean bodyBorder;

	/**
	 * True to display an interior border on the bodyelement of the panel, false
	 * to hide it (defaults to true). This only applies when <a
	 * href="output/Ext.Panel.html#Ext.Panel-border" ext:member="border"
	 * ext:cls="Ext.Panel">border</a> == true. If border == true and bodyBorder
	 * == false, the border will display as a 1px wide inset border, giving the
	 * entire body element an inset appearance.
	 */
	public Boolean getBodyBorder() {
		if (null != this.bodyBorder) {
			return this.bodyBorder;
		}
		ValueExpression _ve = getValueExpression("bodyBorder");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bodyBorder</code> property.
	 * </p>
	 */
	public void setBodyBorder(Boolean bodyBorder) {
		this.bodyBorder = bodyBorder;
		this.handleConfig("bodyBorder", bodyBorder);
	}

	private Object bodyCfg;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element specification object may be
	 * specified for any Panel Element.
	 * </p>
	 * 
	 * <p>
	 * By default, the Default element in the table below will be used for the
	 * html markup to create a child element with the commensurate Default class
	 * name (<tt>baseCls</tt> will be replaced by
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-baseCls" ext:member="baseCls" ext:cls="Ext.Panel">baseCls</a></tt>
	 * ):
	 * </p>
	 * 
	 * <pre>
	 * Panel      Default  Default             Custom      Additional       Additional
	 * Element    element  class               element     class            style
	 * ========   ==========================   =========   ==============   ===========
	 * &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-header&quot; ext:member=&quot;header&quot; ext:cls=&quot;Ext.Panel&quot;&gt;header&lt;/a&gt;     div      &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-baseCls&quot; ext:member=&quot;baseCls&quot; ext:cls=&quot;Ext.Panel&quot;&gt;baseCls&lt;/a&gt;+'-header'   &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-headerCfg&quot; ext:member=&quot;headerCfg&quot; ext:cls=&quot;Ext.Panel&quot;&gt;headerCfg&lt;/a&gt;   headerCssClass   headerStyle
	 * &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bwrap&quot; ext:member=&quot;bwrap&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bwrap&lt;/a&gt;      div      &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-baseCls&quot; ext:member=&quot;baseCls&quot; ext:cls=&quot;Ext.Panel&quot;&gt;baseCls&lt;/a&gt;+'-bwrap'     &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bwrapCfg&quot; ext:member=&quot;bwrapCfg&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bwrapCfg&lt;/a&gt;    bwrapCssClass    bwrapStyle
	 * + tbar     div      &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-baseCls&quot; ext:member=&quot;baseCls&quot; ext:cls=&quot;Ext.Panel&quot;&gt;baseCls&lt;/a&gt;+'-tbar'       &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-tbarCfg&quot; ext:member=&quot;tbarCfg&quot; ext:cls=&quot;Ext.Panel&quot;&gt;tbarCfg&lt;/a&gt;     tbarCssClass     tbarStyle
	 * + &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-body&quot; ext:member=&quot;body&quot; ext:cls=&quot;Ext.Panel&quot;&gt;body&lt;/a&gt;     div      &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-baseCls&quot; ext:member=&quot;baseCls&quot; ext:cls=&quot;Ext.Panel&quot;&gt;baseCls&lt;/a&gt;+'-body'       &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bodyCfg&quot; ext:member=&quot;bodyCfg&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bodyCfg&lt;/a&gt;     &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bodyCssClass&quot; ext:member=&quot;bodyCssClass&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bodyCssClass&lt;/a&gt;     &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bodyStyle&quot; ext:member=&quot;bodyStyle&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bodyStyle&lt;/a&gt;
	 * + bbar     div      &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-baseCls&quot; ext:member=&quot;baseCls&quot; ext:cls=&quot;Ext.Panel&quot;&gt;baseCls&lt;/a&gt;+'-bbar'       &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bbarCfg&quot; ext:member=&quot;bbarCfg&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bbarCfg&lt;/a&gt;     bbarCssClass     bbarStyle
	 * + &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-footer&quot; ext:member=&quot;footer&quot; ext:cls=&quot;Ext.Panel&quot;&gt;footer&lt;/a&gt;   div      &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-baseCls&quot; ext:member=&quot;baseCls&quot; ext:cls=&quot;Ext.Panel&quot;&gt;baseCls&lt;/a&gt;+'-footer'   &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-footerCfg&quot; ext:member=&quot;footerCfg&quot; ext:cls=&quot;Ext.Panel&quot;&gt;footerCfg&lt;/a&gt;   footerCssClass   footerStyle
	 * </pre>
	 * 
	 * <p>
	 * Configuring a Custom element may be used, for example, to force the <a
	 * href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body"
	 * ext:cls="Ext.Panel">body</a> Element to use a different form of markup
	 * than is created by default. An example of this might be to <a
	 * href="output/Ext.Element.html#Ext.Element-createChild"
	 * ext:member="createChild" ext:cls="Ext.Element">create a child</a> Panel
	 * containing a custom content, such as a header, or forcing centering of
	 * all Panel content by having the body be a &lt;center&gt; element:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.Panel({
	 *     title: &lt;em&gt;'Message Title'&lt;/em&gt;,
	 *     renderTo: Ext.getBody(),
	 *     width: 200, height: 130,
	 *     &lt;b&gt;bodyCfg&lt;/b&gt;: {
	 *         tag: &lt;em&gt;'center'&lt;/em&gt;,
	 *         cls: &lt;em&gt;'x-panel-body'&lt;/em&gt;,  &lt;i&gt;// Default class not applied &lt;b&gt;if&lt;/b&gt; Custom element specified&lt;/i&gt;
	 *         html: &lt;em&gt;'Message'&lt;/em&gt;
	 *     },
	 *     footerCfg: {
	 *         tag: &lt;em&gt;'h2'&lt;/em&gt;,
	 *         cls: &lt;em&gt;'x-panel-footer'&lt;/em&gt;        &lt;i&gt;// same as the Default class&lt;/i&gt;
	 *         html: &lt;em&gt;'footer html'&lt;/em&gt;
	 *     },
	 *     footerCssClass: &lt;em&gt;'custom-footer'&lt;/em&gt;, &lt;i&gt;// additional css class, see &lt;a href=&quot;output/Ext.element.html#Ext.element-addClass&quot; ext:member=&quot;addClass&quot; ext:cls=&quot;Ext.element&quot;&gt;addClass&lt;/a&gt;&lt;/i&gt;
	 *     footerStyle:    &lt;em&gt;'background-color:red'&lt;/em&gt; &lt;i&gt;// see &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-bodyStyle&quot; ext:member=&quot;bodyStyle&quot; ext:cls=&quot;Ext.Panel&quot;&gt;bodyStyle&lt;/a&gt;&lt;/i&gt;
	 * });&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * The example above also explicitly creates a
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-footer" ext:member="footer" ext:cls="Ext.Panel">footer</a></tt>
	 * with custom markup and styling applied.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getBodyCfg() {
		if (null != this.bodyCfg) {
			return this.bodyCfg;
		}
		ValueExpression _ve = getValueExpression("bodyCfg");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bodyCfg</code> property.
	 * </p>
	 */
	public void setBodyCfg(Object bodyCfg) {
		this.bodyCfg = bodyCfg;
		this.handleConfig("bodyCfg", bodyCfg);
	}

	private String bodyCssClass;

	/**
	 * Additional css class selector to be applied tothe <a
	 * href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body"
	 * ext:cls="Ext.Panel">body</a> element in the format expected by <a
	 * href="output/Ext.Element.html#Ext.Element-addClass" ext:member="addClass"
	 * ext:cls="Ext.Element">Ext.Element.addClass</a> (defaults to null). See <a
	 * href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg"
	 * ext:cls="Ext.Panel">bodyCfg</a>.
	 */
	public String getBodyCssClass() {
		if (null != this.bodyCssClass) {
			return this.bodyCssClass;
		}
		ValueExpression _ve = getValueExpression("bodyCssClass");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bodyCssClass</code> property.
	 * </p>
	 */
	public void setBodyCssClass(String bodyCssClass) {
		this.bodyCssClass = bodyCssClass;
		this.handleConfig("bodyCssClass", bodyCssClass);
	}

	private String bodyStyle;

	/**
	 * Custom CSS styles to be applied to the <a
	 * href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body"
	 * ext:cls="Ext.Panel">body</a> element in the format expected by <a
	 * href="output/Ext.Element.html#Ext.Element-applyStyles"
	 * ext:member="applyStyles"
	 * ext:cls="Ext.Element">Ext.Element.applyStyles</a> (defaults tonull). See
	 * <a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg"
	 * ext:cls="Ext.Panel">bodyCfg</a>.
	 */
	public String getBodyStyle() {
		if (null != this.bodyStyle) {
			return this.bodyStyle;
		}
		ValueExpression _ve = getValueExpression("bodyStyle");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bodyStyle</code> property.
	 * </p>
	 */
	public void setBodyStyle(String bodyStyle) {
		this.bodyStyle = bodyStyle;
		this.handleConfig("bodyStyle", bodyStyle);
	}

	private Boolean border;

	/**
	 * True to display the borders of the panel's bodyelement, false to hide
	 * them (defaults to true). By default, the border is a 2px wide inset
	 * border, but this can be further altered by setting <a
	 * href="output/Ext.Panel.html#Ext.Panel-bodyBorder" ext:member="bodyBorder"
	 * ext:cls="Ext.Panel">bodyBorder</a> to false.
	 */
	public Boolean getBorder() {
		if (null != this.border) {
			return this.border;
		}
		ValueExpression _ve = getValueExpression("border");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>border</code> property.
	 * </p>
	 */
	public void setBorder(Boolean border) {
		this.border = border;
		this.handleConfig("border", border);
	}

	private String buttonAlign;

	/**
	 * The alignment of any <a href="output/Ext.Panel.html#Ext.Panel-buttons"
	 * ext:member="buttons" ext:cls="Ext.Panel">buttons</a> added to this panel.
	 * Valid valuesare <tt>'right'</tt>, <tt>'left'</tt> and <tt>'center'</tt> (defaults to <tt>'right'</tt>).
	 */
	public String getButtonAlign() {
		if (null != this.buttonAlign) {
			return this.buttonAlign;
		}
		ValueExpression _ve = getValueExpression("buttonAlign");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>buttonAlign</code> property.
	 * </p>
	 */
	public void setButtonAlign(String buttonAlign) {
		this.buttonAlign = buttonAlign;
		this.handleConfig("buttonAlign", buttonAlign);
	}

	private Object buttons;

	/**
	 * <tt>buttons</tt> will be used as
	 * <tt><a href="output/Ext.Container.html#Ext.Container-items" ext:member="items" ext:cls="Ext.Container">items</a></tt>
	 * for thetoolbar in the footer (
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-fbar" ext:member="fbar" ext:cls="Ext.Panel">fbar</a></tt>
	 * ). Typically the value of this configuration property will be an array of
	 * <a href="output/Ext.Button.html" ext:cls="Ext.Button">Ext.Button</a>s or
	 * <a href="output/Ext.Button.html" ext:cls="Ext.Button">Ext.Button</a>
	 * configuration objects. If an item is configured with <tt>minWidth</tt> or
	 * the Panel is configured with <tt>minButtonWidth</tt>, that width will be
	 * applied to the item.
	 */
	@ClientConfig(JsonMode.Array)
	public Object getButtons() {
		if (null != this.buttons) {
			return this.buttons;
		}
		ValueExpression _ve = getValueExpression("buttons");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>buttons</code> property.
	 * </p>
	 */
	public void setButtons(Object buttons) {
		this.buttons = buttons;
		this.handleConfig("buttons", buttons);
	}

	private Object bwrapCfg;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element specification object
	 * specifying the element structure of this Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-bwrap" ext:member="bwrap"
	 * ext:cls="Ext.Panel">bwrap</a> Element. See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg" ext:cls="Ext.Panel">bodyCfg</a></tt>
	 * also.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getBwrapCfg() {
		if (null != this.bwrapCfg) {
			return this.bwrapCfg;
		}
		ValueExpression _ve = getValueExpression("bwrapCfg");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bwrapCfg</code> property.
	 * </p>
	 */
	public void setBwrapCfg(Object bwrapCfg) {
		this.bwrapCfg = bwrapCfg;
		this.handleConfig("bwrapCfg", bwrapCfg);
	}

	private Boolean closable;

	/**
	 * Panels themselves do not directly support beingclosed, but some Panel
	 * subclasses do (like <a href="output/Ext.Window.html"
	 * ext:cls="Ext.Window">Ext.Window</a>) or a Panel Class within an <a
	 * href="output/Ext.TabPanel.html" ext:cls="Ext.TabPanel">Ext.TabPanel</a>.
	 * Specify <tt>true</tt> to enable closing in such situations. Defaults to
	 * <tt>false</tt>.
	 */
	public Boolean getClosable() {
		if (null != this.closable) {
			return this.closable;
		}
		ValueExpression _ve = getValueExpression("closable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>closable</code> property.
	 * </p>
	 */
	public void setClosable(Boolean closable) {
		this.closable = closable;
		this.handleConfig("closable", closable);
	}

	private Boolean collapseFirst;

	/**
	 * <tt>true</tt> to make sure the collapse/expandtoggle button always
	 * renders first (to the left of) any other tools in the panel's title bar,
	 * <tt>false</tt> to render it last (defaults to <tt>true</tt>).
	 */
	public Boolean getCollapseFirst() {
		if (null != this.collapseFirst) {
			return this.collapseFirst;
		}
		ValueExpression _ve = getValueExpression("collapseFirst");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>collapseFirst</code> property.
	 * </p>
	 */
	public void setCollapseFirst(Boolean collapseFirst) {
		this.collapseFirst = collapseFirst;
		this.handleConfig("collapseFirst", collapseFirst);
	}

	private Boolean collapsed;

	/**
	 * <tt>true</tt> to render the panel collapsed,<tt>false</tt> to render it
	 * expanded (defaults to <tt>false</tt>).
	 */
	public Boolean getCollapsed() {
		if (null != this.collapsed) {
			return this.collapsed;
		}
		ValueExpression _ve = getValueExpression("collapsed");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>collapsed</code> property.
	 * </p>
	 */
	public void setCollapsed(Boolean collapsed) {
		this.collapsed = collapsed;
		this.handleConfig("collapsed", collapsed);
	}

	private String collapsedCls;

	/**
	 * A CSS class to add to the panel's element afterit has been collapsed
	 * (defaults to <tt>'x-panel-collapsed'</tt>).
	 */
	public String getCollapsedCls() {
		if (null != this.collapsedCls) {
			return this.collapsedCls;
		}
		ValueExpression _ve = getValueExpression("collapsedCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>collapsedCls</code> property.
	 * </p>
	 */
	public void setCollapsedCls(String collapsedCls) {
		this.collapsedCls = collapsedCls;
		this.handleConfig("collapsedCls", collapsedCls);
	}

	private Boolean collapsible;

	/**
	 * True to make the panel collapsible and have theexpand/collapse toggle
	 * button automatically rendered into the header tool button area, false to
	 * keep the panel statically sized with no button (defaults to false).
	 */
	public Boolean getCollapsible() {
		if (null != this.collapsible) {
			return this.collapsible;
		}
		ValueExpression _ve = getValueExpression("collapsible");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>collapsible</code> property.
	 * </p>
	 */
	public void setCollapsible(Boolean collapsible) {
		this.collapsible = collapsible;
		this.handleConfig("collapsible", collapsible);
	}

	private String contentEl;

	/**
	 * <p>
	 * Specify the <tt>id</tt> of an existing HTML node to use as the panel's
	 * body content (defaults to '').
	 * </p>
	 * 
	 * <div>
	 * <ul>
	 * <li><b>Description</b> :
	 * 
	 * <div style="margin-left: 2em"> <div class="sub-desc">This config option
	 * is used to take an existing HTML element and place it in the body of a
	 * new panel (it simply moves the specified DOM element into the body
	 * element of the Panel <i>when the Panel is rendered</i> to use as the
	 * content (it is not going to be the actual panel itself).</div> </div></li>
	 * 
	 * <li><b>Notes</b> :
	 * 
	 * <div style="margin-left: 2em"> <div class="sub-desc">The specified HTML
	 * Element is appended to the Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body"
	 * ext:cls="Ext.Panel">body</a> Element by the Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-afterRender"
	 * ext:member="afterRender" ext:cls="Ext.Panel">afterRender</a> method
	 * <i>after any configured <a href="output/Ext.Panel.html#Ext.Panel-html"
	 * ext:member="html" ext:cls="Ext.Panel">HTML</a> has been inserted</i>, and
	 * so the document will not contain this HTML at the time the <a
	 * href="output/Ext.Panel.html#Ext.Panel-render" ext:member="render"
	 * ext:cls="Ext.Panel">render</a> event is fired.</div>
	 * 
	 * <div class="sub-desc">The specified HTML element used will not
	 * participate in any layout scheme that the Panel may use. It's just HTML.
	 * Layouts operate on child items.</div>
	 * 
	 * <div class="sub-desc">Add either the <tt>x-hidden</tt> or the
	 * <tt>x-hide-display</tt> CSS class to prevent a brief flicker of the
	 * content before it is rendered to the panel.</div> </div></li>
	 * </ul>
	 * </div>
	 */
	public String getContentEl() {
		if (null != this.contentEl) {
			return this.contentEl;
		}
		ValueExpression _ve = getValueExpression("contentEl");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>contentEl</code> property.
	 * </p>
	 */
	public void setContentEl(String contentEl) {
		this.contentEl = contentEl;
		this.handleConfig("contentEl", contentEl);
	}

	private Boolean disabled;

	/**
	 * Render this panel disabled (default is<tt>false</tt>). An important note
	 * when using the disabled config on panels is that IE will often fail to
	 * initialize the disabled mask element correectly if the panel's layout has
	 * not yet completed by the time the Panel is disabled during the render
	 * process. If you experience this issue, you may need to instead use the <a
	 * href="output/Ext.Panel.html#Ext.Panel-afterlayout"
	 * ext:member="afterlayout" ext:cls="Ext.Panel">afterlayout</a> event to
	 * initialize the disabled state:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.Panel({
	 *     ...
	 *     listeners: {
	 *         &lt;em&gt;'afterlayout'&lt;/em&gt;: {
	 *             fn: &lt;b&gt;function&lt;/b&gt;(p){
	 *                 p.disable();
	 *             },
	 *             single: true &lt;i&gt;// important, as many layouts can occur&lt;/i&gt;
	 *         }
	 *     }
	 * });&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(value = JsonMode.Ignore)
	public Boolean getDisabled() {
		if (null != this.disabled) {
			return this.disabled;
		}
		ValueExpression _ve = getValueExpression("disabled");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>disabled</code> property.
	 * </p>
	 */
	public void setDisabled(Boolean disabled) {
		this.disabled = disabled;
		this.handleConfig("disabled", disabled);
	}
	
	private Boolean extDisabled;

	/**
	 * True to disable all components using this action, false to enable them
	 * (defaults to false).
	 */
	@ClientConfig(name="disabled")
	public Boolean getExtDisabled() {
		if (null != this.extDisabled) {
			return this.extDisabled;
		}
		ValueExpression _ve = getValueExpression("extDisabled");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>disabled</code> property.
	 * </p>
	 */
	public void setExtDisabled(Boolean extDisabled) {
		this.extDisabled = extDisabled;
		this.handleConfig("extDisabled", extDisabled);
	}

	private Object draggable;

	/**
	 * <p>
	 * <tt>true</tt> to enable dragging of this Panel (defaults to
	 * <tt>false</tt>).
	 * </p>
	 * 
	 * <p>
	 * For custom drag/drop implementations, an <b>Ext.Panel.DD</b> config could
	 * also be passed in this config instead of <tt>true</tt>. Ext.Panel.DD is
	 * an internal, undocumented class which moves a proxy Element around in
	 * place of the Panel's element, but provides no other behaviour during
	 * dragging or on drop. It is a subclass of <a
	 * href="output/Ext.dd.DragSource.html"
	 * ext:cls="Ext.dd.DragSource">Ext.dd.DragSource</a>, so behaviour may be
	 * added by implementing the interface methods of <a
	 * href="output/Ext.dd.DragDrop.html"
	 * ext:cls="Ext.dd.DragDrop">Ext.dd.DragDrop</a> e.g.:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.Panel({
	 *     title: &lt;em&gt;'Drag me'&lt;/em&gt;,
	 *     x: 100,
	 *     y: 100,
	 *     renderTo: Ext.getBody(),
	 *     floating: true,
	 *     frame: true,
	 *     width: 400,
	 *     height: 200,
	 *     draggable: {
	 * &lt;i&gt;//      Config option of Ext.Panel.DD class.&lt;/i&gt;
	 * &lt;i&gt;//      It's a floating Panel, so &lt;b&gt;do&lt;/b&gt; not show a placeholder proxy &lt;b&gt;in&lt;/b&gt; the original position.&lt;/i&gt;
	 *         insertProxy: false,
	 * 
	 * &lt;i&gt;//      Called &lt;b&gt;for&lt;/b&gt; each mousemove event &lt;b&gt;while&lt;/b&gt; dragging the DD object.&lt;/i&gt;
	 *         onDrag : &lt;b&gt;function&lt;/b&gt;(e){
	 * &lt;i&gt;//          Record the x,y position of the drag proxy so that we can&lt;/i&gt;
	 * &lt;i&gt;//          position the Panel at end of drag.&lt;/i&gt;
	 *             &lt;b&gt;var&lt;/b&gt; pel = this.proxy.getEl();
	 *             this.x = pel.getLeft(true);
	 *             this.y = pel.getTop(true);
	 * 
	 * &lt;i&gt;//          Keep the Shadow aligned &lt;b&gt;if&lt;/b&gt; there is one.&lt;/i&gt;
	 *             &lt;b&gt;var&lt;/b&gt; s = this.panel.getEl().shadow;
	 *             &lt;b&gt;if&lt;/b&gt; (s) {
	 *                 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
	 *             }
	 *         },
	 * 
	 * &lt;i&gt;//      Called on the mouseup event.&lt;/i&gt;
	 *         endDrag : &lt;b&gt;function&lt;/b&gt;(e){
	 *             this.panel.setPosition(this.x, this.y);
	 *         }
	 *     }
	 * }).show();&lt;/code&gt;
	 * </pre>
	 */
	public Object getDraggable() {
		if (null != this.draggable) {
			return this.draggable;
		}
		ValueExpression _ve = getValueExpression("draggable");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>draggable</code> property.
	 * </p>
	 */
	public void setDraggable(Object draggable) {
		this.draggable = draggable;
		this.handleConfig("draggable", draggable);
	}

	private String elements;

	/**
	 * A comma-delimited list of panel elements toinitialize when the panel is
	 * rendered. Normally, this list will be generated automatically based on
	 * the items added to the panel at config time, but sometimes it might be
	 * useful to make sure a structural element is rendered even if not
	 * specified at config time (for example, you may want to add a button or
	 * toolbar dynamically after the panel has been rendered). Adding those
	 * elements to this list will allocate the required placeholders in the
	 * panel when it is rendered. Valid values are
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><tt>header</tt></li>
	 * 
	 * <li><tt>tbar</tt> (top bar)</li>
	 * 
	 * <li><tt>body</tt></li>
	 * 
	 * <li><tt>bbar</tt> (bottom bar)</li>
	 * 
	 * <li><tt>footer</tt></li>
	 * </ul>
	 * </div>
	 * 
	 * Defaults to '<tt>body</tt>'.
	 */
	public String getElements() {
		if (null != this.elements) {
			return this.elements;
		}
		ValueExpression _ve = getValueExpression("elements");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>elements</code> property.
	 * </p>
	 */
	public void setElements(String elements) {
		this.elements = elements;
		this.handleConfig("elements", elements);
	}

	private Object fbar;

	/**
	 * <p>
	 * A <a href="output/Ext.Toolbar.html" ext:cls="Ext.Toolbar">Toolbar</a>
	 * object, a Toolbar config, or an array of <a href="output/Ext.Button.html"
	 * ext:cls="Ext.Button">Button</a>s/<a href="output/Ext.Button.html"
	 * ext:cls="Ext.Button">Button</a> configs, describing a <a
	 * href="output/Ext.Toolbar.html" ext:cls="Ext.Toolbar">Toolbar</a> to be
	 * rendered into this Panel's footer element.
	 * </p>
	 * 
	 * <p>
	 * After render, the <code>fbar</code> property will be an <a
	 * href="output/Ext.Toolbar.html" ext:cls="Ext.Toolbar">Toolbar</a>
	 * instance.
	 * </p>
	 * 
	 * <p>
	 * If
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-buttons" ext:member="buttons" ext:cls="Ext.Panel">buttons</a></tt>
	 * are specified, they will supersede the <tt>fbar</tt> configuration
	 * property.
	 * </p>
	 * 
	 * The Panel's
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-buttonAlign" ext:member="buttonAlign" ext:cls="Ext.Panel">buttonAlign</a></tt>
	 * configuration affects the layout of these items, for example:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; w = &lt;b&gt;new&lt;/b&gt; Ext.Window({
	 *     height: 250,
	 *     width: 500,
	 *     bbar: &lt;b&gt;new&lt;/b&gt; Ext.Toolbar({
	 *         items: [{
	 *             text: &lt;em&gt;'bbar Left'&lt;/em&gt;
	 *         },&lt;em&gt;'-&gt;'&lt;/em&gt;,{
	 *             text: &lt;em&gt;'bbar Right'&lt;/em&gt;
	 *         }]
	 *     }),
	 *     &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-buttonAlign&quot; ext:member=&quot;buttonAlign&quot; ext:cls=&quot;Ext.Panel&quot;&gt;buttonAlign&lt;/a&gt;: &lt;em&gt;'left'&lt;/em&gt;, &lt;i&gt;// anything but &lt;em&gt;'center'&lt;/em&gt; or &lt;em&gt;'right'&lt;/em&gt; and you can use &lt;em&gt;&quot;-&quot;&lt;/em&gt;, and &lt;em&gt;&quot;-&gt;&quot;&lt;/em&gt;&lt;/i&gt;
	 *                                   &lt;i&gt;// to control the alignment of fbar items&lt;/i&gt;
	 *     fbar: [{
	 *         text: &lt;em&gt;'fbar Left'&lt;/em&gt;
	 *     },&lt;em&gt;'-&gt;'&lt;/em&gt;,{
	 *         text: &lt;em&gt;'fbar Right'&lt;/em&gt;
	 *     }]
	 * }).show();&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * <b>Note:</b> Although a Toolbar may contain Field components, these will
	 * <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's
	 * toolbars are not part of the standard Container-&gt;Component hierarchy,
	 * and so are not scanned to collect form items. However, the values
	 * <b>will</b> be submitted because form submission parameters are collected
	 * from the DOM tree.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getFbar() {
		if (null != this.fbar) {
			return this.fbar;
		}
		ValueExpression _ve = getValueExpression("fbar");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>fbar</code> property.
	 * </p>
	 */
	public void setFbar(Object fbar) {
		this.fbar = fbar;
		this.handleConfig("fbar", fbar);
	}

	private Object floating;

	/**
	 * <p>
	 * This property is used to configure the underlying <a
	 * href="output/Ext.Layer.html" ext:cls="Ext.Layer">Ext.Layer</a>.
	 * Acceptable values for this configuration property are:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><b><tt>false</tt></b> : <b>Default.</b> <div class="sub-desc">Display
	 * the panel inline where it is rendered.</div></li>
	 * 
	 * <li><b><tt>true</tt></b> :
	 * 
	 * <div class="sub-desc">Float the panel (absolute position it with
	 * automatic shimming and shadow).
	 * 
	 * <div style="margin-left: 2em"> <div class="sub-desc">Setting floating to
	 * true will create an Ext.Layer for this panel and display the panel at
	 * negative offsets so that it is hidden.</div>
	 * 
	 * <div class="sub-desc">Since the panel will be absolute positioned, the
	 * position must be set explicitly <i>after</i> render (e.g.,
	 * <tt>myPanel.setPosition(100,100);</tt>).</div>
	 * 
	 * <div class="sub-desc"><b>Note</b>: when floating a panel you should
	 * always assign a fixed width, otherwise it will be auto width and will
	 * expand to fill to the right edge of the viewport.</div> </div> </div></li>
	 * 
	 * <li><b>
	 * <tt><a href="output/Ext.Layer.html" ext:cls="Ext.Layer">object</a></tt>
	 * </b> :
	 * 
	 * <div class="sub-desc">The specified object will be used as the
	 * configuration object for the <a href="output/Ext.Layer.html"
	 * ext:cls="Ext.Layer">Ext.Layer</a> that will be created.</div></li>
	 * </ul>
	 * </div>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getFloating() {
		if (null != this.floating) {
			return this.floating;
		}
		ValueExpression _ve = getValueExpression("floating");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>floating</code> property.
	 * </p>
	 */
	public void setFloating(Object floating) {
		this.floating = floating;
		this.handleConfig("floating", floating);
	}

	private Boolean footer;

	/**
	 * <tt>true</tt> to create the footer elementexplicitly, false to skip
	 * creating it. The footer will be created automatically if
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-buttons" ext:member="buttons" ext:cls="Ext.Panel">buttons</a></tt>
	 * or a
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-fbar" ext:member="fbar" ext:cls="Ext.Panel">fbar</a></tt>
	 * have been configured. See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg" ext:cls="Ext.Panel">bodyCfg</a></tt>
	 * for an example.
	 */
	public Boolean getFooter() {
		if (null != this.footer) {
			return this.footer;
		}
		ValueExpression _ve = getValueExpression("footer");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>footer</code> property.
	 * </p>
	 */
	public void setFooter(Boolean footer) {
		this.footer = footer;
		this.handleConfig("footer", footer);
	}

	private Object footerCfg;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element specification object
	 * specifying the element structure of this Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-footer" ext:member="footer"
	 * ext:cls="Ext.Panel">footer</a> Element. See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg" ext:cls="Ext.Panel">bodyCfg</a></tt>
	 * also.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getFooterCfg() {
		if (null != this.footerCfg) {
			return this.footerCfg;
		}
		ValueExpression _ve = getValueExpression("footerCfg");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>footerCfg</code> property.
	 * </p>
	 */
	public void setFooterCfg(Object footerCfg) {
		this.footerCfg = footerCfg;
		this.handleConfig("footerCfg", footerCfg);
	}

	private Boolean frame;

	/**
	 * <tt>false</tt> by default to render with plain1px square borders.
	 * <tt>true</tt> to render with 9 elements, complete with custom rounded
	 * corners (also see <a href="output/Ext.Element.html#Ext.Element-boxWrap"
	 * ext:member="boxWrap" ext:cls="Ext.Element">Ext.Element.boxWrap</a>).
	 * 
	 * <p>
	 * The template generated for each condition is depicted below:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;i&gt;// frame = false&lt;/i&gt;
	 * &lt;div id=&lt;em&gt;&quot;developer-specified-id-goes-here&quot;&lt;/em&gt; class=&lt;em&gt;&quot;x-panel&quot;&lt;/em&gt;&gt;
	 * 
	 *     &lt;div class=&lt;em&gt;&quot;x-panel-header&quot;&lt;/em&gt;&gt;&lt;span class=&lt;em&gt;&quot;x-panel-header-text&quot;&lt;/em&gt;&gt;Title: (frame:false)&lt;/span&gt;&lt;/div&gt;
	 * 
	 *     &lt;div class=&lt;em&gt;&quot;x-panel-bwrap&quot;&lt;/em&gt;&gt;
	 *         &lt;div class=&lt;em&gt;&quot;x-panel-body&quot;&lt;/em&gt;&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
	 *     &lt;/div&gt;
	 * &lt;/div&gt;
	 * 
	 * &lt;i&gt;// frame = true (create 9 elements)&lt;/i&gt;
	 * &lt;div id=&lt;em&gt;&quot;developer-specified-id-goes-here&quot;&lt;/em&gt; class=&lt;em&gt;&quot;x-panel&quot;&lt;/em&gt;&gt;
	 *     &lt;div class=&lt;em&gt;&quot;x-panel-tl&quot;&lt;/em&gt;&gt;&lt;div class=&lt;em&gt;&quot;x-panel-tr&quot;&lt;/em&gt;&gt;&lt;div class=&lt;em&gt;&quot;x-panel-tc&quot;&lt;/em&gt;&gt;
	 *         &lt;div class=&lt;em&gt;&quot;x-panel-header&quot;&lt;/em&gt;&gt;&lt;span class=&lt;em&gt;&quot;x-panel-header-text&quot;&lt;/em&gt;&gt;Title: (frame:true)&lt;/span&gt;&lt;/div&gt;
	 *     &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
	 * 
	 *     &lt;div class=&lt;em&gt;&quot;x-panel-bwrap&quot;&lt;/em&gt;&gt;
	 *         &lt;div class=&lt;em&gt;&quot;x-panel-ml&quot;&lt;/em&gt;&gt;&lt;div class=&lt;em&gt;&quot;x-panel-mr&quot;&lt;/em&gt;&gt;&lt;div class=&lt;em&gt;&quot;x-panel-mc&quot;&lt;/em&gt;&gt;
	 *             &lt;div class=&lt;em&gt;&quot;x-panel-body&quot;&lt;/em&gt;&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
	 *         &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
	 * 
	 *         &lt;div class=&lt;em&gt;&quot;x-panel-bl&quot;&lt;/em&gt;&gt;&lt;div class=&lt;em&gt;&quot;x-panel-br&quot;&lt;/em&gt;&gt;&lt;div class=&lt;em&gt;&quot;x-panel-bc&quot;&lt;/em&gt;/&gt;
	 *         &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
	 * &lt;/div&gt;&lt;/code&gt;
	 * </pre>
	 */
	public Boolean getFrame() {
		if (null != this.frame) {
			return this.frame;
		}
		ValueExpression _ve = getValueExpression("frame");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>frame</code> property.
	 * </p>
	 */
	public void setFrame(Boolean frame) {
		this.frame = frame;
		this.handleConfig("frame", frame);
	}

	private Boolean header;

	/**
	 * <tt>true</tt> to create the Panel's headerelement explicitly,
	 * <tt>false</tt> to skip creating it. If a
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-title" ext:member="title" ext:cls="Ext.Panel">title</a></tt>
	 * is set the header will be created automatically, otherwise it will not.
	 * If a
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-title" ext:member="title" ext:cls="Ext.Panel">title</a></tt>
	 * is set but <tt>header</tt> is explicitly set to <tt>false</tt>, the
	 * header will not be rendered.
	 */
	public Boolean getHeader() {
		if (null != this.header) {
			return this.header;
		}
		ValueExpression _ve = getValueExpression("header");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>header</code> property.
	 * </p>
	 */
	public void setHeader(Boolean header) {
		this.header = header;
		this.handleConfig("header", header);
	}

	private Boolean headerAsText;

	/**
	 * <tt>true</tt> to display the panel
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-title" ext:member="title" ext:cls="Ext.Panel">title</a></tt>
	 * in the
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header" ext:cls="Ext.Panel">header</a></tt>
	 * , <tt>false</tt> to hide it(defaults to <tt>true</tt>).
	 */
	public Boolean getHeaderAsText() {
		if (null != this.headerAsText) {
			return this.headerAsText;
		}
		ValueExpression _ve = getValueExpression("headerAsText");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>headerAsText</code> property.
	 * </p>
	 */
	public void setHeaderAsText(Boolean headerAsText) {
		this.headerAsText = headerAsText;
		this.handleConfig("headerAsText", headerAsText);
	}

	private Object headerCfg;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element specification object
	 * specifying the element structure of this Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header"
	 * ext:cls="Ext.Panel">header</a> Element. See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg" ext:cls="Ext.Panel">bodyCfg</a></tt>
	 * also.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getHeaderCfg() {
		if (null != this.headerCfg) {
			return this.headerCfg;
		}
		ValueExpression _ve = getValueExpression("headerCfg");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>headerCfg</code> property.
	 * </p>
	 */
	public void setHeaderCfg(Object headerCfg) {
		this.headerCfg = headerCfg;
		this.handleConfig("headerCfg", headerCfg);
	}

	private Boolean hideCollapseTool;

	/**
	 * <tt>true</tt> to hide the expand/collapse togglebutton when
	 * 
	 * <code><a href="output/Ext.Panel.html#Ext.Panel-collapsible" ext:member="collapsible" ext:cls="Ext.Panel">collapsible</a> ==
true</code>, <tt>false</tt> to display it (defaults to <tt>false</tt>).
	 */
	public Boolean getHideCollapseTool() {
		if (null != this.hideCollapseTool) {
			return this.hideCollapseTool;
		}
		ValueExpression _ve = getValueExpression("hideCollapseTool");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideCollapseTool</code> property.
	 * </p>
	 */
	public void setHideCollapseTool(Boolean hideCollapseTool) {
		this.hideCollapseTool = hideCollapseTool;
		this.handleConfig("hideCollapseTool", hideCollapseTool);
	}

	private String html;

	/**
	 * An HTML fragment, or a <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> specification to use as thepanel's
	 * body content (defaults to ''). The HTML content is added by the Panel's
	 * <a href="output/Ext.Panel.html#Ext.Panel-afterRender"
	 * ext:member="afterRender" ext:cls="Ext.Panel">afterRender</a> method, and
	 * so the document will not contain this HTML at the time the <a
	 * href="output/Ext.Panel.html#Ext.Panel-render" ext:member="render"
	 * ext:cls="Ext.Panel">render</a> event is fired. This content is inserted
	 * into the body <i>before</i> any configured <a
	 * href="output/Ext.Panel.html#Ext.Panel-contentEl" ext:member="contentEl"
	 * ext:cls="Ext.Panel">contentEl</a> is appended.
	 */
	public String getHtml() {
		if (null != this.html) {
			return this.html;
		}
		ValueExpression _ve = getValueExpression("html");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>html</code> property.
	 * </p>
	 */
	public void setHtml(String html) {
		this.html = html;
		this.handleConfig("html", html);
	}

	private String iconCls;

	/**
	 * The CSS class selector that specifies abackground image to be used as the
	 * header icon (defaults to '').
	 * 
	 * <p>
	 * An example of specifying a custom icon class would be something like:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;i&gt;// specify the property &lt;b&gt;in&lt;/b&gt; the config &lt;b&gt;for&lt;/b&gt; the class:&lt;/i&gt;
	 *      ...
	 *      iconCls: &lt;em&gt;'my-icon'&lt;/em&gt;
	 * 
	 * &lt;i&gt;// css class that specifies background image to be used as the icon image:&lt;/i&gt;
	 * .my-icon { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }&lt;/code&gt;
	 * </pre>
	 */
	public String getIconCls() {
		if (null != this.iconCls) {
			return this.iconCls;
		}
		ValueExpression _ve = getValueExpression("iconCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>iconCls</code> property.
	 * </p>
	 */
	public void setIconCls(String iconCls) {
		this.iconCls = iconCls;
		this.handleConfig("iconCls", iconCls);
	}

	private Object keys;

	/**
	 * A <a href="output/Ext.KeyMap.html" ext:cls="Ext.KeyMap">Ext.KeyMap</a>
	 * config object (in the formatexpected by <a
	 * href="output/Ext.KeyMap.html#Ext.KeyMap-addBinding"
	 * ext:member="addBinding" ext:cls="Ext.KeyMap">Ext.KeyMap.addBinding</a>
	 * used to assign custom key handling to this panel (defaults to
	 * <tt>null</tt>).
	 */
	@ClientConfig(JsonMode.Array)
	public Object getKeys() {
		if (null != this.keys) {
			return this.keys;
		}
		ValueExpression _ve = getValueExpression("keys");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>keys</code> property.
	 * </p>
	 */
	public void setKeys(Object keys) {
		this.keys = keys;
		this.handleConfig("keys", keys);
	}

	private Boolean maskDisabled;

	/**
	 * <tt>true</tt> to mask the panel when it is <a
	 * href="output/Ext.Panel.html#Ext.Panel-disabled" ext:member="disabled"
	 * ext:cls="Ext.Panel">disabled</a>,<tt>false</tt> to not mask it (defaults
	 * to <tt>true</tt>). Either way, the panel will always tell its contained
	 * elements to disable themselves when it is disabled, but masking the panel
	 * can provide an additional visual cue that the panel is disabled.
	 */
	public Boolean getMaskDisabled() {
		if (null != this.maskDisabled) {
			return this.maskDisabled;
		}
		ValueExpression _ve = getValueExpression("maskDisabled");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maskDisabled</code> property.
	 * </p>
	 */
	public void setMaskDisabled(Boolean maskDisabled) {
		this.maskDisabled = maskDisabled;
		this.handleConfig("maskDisabled", maskDisabled);
	}

	private Integer minButtonWidth;

	/**
	 * Minimum width in pixels of all <a
	 * href="output/Ext.Panel.html#Ext.Panel-buttons" ext:member="buttons"
	 * ext:cls="Ext.Panel">buttons</a> in this panel (defaults to<tt>75</tt>)
	 */
	public Integer getMinButtonWidth() {
		if (null != this.minButtonWidth) {
			return this.minButtonWidth;
		}
		ValueExpression _ve = getValueExpression("minButtonWidth");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>minButtonWidth</code> property.
	 * </p>
	 */
	public void setMinButtonWidth(Integer minButtonWidth) {
		this.minButtonWidth = minButtonWidth;
		this.handleConfig("minButtonWidth", minButtonWidth);
	}

	private Boolean preventBodyReset;

	/**
	 * Defaults to <tt>false</tt>. When set to<tt>true</tt>, an extra css class
	 * <tt>'x-panel-normal'</tt> will be added to the panel's element, effectively applying css
	 * styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html)
	 * to the Panel's <b>body</b> element (not the header, footer, etc.).
	 */
	public Boolean getPreventBodyReset() {
		if (null != this.preventBodyReset) {
			return this.preventBodyReset;
		}
		ValueExpression _ve = getValueExpression("preventBodyReset");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>preventBodyReset</code> property.
	 * </p>
	 */
	public void setPreventBodyReset(Boolean preventBodyReset) {
		this.preventBodyReset = preventBodyReset;
		this.handleConfig("preventBodyReset", preventBodyReset);
	}

	private Boolean shadow;

	/**
	 * <tt>true</tt> (or a valid Ext.Shadow <a
	 * href="output/Ext.Shadow.html#Ext.Shadow-mode" ext:member="mode"
	 * ext:cls="Ext.Shadow">Ext.Shadow.mode</a> value) to display a shadowbehind
	 * the panel, <tt>false</tt> to display no shadow (defaults to <tt>'sides'</tt>). Note
	 * that this option only applies when
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-floating" ext:member="floating" ext:cls="Ext.Panel">floating</a> =
true</tt>.
	 */
	public Boolean getShadow() {
		if (null != this.shadow) {
			return this.shadow;
		}
		ValueExpression _ve = getValueExpression("shadow");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>shadow</code> property.
	 * </p>
	 */
	public void setShadow(Boolean shadow) {
		this.shadow = shadow;
		this.handleConfig("shadow", shadow);
	}

	private Integer shadowOffset;

	/**
	 * The number of pixels to offset the shadow ifdisplayed (defaults to
	 * <tt>4</tt>). Note that this option only applies when
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-floating" ext:member="floating" ext:cls="Ext.Panel">floating</a> =
true</tt>.
	 */
	public Integer getShadowOffset() {
		if (null != this.shadowOffset) {
			return this.shadowOffset;
		}
		ValueExpression _ve = getValueExpression("shadowOffset");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>shadowOffset</code> property.
	 * </p>
	 */
	public void setShadowOffset(Integer shadowOffset) {
		this.shadowOffset = shadowOffset;
		this.handleConfig("shadowOffset", shadowOffset);
	}

	private Boolean shim;

	/**
	 * <tt>false</tt> to disable the iframe shim inbrowsers which need one
	 * (defaults to <tt>true</tt>). Note that this option only applies when
	 * 
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-floating" ext:member="floating" ext:cls="Ext.Panel">floating</a> =
true</tt>.
	 */
	public Boolean getShim() {
		if (null != this.shim) {
			return this.shim;
		}
		ValueExpression _ve = getValueExpression("shim");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>shim</code> property.
	 * </p>
	 */
	public void setShim(Boolean shim) {
		this.shim = shim;
		this.handleConfig("shim", shim);
	}

	private String tabTip;

	/**
	 * A string to be used as innerHTML (html tags areaccepted) to show in a
	 * tooltip when mousing over the tab of a Ext.Panel which is an item of a <a
	 * href="output/Ext.TabPanel.html" ext:cls="Ext.TabPanel">Ext.TabPanel</a>.
	 * <a href="output/Ext.QuickTips.html"
	 * ext:cls="Ext.QuickTips">Ext.QuickTips</a>.init() must be called in order
	 * for the tips to render.
	 */
	public String getTabTip() {
		if (null != this.tabTip) {
			return this.tabTip;
		}
		ValueExpression _ve = getValueExpression("tabTip");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>tabTip</code> property.
	 * </p>
	 */
	public void setTabTip(String tabTip) {
		this.tabTip = tabTip;
		this.handleConfig("tabTip", tabTip);
	}

	private Object tbar;

	/**
	 * <p>
	 * The top toolbar of the panel. This can be a <a
	 * href="output/Ext.Toolbar.html" ext:cls="Ext.Toolbar">Ext.Toolbar</a>
	 * object, a toolbar config, or an array of buttons/button configs to be
	 * added to the toolbar. Note that this is not available as a property after
	 * render. To access the top toolbar after render, use <a
	 * href="output/Ext.Panel.html#Ext.Panel-getTopToolbar"
	 * ext:member="getTopToolbar" ext:cls="Ext.Panel">getTopToolbar</a>.
	 * </p>
	 * 
	 * <p>
	 * <b>Note:</b> Although a Toolbar may contain Field components, these will
	 * <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's
	 * toolbars are not part of the standard Container-&gt;Component hierarchy,
	 * and so are not scanned to collect form items. However, the values
	 * <b>will</b> be submitted because form submission parameters are collected
	 * from the DOM tree.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getTbar() {
		if (null != this.tbar) {
			return this.tbar;
		}
		ValueExpression _ve = getValueExpression("tbar");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>tbar</code> property.
	 * </p>
	 */
	public void setTbar(Object tbar) {
		this.tbar = tbar;
		this.handleConfig("tbar", tbar);
	}

	private Object tbarCfg;

	/**
	 * <p>
	 * A <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> element specification object
	 * specifying the element structure of this Panel's <a
	 * href="output/Ext.Panel.html#Ext.Panel-tbar" ext:member="tbar"
	 * ext:cls="Ext.Panel">tbar</a> Element. See
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-bodyCfg" ext:member="bodyCfg" ext:cls="Ext.Panel">bodyCfg</a></tt>
	 * also.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getTbarCfg() {
		if (null != this.tbarCfg) {
			return this.tbarCfg;
		}
		ValueExpression _ve = getValueExpression("tbarCfg");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>tbarCfg</code> property.
	 * </p>
	 */
	public void setTbarCfg(Object tbarCfg) {
		this.tbarCfg = tbarCfg;
		this.handleConfig("tbarCfg", tbarCfg);
	}

	private String title;

	/**
	 * The title text to be used as innerHTML (html tagsare accepted) to display
	 * in the panel
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header" ext:cls="Ext.Panel">header</a></tt>
	 * (defaults to ''). When a <tt>title</tt> is specified the
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header" ext:cls="Ext.Panel">header</a></tt>
	 * element will automatically be created and displayed unless <a
	 * href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header"
	 * ext:cls="Ext.Panel">header</a> is explicitly set to <tt>false</tt>. If
	 * you do not want to specify a <tt>title</tt> at config time, but you may
	 * want one later, you must either specify a non-empty <tt>title</tt> (a
	 * blank space ' ' will do) or <tt>header:true</tt> so that the container
	 * element will get created.
	 */
	public String getTitle() {
		if (null != this.title) {
			return this.title;
		}
		ValueExpression _ve = getValueExpression("title");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>title</code> property.
	 * </p>
	 */
	public void setTitle(String title) {
		this.title = title;
		this.handleConfig("title", title);
	}

	private Boolean titleCollapse;

	/**
	 * <tt>true</tt> to allow expanding and collapsingthe panel (when
	 * 
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-collapsible" ext:member="collapsible" ext:cls="Ext.Panel">collapsible</a> =
true</tt>) by clicking anywhere in the header bar, <tt>false</tt>) to
	 * allow it only by clicking to tool button (defaults to <tt>false</tt>)).
	 * If this panel is a child item of a border layout also see the <a
	 * href="output/Ext.layout.BorderLayout.Region.html"
	 * ext:cls="Ext.layout.BorderLayout.Region">BorderLayout.Region</a>
	 * 
	 * 
	 * <tt><a href="output/Ext.layout.BorderLayout.Region.html#Ext.layout.BorderLayout.Region-floatable" ext:member="floatable" ext:cls="Ext.layout.BorderLayout.Region">floatable</a></tt>
	 * config option.
	 */
	public Boolean getTitleCollapse() {
		if (null != this.titleCollapse) {
			return this.titleCollapse;
		}
		ValueExpression _ve = getValueExpression("titleCollapse");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>titleCollapse</code> property.
	 * </p>
	 */
	public void setTitleCollapse(Boolean titleCollapse) {
		this.titleCollapse = titleCollapse;
		this.handleConfig("titleCollapse", titleCollapse);
	}

	private Object toolTemplate;

	/**
	 * <p>
	 * A Template used to create <a href="output/Ext.Panel.html#Ext.Panel-tools"
	 * ext:member="tools" ext:cls="Ext.Panel">tools</a> in the <a
	 * href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header"
	 * ext:cls="Ext.Panel">header</a> Element. Defaults to:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.Template(&lt;em&gt;'&lt;div class=&lt;/em&gt;&quot;x-tool x-tool-{id}&quot;&lt;/code&gt;&gt;&amp;#160;&lt;/div&gt;')
	 * </pre>
	 * 
	 * <p>
	 * This may may be overridden to provide a custom DOM structure for tools
	 * based upon a more complex XTemplate. The template's data is a single tool
	 * configuration object (Not the entire Array) as specified in <a
	 * href="output/Ext.Panel.html#Ext.Panel-tools" ext:member="tools"
	 * ext:cls="Ext.Panel">tools</a>. In the following example an &lt;a&gt; tag
	 * is used to provide a visual indication when hovering over the tool:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; win = &lt;b&gt;new&lt;/b&gt; Ext.Window({
	 *     tools: [{
	 *         id: &lt;em&gt;'download'&lt;/em&gt;,
	 *         href: &lt;em&gt;'/MyPdfDoc.pdf'&lt;/em&gt;
	 *     }],
	 *     toolTemplate: &lt;b&gt;new&lt;/b&gt; Ext.XTemplate(
	 *         &lt;em&gt;'&lt;tpl &lt;b&gt;if&lt;/b&gt;=&lt;/em&gt;&quot;id==\'&lt;/code&gt;download\&lt;em&gt;'&quot;&lt;/em&gt;&gt;',
	 *             &lt;em&gt;'&lt;a class=&lt;/em&gt;&quot;x-tool x-tool-pdf&quot; href=&lt;em&gt;&quot;{href}&quot;&lt;/em&gt;&gt;&lt;/a&gt;',
	 *         &lt;em&gt;'&lt;/tpl&gt;'&lt;/em&gt;,
	 *         &lt;em&gt;'&lt;tpl &lt;b&gt;if&lt;/b&gt;=&lt;/em&gt;&quot;id!=\'download\&lt;em&gt;'&quot;&lt;/em&gt;&gt;',
	 *             &lt;em&gt;'&lt;div class=&lt;/em&gt;&quot;x-tool x-tool-{id}&quot;&gt;&amp;#160;&lt;/div&gt;',
	 *         &lt;em&gt;'&lt;/tpl&gt;'&lt;/em&gt;
	 *     ),
	 *     width:500,
	 *     height:300,
	 *     closeAction:&lt;em&gt;'hide'&lt;/em&gt;
	 * });
	 * </pre>
	 * 
	 * <p>
	 * Note that the CSS class "x-tool-pdf" should have an associated style rule
	 * which provides an appropriate background image, something like:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getToolTemplate() {
		if (null != this.toolTemplate) {
			return this.toolTemplate;
		}
		ValueExpression _ve = getValueExpression("toolTemplate");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>toolTemplate</code> property.
	 * </p>
	 */
	public void setToolTemplate(Object toolTemplate) {
		this.toolTemplate = toolTemplate;
		this.handleConfig("toolTemplate", toolTemplate);
	}

	private Object tools;

	/**
	 * An array of tool button configs to be added tothe header tool area. When
	 * rendered, each tool is stored as an <a href="output/Ext.Element.html"
	 * ext:cls="Ext.Element">Element</a> referenced by a public property called
	 * <tt>tools.<i>&lt;tool-type&gt;</i></tt>
	 * 
	 * <p>
	 * Each tool config may contain the following properties:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><b>id</b> : String
	 * 
	 * <div class="sub-desc"><b>Required.</b> The type of tool to create. By
	 * default, this assigns a CSS class of the form
	 * <tt>x-tool-<i>&lt;tool-type&gt;</i></tt> to the resulting tool Element.
	 * Ext provides CSS rules, and an icon sprite containing images for the tool
	 * types listed below. The developer may implement custom tools by supplying
	 * alternate CSS rules and background images:
	 * 
	 * <div style="margin-left: 2em"> <div><tt>toggle</tt> (Created by default
	 * when <a href="output/Ext.Panel.html#Ext.Panel-collapsible"
	 * ext:member="collapsible" ext:cls="Ext.Panel">collapsible</a> is
	 * <tt>true</tt>)</div>
	 * 
	 * <div><tt>close</tt></div>
	 * 
	 * <div><tt>minimize</tt></div>
	 * 
	 * <div><tt>maximize</tt></div>
	 * 
	 * <div><tt>restore</tt></div>
	 * 
	 * <div><tt>gear</tt></div>
	 * 
	 * <div><tt>pin</tt></div>
	 * 
	 * <div><tt>unpin</tt></div>
	 * 
	 * <div><tt>right</tt></div>
	 * 
	 * <div><tt>left</tt></div>
	 * 
	 * <div><tt>up</tt></div>
	 * 
	 * <div><tt>down</tt></div>
	 * 
	 * <div><tt>refresh</tt></div>
	 * 
	 * <div><tt>minus</tt></div>
	 * 
	 * <div><tt>plus</tt></div>
	 * 
	 * <div><tt>help</tt></div>
	 * 
	 * <div><tt>search</tt></div>
	 * 
	 * <div><tt>save</tt></div>
	 * 
	 * <div><tt>print</tt></div> </div> </div></li>
	 * 
	 * <li><b>handler</b> : Function
	 * 
	 * <div class="sub-desc"><b>Required.</b> The function to call when clicked.
	 * Arguments passed are:
	 * 
	 * <ul>
	 * <li><b>event</b> : Ext.EventObject
	 * 
	 * <div class="sub-desc">The click event.</div></li>
	 * 
	 * <li><b>toolEl</b> : Ext.Element
	 * 
	 * <div class="sub-desc">The tool Element.</div></li>
	 * 
	 * <li><b>panel</b> : Ext.Panel
	 * 
	 * <div class="sub-desc">The host Panel</div></li>
	 * 
	 * <li><b>tc</b> : Ext.Panel
	 * 
	 * <div class="sub-desc">The tool configuration object</div></li>
	 * </ul>
	 * </div></li>
	 * 
	 * <li><b>stopEvent</b> : Boolean
	 * 
	 * <div class="sub-desc">Defaults to true. Specify as false to allow click
	 * event to propagate.</div></li>
	 * 
	 * <li><b>scope</b> : Object
	 * 
	 * <div class="sub-desc">The scope in which to call the handler.</div></li>
	 * 
	 * <li><b>qtip</b> : String/Object
	 * 
	 * <div class="sub-desc">A tip string, or a config argument to <a
	 * href="output/Ext.QuickTip.html#Ext.QuickTip-register"
	 * ext:member="register"
	 * ext:cls="Ext.QuickTip">Ext.QuickTip.register</a></div></li>
	 * 
	 * <li><b>hidden</b> : Boolean
	 * 
	 * <div class="sub-desc">True to initially render hidden.</div></li>
	 * 
	 * <li><b>on</b> : Object
	 * 
	 * <div class="sub-desc">A listener config object specifiying event
	 * listeners in the format of an argument to <a
	 * href="output/Ext.Panel.html#Ext.Panel-addListener"
	 * ext:member="addListener" ext:cls="Ext.Panel">addListener</a></div></li>
	 * </ul>
	 * </div>
	 * 
	 * <p>
	 * Note that, apart from the toggle tool which is provided when a panel is
	 * collapsible, these tools only provide the visual button. Any required
	 * functionality must be provided by adding handlers that implement the
	 * necessary behavior.
	 * </p>
	 * 
	 * <p>
	 * Example usage:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;tools:[{
	 *     id:&lt;em&gt;'refresh'&lt;/em&gt;,
	 *     qtip: &lt;em&gt;'Refresh form Data'&lt;/em&gt;,
	 *     &lt;i&gt;// hidden:true,&lt;/i&gt;
	 *     handler: &lt;b&gt;function&lt;/b&gt;(event, toolEl, panel){
	 *         &lt;i&gt;// refresh logic&lt;/i&gt;
	 *     }
	 * },
	 * {
	 *     id:&lt;em&gt;'help'&lt;/em&gt;,
	 *     qtip: &lt;em&gt;'Get Help'&lt;/em&gt;,
	 *     handler: &lt;b&gt;function&lt;/b&gt;(event, toolEl, panel){
	 *         &lt;i&gt;// whatever&lt;/i&gt;
	 *     }
	 * }]&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * For the custom id of <tt>'help'</tt> define two relevant css classes with a link to
	 * a 15x15 image:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;.x-tool-help {background-image: url(images/help.png);}
	 * .x-tool-help-over {background-image: url(images/help_over.png);}
	 * &lt;i&gt;// &lt;b&gt;if&lt;/b&gt; using an image sprite:&lt;/i&gt;
	 * .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
	 * .x-tool-help-over {background-position:-15px 0;}&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Array)
	public Object getTools() {
		if (null != this.tools) {
			return this.tools;
		}
		ValueExpression _ve = getValueExpression("tools");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>tools</code> property.
	 * </p>
	 */
	public void setTools(Object tools) {
		this.tools = tools;
		this.handleConfig("tools", tools);
	}

	private Boolean unstyled;

	/**
	 * Overrides the
	 * <tt><a href="output/Ext.Panel.html#Ext.Panel-baseCls" ext:member="baseCls" ext:cls="Ext.Panel">baseCls</a></tt>
	 * setting to <tt><a href="output/Ext.Panel.html#Ext.Panel-baseCls" ext:member="baseCls" ext:cls="Ext.Panel">baseCls</a> = 'x-plain'</tt>
	 * which renders thepanel unstyled except for required attributes for Ext
	 * layouts to function (e.g. overflow:hidden).
	 */
	public Boolean getUnstyled() {
		if (null != this.unstyled) {
			return this.unstyled;
		}
		ValueExpression _ve = getValueExpression("unstyled");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>unstyled</code> property.
	 * </p>
	 */
	public void setUnstyled(Boolean unstyled) {
		this.unstyled = unstyled;
		this.handleConfig("unstyled", unstyled);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[53];
		}
		_values[0] = super.saveState(_context);
		_values[1] = animCollapse;
		_values[2] = applyTo;
		_values[3] = autoHeight;
		_values[4] = autoLoad;
		_values[5] = autoScroll;
		_values[6] = baseCls;
		_values[7] = bbar;
		_values[8] = bbarCfg;
		_values[9] = bodyBorder;
		_values[10] = bodyCfg;
		_values[11] = bodyCssClass;
		_values[12] = bodyStyle;
		_values[13] = border;
		_values[14] = buttonAlign;
		_values[15] = buttons;
		_values[16] = bwrapCfg;
		_values[17] = closable;
		_values[18] = collapseFirst;
		_values[19] = collapsed;
		_values[20] = collapsedCls;
		_values[21] = collapsible;
		_values[22] = contentEl;
		_values[23] = disabled;
		_values[24] = draggable;
		_values[25] = elements;
		_values[26] = fbar;
		_values[27] = floating;
		_values[28] = footer;
		_values[29] = footerCfg;
		_values[30] = frame;
		_values[31] = header;
		_values[32] = headerAsText;
		_values[33] = headerCfg;
		_values[34] = hideCollapseTool;
		_values[35] = html;
		_values[36] = iconCls;
		_values[37] = keys;
		_values[38] = maskDisabled;
		_values[39] = minButtonWidth;
		_values[40] = preventBodyReset;
		_values[41] = shadow;
		_values[42] = shadowOffset;
		_values[43] = shim;
		_values[44] = tabTip;
		_values[45] = tbar;
		_values[46] = tbarCfg;
		_values[47] = title;
		_values[48] = titleCollapse;
		_values[49] = toolTemplate;
		_values[50] = tools;
		_values[51] = unstyled;
		_values[52] = extDisabled;
		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.animCollapse = (Boolean) _values[1];
		this.handleConfig("animCollapse", this.animCollapse);
		this.applyTo = (Object) _values[2];
		this.handleConfig("applyTo", this.applyTo);
		this.autoHeight = (Boolean) _values[3];
		this.handleConfig("autoHeight", this.autoHeight);
		this.autoLoad = (Object) _values[4];
		this.handleConfig("autoLoad", this.autoLoad);
		this.autoScroll = (Boolean) _values[5];
		this.handleConfig("autoScroll", this.autoScroll);
		this.baseCls = (String) _values[6];
		this.handleConfig("baseCls", this.baseCls);
		this.bbar = (Object) _values[7];
		this.handleConfig("bbar", this.bbar);
		this.bbarCfg = (Object) _values[8];
		this.handleConfig("bbarCfg", this.bbarCfg);
		this.bodyBorder = (Boolean) _values[9];
		this.handleConfig("bodyBorder", this.bodyBorder);
		this.bodyCfg = (Object) _values[10];
		this.handleConfig("bodyCfg", this.bodyCfg);
		this.bodyCssClass = (String) _values[11];
		this.handleConfig("bodyCssClass", this.bodyCssClass);
		this.bodyStyle = (String) _values[12];
		this.handleConfig("bodyStyle", this.bodyStyle);
		this.border = (Boolean) _values[13];
		this.handleConfig("border", this.border);
		this.buttonAlign = (String) _values[14];
		this.handleConfig("buttonAlign", this.buttonAlign);
		this.buttons = (Object) _values[15];
		this.handleConfig("buttons", this.buttons);
		this.bwrapCfg = (Object) _values[16];
		this.handleConfig("bwrapCfg", this.bwrapCfg);
		this.closable = (Boolean) _values[17];
		this.handleConfig("closable", this.closable);
		this.collapseFirst = (Boolean) _values[18];
		this.handleConfig("collapseFirst", this.collapseFirst);
		this.collapsed = (Boolean) _values[19];
		this.handleConfig("collapsed", this.collapsed);
		this.collapsedCls = (String) _values[20];
		this.handleConfig("collapsedCls", this.collapsedCls);
		this.collapsible = (Boolean) _values[21];
		this.handleConfig("collapsible", this.collapsible);
		this.contentEl = (String) _values[22];
		this.handleConfig("contentEl", this.contentEl);
		this.disabled = (Boolean) _values[23];
		this.handleConfig("disabled", this.disabled);
		this.draggable = (Object) _values[24];
		this.handleConfig("draggable", this.draggable);
		this.elements = (String) _values[25];
		this.handleConfig("elements", this.elements);
		this.fbar = (Object) _values[26];
		this.handleConfig("fbar", this.fbar);
		this.floating = (Object) _values[27];
		this.handleConfig("floating", this.floating);
		this.footer = (Boolean) _values[28];
		this.handleConfig("footer", this.footer);
		this.footerCfg = (Object) _values[29];
		this.handleConfig("footerCfg", this.footerCfg);
		this.frame = (Boolean) _values[30];
		this.handleConfig("frame", this.frame);
		this.header = (Boolean) _values[31];
		this.handleConfig("header", this.header);
		this.headerAsText = (Boolean) _values[32];
		this.handleConfig("headerAsText", this.headerAsText);
		this.headerCfg = (Object) _values[33];
		this.handleConfig("headerCfg", this.headerCfg);
		this.hideCollapseTool = (Boolean) _values[34];
		this.handleConfig("hideCollapseTool", this.hideCollapseTool);
		this.html = (String) _values[35];
		this.handleConfig("html", this.html);
		this.iconCls = (String) _values[36];
		this.handleConfig("iconCls", this.iconCls);
		this.keys = (Object) _values[37];
		this.handleConfig("keys", this.keys);
		this.maskDisabled = (Boolean) _values[38];
		this.handleConfig("maskDisabled", this.maskDisabled);
		this.minButtonWidth = (Integer) _values[39];
		this.handleConfig("minButtonWidth", this.minButtonWidth);
		this.preventBodyReset = (Boolean) _values[40];
		this.handleConfig("preventBodyReset", this.preventBodyReset);
		this.shadow = (Boolean) _values[41];
		this.handleConfig("shadow", this.shadow);
		this.shadowOffset = (Integer) _values[42];
		this.handleConfig("shadowOffset", this.shadowOffset);
		this.shim = (Boolean) _values[43];
		this.handleConfig("shim", this.shim);
		this.tabTip = (String) _values[44];
		this.handleConfig("tabTip", this.tabTip);
		this.tbar = (Object) _values[45];
		this.handleConfig("tbar", this.tbar);
		this.tbarCfg = (Object) _values[46];
		this.handleConfig("tbarCfg", this.tbarCfg);
		this.title = (String) _values[47];
		this.handleConfig("title", this.title);
		this.titleCollapse = (Boolean) _values[48];
		this.handleConfig("titleCollapse", this.titleCollapse);
		this.toolTemplate = (Object) _values[49];
		this.handleConfig("toolTemplate", this.toolTemplate);
		this.tools = (Object) _values[50];
		this.handleConfig("tools", this.tools);
		this.unstyled = (Boolean) _values[51];
		this.handleConfig("unstyled", this.unstyled);
		this.extDisabled = (Boolean) _values[52];
		this.handleConfig("extDisabled", this.extDisabled);
	}
}