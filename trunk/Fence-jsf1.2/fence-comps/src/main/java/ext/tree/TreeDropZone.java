package ext.tree;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.InstanceOf;
import ext.annotation.ParseConfigMode;
import ext.annotation.PersistenceMode;
import ext.annotation.ReferenceMode;
import ext.dd.DropZone;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 */
@InstanceOf("Ext.tree.TreeDropZone")
@ParseConfigMode(name = "dropConfig", pmode = PersistenceMode.ParentProperty, rmode = ReferenceMode.Config)
public class TreeDropZone extends DropZone {
	public static final String COMPONENT_TYPE = "Ext.tree.TreeDropZone";
	public static final String COMPONENT_FAMILY = "Ext.tree.TreeDropZone";

	/**
	 * <p>
	 * Create a new {@link TreeDropZone} instance with default property values.
	 * </p>
	 */
	public TreeDropZone() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String allowContainerDrop;

	/**
	 * True if drops on the tree container (outside ofa specific tree node) are
	 * allowed (defaults to false)
	 */
	public String getAllowContainerDrop() {
		if (null != this.allowContainerDrop) {
			return this.allowContainerDrop;
		}
		ValueExpression _ve = getValueExpression("allowContainerDrop");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>allowContainerDrop</code> property.
	 * </p>
	 */
	public void setAllowContainerDrop(String allowContainerDrop) {
		this.allowContainerDrop = allowContainerDrop;
		this.handleConfig("allowContainerDrop", allowContainerDrop);
	}

	private Boolean allowParentInsert;

	/**
	 * Allow inserting a dragged node between anexpanded parent node and its
	 * first child that will become a sibling of the parent when dropped
	 * (defaults to false)
	 */
	public Boolean getAllowParentInsert() {
		if (null != this.allowParentInsert) {
			return this.allowParentInsert;
		}
		ValueExpression _ve = getValueExpression("allowParentInsert");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>allowParentInsert</code> property.
	 * </p>
	 */
	public void setAllowParentInsert(Boolean allowParentInsert) {
		this.allowParentInsert = allowParentInsert;
		this.handleConfig("allowParentInsert", allowParentInsert);
	}

	private String appendOnly;

	/**
	 * True if the tree should only allow append drops(use for trees which are
	 * sorted, defaults to false)
	 */
	public String getAppendOnly() {
		if (null != this.appendOnly) {
			return this.appendOnly;
		}
		ValueExpression _ve = getValueExpression("appendOnly");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>appendOnly</code> property.
	 * </p>
	 */
	public void setAppendOnly(String appendOnly) {
		this.appendOnly = appendOnly;
		this.handleConfig("appendOnly", appendOnly);
	}

	private String ddGroup;

	/**
	 * A named drag drop group to which this objectbelongs. If a group is
	 * specified, then this object will only interact with other drag drop
	 * objects in the same group (defaults to 'TreeDD').
	 */
	public String getDdGroup() {
		if (null != this.ddGroup) {
			return this.ddGroup;
		}
		ValueExpression _ve = getValueExpression("ddGroup");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>ddGroup</code> property.
	 * </p>
	 */
	public void setDdGroup(String ddGroup) {
		this.ddGroup = ddGroup;
		this.handleConfig("ddGroup", ddGroup);
	}

	private String expandDelay;

	/**
	 * The delay in milliseconds to wait beforeexpanding a target tree node
	 * while dragging a droppable node over the target (defaults to 1000)
	 */
	public String getExpandDelay() {
		if (null != this.expandDelay) {
			return this.expandDelay;
		}
		ValueExpression _ve = getValueExpression("expandDelay");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>expandDelay</code> property.
	 * </p>
	 */
	public void setExpandDelay(String expandDelay) {
		this.expandDelay = expandDelay;
		this.handleConfig("expandDelay", expandDelay);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[6];
		}
		_values[0] = super.saveState(_context);
		_values[1] = allowContainerDrop;
		_values[2] = allowParentInsert;
		_values[3] = appendOnly;
		_values[4] = ddGroup;
		_values[5] = expandDelay;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.allowContainerDrop = (String) _values[1];
		this.handleConfig("allowContainerDrop", this.allowContainerDrop);
		this.allowParentInsert = (Boolean) _values[2];
		this.handleConfig("allowParentInsert", this.allowParentInsert);
		this.appendOnly = (String) _values[3];
		this.handleConfig("appendOnly", this.appendOnly);
		this.ddGroup = (String) _values[4];
		this.handleConfig("ddGroup", this.ddGroup);
		this.expandDelay = (String) _values[5];
		this.handleConfig("expandDelay", this.expandDelay);

	}
}