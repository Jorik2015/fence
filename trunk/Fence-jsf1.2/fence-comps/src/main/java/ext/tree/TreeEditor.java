package ext.tree;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.Editor;
import ext.annotation.InstanceOf;

/**
 *Note:This java code is auto generated by abner,do not edit it. Provides
 * editor functionality for inline tree node editing. Any valid <a
 * href="output/Ext.form.Field.html" ext:cls="Ext.form.Field">Ext.form.Field</a>
 * subclass can be used as the editor field.
 */
@InstanceOf("Ext.tree.TreeEditor")
public class TreeEditor extends Editor {
	public static final String COMPONENT_TYPE = "Ext.tree.TreeEditor";
	public static final String COMPONENT_FAMILY = "Ext.tree.TreeEditor";

	/**
	 * <p>
	 * Create a new {@link TreeEditor} instance with default property values.
	 * </p>
	 */
	public TreeEditor() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String alignment;

	/**
	 * The position to align to (see <a
	 * href="output/Ext.Element.html#Ext.Element-alignTo" ext:member="alignTo"
	 * ext:cls="Ext.Element">Ext.Element.alignTo</a>for more details, defaults
	 * to "l-l").
	 */
	public String getAlignment() {
		if (null != this.alignment) {
			return this.alignment;
		}
		ValueExpression _ve = getValueExpression("alignment");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>alignment</code> property.
	 * </p>
	 */
	public void setAlignment(String alignment) {
		this.alignment = alignment;
		this.handleConfig("alignment", alignment);
	}

	private String cls;

	/**
	 * CSS class to apply to the editor (defaults
	 * to"x-small-editor x-tree-editor")
	 */
	public String getCls() {
		if (null != this.cls) {
			return this.cls;
		}
		ValueExpression _ve = getValueExpression("cls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>cls</code> property.
	 * </p>
	 */
	public void setCls(String cls) {
		this.cls = cls;
		this.handleConfig("cls", cls);
	}

	private Integer editDelay;

	/**
	 * The number of milliseconds between clicks toregister a double-click that
	 * will trigger editing on the current node (defaults to 350). If two clicks
	 * occur on the same node within this time span, the editor for the node
	 * will display, otherwise it will be processed as a regular click.
	 */
	public Integer getEditDelay() {
		if (null != this.editDelay) {
			return this.editDelay;
		}
		ValueExpression _ve = getValueExpression("editDelay");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>editDelay</code> property.
	 * </p>
	 */
	public void setEditDelay(Integer editDelay) {
		this.editDelay = editDelay;
		this.handleConfig("editDelay", editDelay);
	}

	private Boolean hideEl;

	/**
	 * True to hide the bound element while the editoris displayed (defaults to
	 * false)
	 */
	public Boolean getHideEl() {
		if (null != this.hideEl) {
			return this.hideEl;
		}
		ValueExpression _ve = getValueExpression("hideEl");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideEl</code> property.
	 * </p>
	 */
	public void setHideEl(Boolean hideEl) {
		this.hideEl = hideEl;
		this.handleConfig("hideEl", hideEl);
	}

	private Integer maxWidth;

	/**
	 * The maximum width in pixels of the editor field(defaults to 250). Note
	 * that if the maxWidth would exceed the containing tree element's size, it
	 * will be automatically limited for you to the container width, taking
	 * scroll and client offsets into account prior to each edit.
	 */
	public Integer getMaxWidth() {
		if (null != this.maxWidth) {
			return this.maxWidth;
		}
		ValueExpression _ve = getValueExpression("maxWidth");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maxWidth</code> property.
	 * </p>
	 */
	public void setMaxWidth(Integer maxWidth) {
		this.maxWidth = maxWidth;
		this.handleConfig("maxWidth", maxWidth);
	}

	private Boolean shim;

	/**
	 * True to shim the editor if selects/iframes couldbe displayed beneath it
	 * (defaults to false)
	 */
	public Boolean getShim() {
		if (null != this.shim) {
			return this.shim;
		}
		ValueExpression _ve = getValueExpression("shim");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>shim</code> property.
	 * </p>
	 */
	public void setShim(Boolean shim) {
		this.shim = shim;
		this.handleConfig("shim", shim);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[7];
		}
		_values[0] = super.saveState(_context);
		_values[1] = alignment;
		_values[2] = cls;
		_values[3] = editDelay;
		_values[4] = hideEl;
		_values[5] = maxWidth;
		_values[6] = shim;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.alignment = (String) _values[1];
		this.handleConfig("alignment", this.alignment);
		this.cls = (String) _values[2];
		this.handleConfig("cls", this.cls);
		this.editDelay = (Integer) _values[3];
		this.handleConfig("editDelay", this.editDelay);
		this.hideEl = (Boolean) _values[4];
		this.handleConfig("hideEl", this.hideEl);
		this.maxWidth = (Integer) _values[5];
		this.handleConfig("maxWidth", this.maxWidth);
		this.shim = (Boolean) _values[6];
		this.handleConfig("shim", this.shim);

	}
}