package ext.direct;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.JsonMode;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * The <a href="output/Ext.direct.RemotingProvider.html"
 * ext:cls="Ext.direct.RemotingProvider">RemotingProvider</a> exposes access to
 * server side methods on the client (a remote procedure call (RPC) type of
 * connection where the client can initiate a procedure on the server).
 * </p>
 * 
 * <p>
 * This allows for code to be organized in a fashion that is maintainable, while
 * providing a clear path between client and server, something that is not
 * always apparent when using URLs.
 * </p>
 * 
 * <p>
 * To accomplish this the server-side needs to describe what classes and methods
 * are available on the client-side. This configuration will typically be
 * outputted by the server-side Ext.Direct stack when the API description is
 * built.
 * </p>
 */
public class RemotingProvider extends JsonProvider {
	public static final String COMPONENT_TYPE = "Ext.direct.RemotingProvider";

	/**
	 * <p>
	 * Create a new {@link RemotingProvider} instance with default property
	 * values.
	 * </p>
	 */
	public RemotingProvider() {
		super();
		setRendererType(COMPONENT_TYPE);
	}

	public String getFamily() {
		return (COMPONENT_TYPE);
	}

	private Object actions;

	/**
	 * Object literal defining the server side actionsand methods. For example,
	 * if the Provider is configured with:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;em&gt;&quot;actions&quot;&lt;/em&gt;:{ &lt;i&gt;// each property within the &lt;em&gt;'actions'&lt;/em&gt; object represents a server side Class 
	 * &lt;/i&gt;
	 *     &lt;em&gt;&quot;TestAction&quot;&lt;/em&gt;:[ &lt;i&gt;// array of methods within each server side Class to be   
	 * &lt;/i&gt;
	 *     {              &lt;i&gt;// stubbed out on client
	 * &lt;/i&gt;
	 *         &lt;em&gt;&quot;name&quot;&lt;/em&gt;:&lt;em&gt;&quot;doEcho&quot;&lt;/em&gt;, 
	 *         &lt;em&gt;&quot;len&quot;&lt;/em&gt;:1            
	 *     },{
	 *         &lt;em&gt;&quot;name&quot;&lt;/em&gt;:&lt;em&gt;&quot;multiply&quot;&lt;/em&gt;,&lt;i&gt;// name of method
	 * &lt;/i&gt;
	 *         &lt;em&gt;&quot;len&quot;&lt;/em&gt;:2           &lt;i&gt;// The number of parameters that will be used to create an
	 * &lt;/i&gt;
	 *                           &lt;i&gt;// array of data to send to the server side &lt;b&gt;function&lt;/b&gt;.
	 * &lt;/i&gt;
	 *                           &lt;i&gt;// Ensure the server sends back a Number, not a String. 
	 * &lt;/i&gt;
	 *     },{
	 *         &lt;em&gt;&quot;name&quot;&lt;/em&gt;:&lt;em&gt;&quot;doForm&quot;&lt;/em&gt;,
	 *         &lt;em&gt;&quot;formHandler&quot;&lt;/em&gt;:true, &lt;i&gt;// direct the client to use specialized form handling method 
	 * &lt;/i&gt;
	 *         &lt;em&gt;&quot;len&quot;&lt;/em&gt;:1
	 *     }]
	 * }&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * Note that a Store is not required, a server method can be called at any
	 * time. In the following example a <b>client side</b> handler is used to
	 * call the server side method "multiply" in the server-side "TestAction"
	 * Class:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;TestAction.multiply(
	 *     2, 4, &lt;i&gt;// pass two arguments to server, so specify len=2
	 * &lt;/i&gt;
	 *     &lt;i&gt;// callback &lt;b&gt;function&lt;/b&gt; after the server is called
	 * &lt;/i&gt;
	 *     &lt;i&gt;// result: the result returned by the server
	 * &lt;/i&gt;
	 *     &lt;i&gt;//      e: Ext.Direct.RemotingEvent object
	 * &lt;/i&gt;
	 *     &lt;b&gt;function&lt;/b&gt;(result, e){
	 *         &lt;b&gt;var&lt;/b&gt; t = e.getTransaction();
	 *         &lt;b&gt;var&lt;/b&gt; action = t.action; &lt;i&gt;// server side Class called
	 * &lt;/i&gt;
	 *         &lt;b&gt;var&lt;/b&gt; method = t.method; &lt;i&gt;// server side method called
	 * &lt;/i&gt;
	 *         &lt;b&gt;if&lt;/b&gt;(e.status){
	 *             &lt;b&gt;var&lt;/b&gt; answer = Ext.encode(result); &lt;i&gt;// 8
	 * &lt;/i&gt;
	 *     
	 *         }&lt;b&gt;else&lt;/b&gt;{
	 *             &lt;b&gt;var&lt;/b&gt; msg = e.message; &lt;i&gt;// failure message
	 * &lt;/i&gt;
	 *         }
	 *     }
	 * );&lt;/code&gt;
	 * </pre>
	 * 
	 * In the example above, the server side "multiply" function will be passed
	 * two arguments (2 and 4). The "multiply" method should return the value 8
	 * which will be available as the <tt>result</tt> in the example above.
	 */
	@ClientConfig(JsonMode.Object)
	public Object getActions() {
		if (null != this.actions) {
			return this.actions;
		}
		ValueExpression _ve = getValueExpression("actions");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>actions</code> property.
	 * </p>
	 */
	public void setActions(Object actions) {
		this.actions = actions;
		handleConfig("actions", actions);
	}

	private Integer enableBuffer;

	/**
	 * <p>
	 * <tt>true</tt> or <tt>false</tt> to enable or disable combining of method
	 * calls. If a number is specified this is the amount of time in
	 * milliseconds to wait before sending a batched request (defaults to
	 * <tt>10</tt>).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Calls which are received within the specified timeframe will be
	 * concatenated together and sent in a single request, optimizing the
	 * application by reducing the amount of round trips that have to be made to
	 * the server.
	 * </p>
	 */
	public Integer getEnableBuffer() {
		if (null != this.enableBuffer) {
			return this.enableBuffer;
		}
		ValueExpression _ve = getValueExpression("enableBuffer");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>enableBuffer</code> property.
	 * </p>
	 */
	public void setEnableBuffer(Integer enableBuffer) {
		this.enableBuffer = enableBuffer;
		handleConfig("enableBuffer", enableBuffer);
	}

	private String enableUrlEncode;

	/**
	 * Specify which param will hold the arguments forthe method. Defaults to <tt>'data'</tt>
	 * .
	 */
	public String getEnableUrlEncode() {
		if (null != this.enableUrlEncode) {
			return this.enableUrlEncode;
		}
		ValueExpression _ve = getValueExpression("enableUrlEncode");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>enableUrlEncode</code> property.
	 * </p>
	 */
	public void setEnableUrlEncode(String enableUrlEncode) {
		this.enableUrlEncode = enableUrlEncode;
		handleConfig("enableUrlEncode", enableUrlEncode);
	}

	private Integer maxRetries;

	/**
	 * Number of times to re-attempt delivery onfailure of a call.
	 */
	public Integer getMaxRetries() {
		if (null != this.maxRetries) {
			return this.maxRetries;
		}
		ValueExpression _ve = getValueExpression("maxRetries");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maxRetries</code> property.
	 * </p>
	 */
	public void setMaxRetries(Integer maxRetries) {
		this.maxRetries = maxRetries;
		handleConfig("maxRetries", maxRetries);
	}

	private String namespace;

	/**
	 * Namespace for the Remoting Provider (defaults tothe browser global scope
	 * of <i>window</i>). Explicitly specify the namespace Object, or specify a
	 * String to have a <a href="output/Ext.html#Ext-namespace"
	 * ext:member="namespace" ext:cls="Ext">namespace created</a> implicitly.
	 */
	public String getNamespace() {
		if (null != this.namespace) {
			return this.namespace;
		}
		ValueExpression _ve = getValueExpression("namespace");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>namespace</code> property.
	 * </p>
	 */
	public void setNamespace(String namespace) {
		this.namespace = namespace;
		handleConfig("namespace", namespace);
	}

	private String url;

	/**
	 * <b>Required</b>. The url to connect to the <a
	 * href="output/Ext.Direct.html"
	 * ext:cls="Ext.Direct">Ext.Direct</a>server-side router.
	 */
	public String getUrl() {
		if (null != this.url) {
			return this.url;
		}
		ValueExpression _ve = getValueExpression("url");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>url</code> property.
	 * </p>
	 */
	public void setUrl(String url) {
		this.url = url;
		handleConfig("url", url);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[7];
		}
		_values[0] = super.saveState(_context);
		_values[1] = actions;
		_values[2] = enableBuffer;
		_values[3] = enableUrlEncode;
		_values[4] = maxRetries;
		_values[5] = namespace;
		_values[6] = url;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.actions = (Object) _values[1];
		this.handleConfig("actions", this.actions);
		this.enableBuffer = (Integer) _values[2];
		this.handleConfig("enableBuffer", this.enableBuffer);
		this.enableUrlEncode = (String) _values[3];
		this.handleConfig("enableUrlEncode", this.enableUrlEncode);
		this.maxRetries = (Integer) _values[4];
		this.handleConfig("maxRetries", this.maxRetries);
		this.namespace = (String) _values[5];
		this.handleConfig("namespace", this.namespace);
		this.url = (String) _values[6];
		this.handleConfig("url", this.url);

	}
}