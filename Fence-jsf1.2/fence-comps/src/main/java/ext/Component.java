package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.util.Observable;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * Base class for all Ext components. All subclasses of Component may
 * participate in the automated Ext component lifecycle of creation, rendering
 * and destruction which is provided by the <a href="output/Ext.Container.html"
 * ext:cls="Ext.Container">Container</a> class. Components may be added to a
 * Container through the <a href="output/Ext.Container.html#Ext.Container-items"
 * ext:member="items" ext:cls="Ext.Container">items</a> config option at the
 * time the Container is created, or they may be added dynamically via the <a
 * href="output/Ext.Container.html#Ext.Container-add" ext:member="add"
 * ext:cls="Ext.Container">add</a> method.
 * </p>
 * 
 * <p>
 * The Component base class has built-in support for basic hide/show and
 * enable/disable behavior.
 * </p>
 * 
 * <p>
 * All Components are registered with the <a href="output/Ext.ComponentMgr.html"
 * ext:cls="Ext.ComponentMgr">Ext.ComponentMgr</a> on construction so that they
 * can be referenced at any time via <a href="output/Ext.html#Ext-getCmp"
 * ext:member="getCmp" ext:cls="Ext">Ext.getCmp</a>, passing the <a
 * href="output/Ext.Component.html#Ext.Component-id" ext:member="id"
 * ext:cls="Ext.Component">id</a>.
 * </p>
 * 
 * <p>
 * All user-developed visual widgets that are required to participate in
 * automated lifecycle and size management should subclass Component (or <a
 * href="output/Ext.BoxComponent.html"
 * ext:cls="Ext.BoxComponent">Ext.BoxComponent</a> if managed box model handling
 * is required, ie height and width management).
 * </p>
 * 
 * <p>
 * See the <a
 * href="http://extjs.com/learn/Tutorial:Creating_new_UI_controls">Creating new
 * UI controls</a> tutorial for details on how and to either extend or augment
 * ExtJs base classes to create custom Components.
 * </p>
 * 
 * <p>
 * Every component has a specific xtype, which is its Ext-specific type name,
 * along with methods for checking the xtype like <a
 * href="output/Ext.Component.html#Ext.Component-getXType" ext:member="getXType"
 * ext:cls="Ext.Component">getXType</a> and <a
 * href="output/Ext.Component.html#Ext.Component-isXType" ext:member="isXType"
 * ext:cls="Ext.Component">isXType</a>. This is the list of all valid xtypes:
 * </p>
 * 
 * <pre>
 * xtype            Class
 * -------------    ------------------
 * box              &lt;a href=&quot;output/Ext.BoxComponent.html&quot; ext:cls=&quot;Ext.BoxComponent&quot;&gt;Ext.BoxComponent&lt;/a&gt;
 * button           &lt;a href=&quot;output/Ext.Button.html&quot; ext:cls=&quot;Ext.Button&quot;&gt;Ext.Button&lt;/a&gt;
 * buttongroup      &lt;a href=&quot;output/Ext.ButtonGroup.html&quot; ext:cls=&quot;Ext.ButtonGroup&quot;&gt;Ext.ButtonGroup&lt;/a&gt;
 * colorpalette     &lt;a href=&quot;output/Ext.ColorPalette.html&quot; ext:cls=&quot;Ext.ColorPalette&quot;&gt;Ext.ColorPalette&lt;/a&gt;
 * component        &lt;a href=&quot;output/Ext.Component.html&quot; ext:cls=&quot;Ext.Component&quot;&gt;Ext.Component&lt;/a&gt;
 * container        &lt;a href=&quot;output/Ext.Container.html&quot; ext:cls=&quot;Ext.Container&quot;&gt;Ext.Container&lt;/a&gt;
 * cycle            &lt;a href=&quot;output/Ext.CycleButton.html&quot; ext:cls=&quot;Ext.CycleButton&quot;&gt;Ext.CycleButton&lt;/a&gt;
 * dataview         &lt;a href=&quot;output/Ext.DataView.html&quot; ext:cls=&quot;Ext.DataView&quot;&gt;Ext.DataView&lt;/a&gt;
 * datepicker       &lt;a href=&quot;output/Ext.DatePicker.html&quot; ext:cls=&quot;Ext.DatePicker&quot;&gt;Ext.DatePicker&lt;/a&gt;
 * editor           &lt;a href=&quot;output/Ext.Editor.html&quot; ext:cls=&quot;Ext.Editor&quot;&gt;Ext.Editor&lt;/a&gt;
 * editorgrid       &lt;a href=&quot;output/Ext.grid.EditorGridPanel.html&quot; ext:cls=&quot;Ext.grid.EditorGridPanel&quot;&gt;Ext.grid.EditorGridPanel&lt;/a&gt;
 * flash            &lt;a href=&quot;output/Ext.FlashComponent.html&quot; ext:cls=&quot;Ext.FlashComponent&quot;&gt;Ext.FlashComponent&lt;/a&gt;
 * grid             &lt;a href=&quot;output/Ext.grid.GridPanel.html&quot; ext:cls=&quot;Ext.grid.GridPanel&quot;&gt;Ext.grid.GridPanel&lt;/a&gt;
 * listview         &lt;a href=&quot;output/Ext.ListView.html&quot; ext:cls=&quot;Ext.ListView&quot;&gt;Ext.ListView&lt;/a&gt;
 * panel            &lt;a href=&quot;output/Ext.Panel.html&quot; ext:cls=&quot;Ext.Panel&quot;&gt;Ext.Panel&lt;/a&gt;
 * progress         &lt;a href=&quot;output/Ext.ProgressBar.html&quot; ext:cls=&quot;Ext.ProgressBar&quot;&gt;Ext.ProgressBar&lt;/a&gt;
 * propertygrid     &lt;a href=&quot;output/Ext.grid.PropertyGrid.html&quot; ext:cls=&quot;Ext.grid.PropertyGrid&quot;&gt;Ext.grid.PropertyGrid&lt;/a&gt;
 * slider           &lt;a href=&quot;output/Ext.Slider.html&quot; ext:cls=&quot;Ext.Slider&quot;&gt;Ext.Slider&lt;/a&gt;
 * spacer           &lt;a href=&quot;output/Ext.Spacer.html&quot; ext:cls=&quot;Ext.Spacer&quot;&gt;Ext.Spacer&lt;/a&gt;
 * splitbutton      &lt;a href=&quot;output/Ext.SplitButton.html&quot; ext:cls=&quot;Ext.SplitButton&quot;&gt;Ext.SplitButton&lt;/a&gt;
 * tabpanel         &lt;a href=&quot;output/Ext.TabPanel.html&quot; ext:cls=&quot;Ext.TabPanel&quot;&gt;Ext.TabPanel&lt;/a&gt;
 * treepanel        &lt;a href=&quot;output/Ext.tree.TreePanel.html&quot; ext:cls=&quot;Ext.tree.TreePanel&quot;&gt;Ext.tree.TreePanel&lt;/a&gt;
 * viewport         &lt;a href=&quot;output/Ext.ViewPort.html&quot; ext:cls=&quot;Ext.ViewPort&quot;&gt;Ext.ViewPort&lt;/a&gt;
 * window           &lt;a href=&quot;output/Ext.Window.html&quot; ext:cls=&quot;Ext.Window&quot;&gt;Ext.Window&lt;/a&gt;
 * 
 * Toolbar components
 * ---------------------------------------
 * paging           &lt;a href=&quot;output/Ext.PagingToolbar.html&quot; ext:cls=&quot;Ext.PagingToolbar&quot;&gt;Ext.PagingToolbar&lt;/a&gt;
 * toolbar          &lt;a href=&quot;output/Ext.Toolbar.html&quot; ext:cls=&quot;Ext.Toolbar&quot;&gt;Ext.Toolbar&lt;/a&gt;
 * tbbutton         &lt;a href=&quot;output/Ext.Toolbar.Button.html&quot; ext:cls=&quot;Ext.Toolbar.Button&quot;&gt;Ext.Toolbar.Button&lt;/a&gt;        (deprecated; use button)
 * tbfill           &lt;a href=&quot;output/Ext.Toolbar.Fill.html&quot; ext:cls=&quot;Ext.Toolbar.Fill&quot;&gt;Ext.Toolbar.Fill&lt;/a&gt;
 * tbitem           &lt;a href=&quot;output/Ext.Toolbar.Item.html&quot; ext:cls=&quot;Ext.Toolbar.Item&quot;&gt;Ext.Toolbar.Item&lt;/a&gt;
 * tbseparator      &lt;a href=&quot;output/Ext.Toolbar.Separator.html&quot; ext:cls=&quot;Ext.Toolbar.Separator&quot;&gt;Ext.Toolbar.Separator&lt;/a&gt;
 * tbspacer         &lt;a href=&quot;output/Ext.Toolbar.Spacer.html&quot; ext:cls=&quot;Ext.Toolbar.Spacer&quot;&gt;Ext.Toolbar.Spacer&lt;/a&gt;
 * tbsplit          &lt;a href=&quot;output/Ext.Toolbar.SplitButton.html&quot; ext:cls=&quot;Ext.Toolbar.SplitButton&quot;&gt;Ext.Toolbar.SplitButton&lt;/a&gt;   (deprecated; use splitbutton)
 * tbtext           &lt;a href=&quot;output/Ext.Toolbar.TextItem.html&quot; ext:cls=&quot;Ext.Toolbar.TextItem&quot;&gt;Ext.Toolbar.TextItem&lt;/a&gt;
 * 
 * Menu components
 * ---------------------------------------
 * menu             &lt;a href=&quot;output/Ext.menu.Menu.html&quot; ext:cls=&quot;Ext.menu.Menu&quot;&gt;Ext.menu.Menu&lt;/a&gt;
 * colormenu        &lt;a href=&quot;output/Ext.menu.ColorMenu.html&quot; ext:cls=&quot;Ext.menu.ColorMenu&quot;&gt;Ext.menu.ColorMenu&lt;/a&gt;
 * datemenu         &lt;a href=&quot;output/Ext.menu.DateMenu.html&quot; ext:cls=&quot;Ext.menu.DateMenu&quot;&gt;Ext.menu.DateMenu&lt;/a&gt;
 * menubaseitem     &lt;a href=&quot;output/Ext.menu.BaseItem.html&quot; ext:cls=&quot;Ext.menu.BaseItem&quot;&gt;Ext.menu.BaseItem&lt;/a&gt;
 * menucheckitem    &lt;a href=&quot;output/Ext.menu.CheckItem.html&quot; ext:cls=&quot;Ext.menu.CheckItem&quot;&gt;Ext.menu.CheckItem&lt;/a&gt;
 * menuitem         &lt;a href=&quot;output/Ext.menu.Item.html&quot; ext:cls=&quot;Ext.menu.Item&quot;&gt;Ext.menu.Item&lt;/a&gt;
 * menuseparator    &lt;a href=&quot;output/Ext.menu.Separator.html&quot; ext:cls=&quot;Ext.menu.Separator&quot;&gt;Ext.menu.Separator&lt;/a&gt;
 * menutextitem     &lt;a href=&quot;output/Ext.menu.TextItem.html&quot; ext:cls=&quot;Ext.menu.TextItem&quot;&gt;Ext.menu.TextItem&lt;/a&gt;
 * 
 * Form components
 * ---------------------------------------
 * form             &lt;a href=&quot;output/Ext.FormPanel.html&quot; ext:cls=&quot;Ext.FormPanel&quot;&gt;Ext.FormPanel&lt;/a&gt;
 * checkbox         &lt;a href=&quot;output/Ext.form.Checkbox.html&quot; ext:cls=&quot;Ext.form.Checkbox&quot;&gt;Ext.form.Checkbox&lt;/a&gt;
 * checkboxgroup    &lt;a href=&quot;output/Ext.form.CheckboxGroup.html&quot; ext:cls=&quot;Ext.form.CheckboxGroup&quot;&gt;Ext.form.CheckboxGroup&lt;/a&gt;
 * combo            &lt;a href=&quot;output/Ext.form.ComboBox.html&quot; ext:cls=&quot;Ext.form.ComboBox&quot;&gt;Ext.form.ComboBox&lt;/a&gt;
 * datefield        &lt;a href=&quot;output/Ext.form.DateField.html&quot; ext:cls=&quot;Ext.form.DateField&quot;&gt;Ext.form.DateField&lt;/a&gt;
 * displayfield     &lt;a href=&quot;output/Ext.form.DisplayField.html&quot; ext:cls=&quot;Ext.form.DisplayField&quot;&gt;Ext.form.DisplayField&lt;/a&gt;
 * field            &lt;a href=&quot;output/Ext.form.Field.html&quot; ext:cls=&quot;Ext.form.Field&quot;&gt;Ext.form.Field&lt;/a&gt;
 * fieldset         &lt;a href=&quot;output/Ext.form.FieldSet.html&quot; ext:cls=&quot;Ext.form.FieldSet&quot;&gt;Ext.form.FieldSet&lt;/a&gt;
 * hidden           &lt;a href=&quot;output/Ext.form.Hidden.html&quot; ext:cls=&quot;Ext.form.Hidden&quot;&gt;Ext.form.Hidden&lt;/a&gt;
 * htmleditor       &lt;a href=&quot;output/Ext.form.HtmlEditor.html&quot; ext:cls=&quot;Ext.form.HtmlEditor&quot;&gt;Ext.form.HtmlEditor&lt;/a&gt;
 * label            &lt;a href=&quot;output/Ext.form.Label.html&quot; ext:cls=&quot;Ext.form.Label&quot;&gt;Ext.form.Label&lt;/a&gt;
 * numberfield      &lt;a href=&quot;output/Ext.form.NumberField.html&quot; ext:cls=&quot;Ext.form.NumberField&quot;&gt;Ext.form.NumberField&lt;/a&gt;
 * radio            &lt;a href=&quot;output/Ext.form.Radio.html&quot; ext:cls=&quot;Ext.form.Radio&quot;&gt;Ext.form.Radio&lt;/a&gt;
 * radiogroup       &lt;a href=&quot;output/Ext.form.RadioGroup.html&quot; ext:cls=&quot;Ext.form.RadioGroup&quot;&gt;Ext.form.RadioGroup&lt;/a&gt;
 * textarea         &lt;a href=&quot;output/Ext.form.TextArea.html&quot; ext:cls=&quot;Ext.form.TextArea&quot;&gt;Ext.form.TextArea&lt;/a&gt;
 * textfield        &lt;a href=&quot;output/Ext.form.TextField.html&quot; ext:cls=&quot;Ext.form.TextField&quot;&gt;Ext.form.TextField&lt;/a&gt;
 * timefield        &lt;a href=&quot;output/Ext.form.TimeField.html&quot; ext:cls=&quot;Ext.form.TimeField&quot;&gt;Ext.form.TimeField&lt;/a&gt;
 * trigger          &lt;a href=&quot;output/Ext.form.TriggerField.html&quot; ext:cls=&quot;Ext.form.TriggerField&quot;&gt;Ext.form.TriggerField&lt;/a&gt;
 * 
 * Chart components
 * ---------------------------------------
 * chart            &lt;a href=&quot;output/Ext.chart.Chart.html&quot; ext:cls=&quot;Ext.chart.Chart&quot;&gt;Ext.chart.Chart&lt;/a&gt;
 * barchart         &lt;a href=&quot;output/Ext.chart.BarChart.html&quot; ext:cls=&quot;Ext.chart.BarChart&quot;&gt;Ext.chart.BarChart&lt;/a&gt;
 * cartesianchart   &lt;a href=&quot;output/Ext.chart.CartesianChart.html&quot; ext:cls=&quot;Ext.chart.CartesianChart&quot;&gt;Ext.chart.CartesianChart&lt;/a&gt;
 * columnchart      &lt;a href=&quot;output/Ext.chart.ColumnChart.html&quot; ext:cls=&quot;Ext.chart.ColumnChart&quot;&gt;Ext.chart.ColumnChart&lt;/a&gt;
 * linechart        &lt;a href=&quot;output/Ext.chart.LineChart.html&quot; ext:cls=&quot;Ext.chart.LineChart&quot;&gt;Ext.chart.LineChart&lt;/a&gt;
 * piechart         &lt;a href=&quot;output/Ext.chart.PieChart.html&quot; ext:cls=&quot;Ext.chart.PieChart&quot;&gt;Ext.chart.PieChart&lt;/a&gt;
 * 
 * Store xtypes
 * ---------------------------------------
 * arraystore       &lt;a href=&quot;output/Ext.data.ArrayStore.html&quot; ext:cls=&quot;Ext.data.ArrayStore&quot;&gt;Ext.data.ArrayStore&lt;/a&gt;
 * directstore      &lt;a href=&quot;output/Ext.data.DirectStore.html&quot; ext:cls=&quot;Ext.data.DirectStore&quot;&gt;Ext.data.DirectStore&lt;/a&gt;
 * groupingstore    &lt;a href=&quot;output/Ext.data.GroupingStore.html&quot; ext:cls=&quot;Ext.data.GroupingStore&quot;&gt;Ext.data.GroupingStore&lt;/a&gt;
 * jsonstore        &lt;a href=&quot;output/Ext.data.JsonStore.html&quot; ext:cls=&quot;Ext.data.JsonStore&quot;&gt;Ext.data.JsonStore&lt;/a&gt;
 * simplestore      &lt;a href=&quot;output/Ext.data.SimpleStore.html&quot; ext:cls=&quot;Ext.data.SimpleStore&quot;&gt;Ext.data.SimpleStore&lt;/a&gt;      (deprecated; use arraystore)
 * store            &lt;a href=&quot;output/Ext.data.Store.html&quot; ext:cls=&quot;Ext.data.Store&quot;&gt;Ext.data.Store&lt;/a&gt;
 * xmlstore         &lt;a href=&quot;output/Ext.data.XmlStore.html&quot; ext:cls=&quot;Ext.data.XmlStore&quot;&gt;Ext.data.XmlStore&lt;/a&gt;
 * </pre>
 */
@InstanceOf("Ext.Component")
public class Component extends Observable {
	public static final String COMPONENT_TYPE = "Ext.Component";
	public static final String COMPONENT_FAMILY = "Ext.Component";

	/**
	 * <p>
	 * Create a new {@link Component} instance with default property values.
	 * </p>
	 */
	public Component() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean allowDomMove;

	/**
	 * Whether the component can move the Dom node whenrendering (defaults to
	 * true).
	 */
	public Boolean getAllowDomMove() {
		if (null != this.allowDomMove) {
			return this.allowDomMove;
		}
		ValueExpression _ve = getValueExpression("allowDomMove");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>allowDomMove</code> property.
	 * </p>
	 */
	public void setAllowDomMove(Boolean allowDomMove) {
		this.allowDomMove = allowDomMove;
		this.handleConfig("allowDomMove", allowDomMove);
	}

	private String anchor;

	/**
	 * <p>
	 * <b>Note</b>: this config is only used when this Component is rendered by
	 * a Container which has been configured to use an <b><a
	 * href="output/Ext.layout.AnchorLayout.html"
	 * ext:cls="Ext.layout.AnchorLayout">AnchorLayout</a></b> based layout
	 * manager, for example:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><a href="output/Ext.form.FormPanel.html"
	 * ext:cls="Ext.form.FormPanel">Ext.form.FormPanel</a></li>
	 * 
	 * <li>specifying <code>layout: <em>'anchor'</em> <i>// or
<em>'form'</em>, or <em>'absolute'</em></i></code></li>
	 * </ul>
	 * </div>
	 * 
	 * <br>
	 * <br>
	 * 
	 * 
	 * <p>
	 * See <a href="output/Ext.layout.AnchorLayout.html"
	 * ext:cls="Ext.layout.AnchorLayout">Ext.layout.AnchorLayout</a>.<a href=
	 * "output/Ext.layout.AnchorLayout.html#Ext.layout.AnchorLayout-anchor"
	 * ext:member="anchor" ext:cls="Ext.layout.AnchorLayout">anchor</a> also.
	 * </p>
	 */
	public String getAnchor() {
		if (null != this.anchor) {
			return this.anchor;
		}
		ValueExpression _ve = getValueExpression("anchor");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>anchor</code> property.
	 * </p>
	 */
	public void setAnchor(String anchor) {
		this.anchor = anchor;
		this.handleConfig("anchor", anchor);
	}

	private Object applyTo;

	/**
	 * <p>
	 * Specify the id of the element, a DOM element or an existing Element
	 * corresponding to a DIV that is already present in the document that
	 * specifies some structural markup for this component.
	 * </p>
	 * 
	 * <div>
	 * <ul>
	 * <li><b>Description</b> :
	 * 
	 * <div style="margin-left: 2em"> <div class="sub-desc">When
	 * <tt>applyTo</tt> is used, constituent parts of the component can also be
	 * specified by id or CSS class name within the main element, and the
	 * component being created may attempt to create its subcomponents from that
	 * markup if applicable.</div> </div></li>
	 * 
	 * <li><b>Notes</b> :
	 * 
	 * <div style="margin-left: 2em"> <div class="sub-desc">When using this
	 * config, a call to render() is not required.</div>
	 * 
	 * <div class="sub-desc">If applyTo is specified, any value passed for <a
	 * href="output/Ext.Component.html#Ext.Component-renderTo"
	 * ext:member="renderTo" ext:cls="Ext.Component">renderTo</a> will be
	 * ignored and the target element's parent node will automatically be used
	 * as the component's container.</div> </div></li>
	 * </ul>
	 * </div>
	 */
	public Object getApplyTo() {
		if (null != this.applyTo) {
			return this.applyTo;
		}
		ValueExpression _ve = getValueExpression("applyTo");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>applyTo</code> property.
	 * </p>
	 */
	public void setApplyTo(Object applyTo) {
		this.applyTo = applyTo;
		this.handleConfig("applyTo", applyTo);
	}

	private Object autoEl;

	/**
	 * <p>
	 * A tag name or <a href="output/Ext.DomHelper.html"
	 * ext:cls="Ext.DomHelper">DomHelper</a> spec used to create the <a
	 * href="output/Ext.Component.html#Ext.Component-getEl" ext:member="getEl"
	 * ext:cls="Ext.Component">Element</a> which will encapsulate this
	 * Component.
	 * </p>
	 * 
	 * <p>
	 * You do not normally need to specify this. For the base classes <a
	 * href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">Ext.Component</a>, <a
	 * href="output/Ext.BoxComponent.html"
	 * ext:cls="Ext.BoxComponent">Ext.BoxComponent</a>, and <a
	 * href="output/Ext.Container.html"
	 * ext:cls="Ext.Container">Ext.Container</a>, this defaults to <b><tt>'div'</tt></b>.
	 * The more complex Ext classes use a more complex DOM structure created by
	 * their own onRender methods.
	 * </p>
	 * 
	 * <p>
	 * This is intended to allow the developer to create application-specific
	 * utility Components encapsulated by different DOM elements. Example usage:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{
	 *     xtype: &lt;em&gt;'box'&lt;/em&gt;,
	 *     autoEl: {
	 *         tag: &lt;em&gt;'img'&lt;/em&gt;,
	 *         src: &lt;em&gt;'http:&lt;i&gt;//www.example.com/example.jpg'&lt;/i&gt;&lt;/em&gt;
	 *     }
	 * }, {
	 *     xtype: &lt;em&gt;'box'&lt;/em&gt;,
	 *     autoEl: {
	 *         tag: &lt;em&gt;'blockquote'&lt;/em&gt;,
	 *         html: &lt;em&gt;'autoEl is cool!'&lt;/em&gt;
	 *     }
	 * }, {
	 *     xtype: &lt;em&gt;'container'&lt;/em&gt;,
	 *     autoEl: &lt;em&gt;'ul'&lt;/em&gt;,
	 *     cls: &lt;em&gt;'ux-unordered-list'&lt;/em&gt;,
	 *     items: {
	 *         xtype: &lt;em&gt;'box'&lt;/em&gt;,
	 *         autoEl: &lt;em&gt;'li'&lt;/em&gt;,
	 *         html: &lt;em&gt;'First list item'&lt;/em&gt;
	 *     }
	 * }&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getAutoEl() {
		if (null != this.autoEl) {
			return this.autoEl;
		}
		ValueExpression _ve = getValueExpression("autoEl");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoEl</code> property.
	 * </p>
	 */
	public void setAutoEl(Object autoEl) {
		this.autoEl = autoEl;
		this.handleConfig("autoEl", autoEl);
	}

	private Boolean autoShow;

	/**
	 * True if the component should check for hiddenclasses (e.g. 'x-hidden' or
	 * 'x-hide-display') and remove them on render (defaults to false).
	 */
	public Boolean getAutoShow() {
		if (null != this.autoShow) {
			return this.autoShow;
		}
		ValueExpression _ve = getValueExpression("autoShow");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoShow</code> property.
	 * </p>
	 */
	public void setAutoShow(Boolean autoShow) {
		this.autoShow = autoShow;
		this.handleConfig("autoShow", autoShow);
	}

	private String clearCls;

	/**
	 * <p>
	 * The CSS class used to to apply to the special clearing div rendered
	 * directly after each form field wrapper to provide field clearing
	 * (defaults to <tt>'x-form-clear-left'</tt>).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: this config is only used when this Component is rendered by
	 * a Container which has been configured to use the <b><a
	 * href="output/Ext.layout.FormLayout.html"
	 * ext:cls="Ext.layout.FormLayout">FormLayout</a></b> layout manager (e.g.
	 * <a href="output/Ext.form.FormPanel.html"
	 * ext:cls="Ext.form.FormPanel">Ext.form.FormPanel</a> or specifying <tt>layout:'form'</tt>
	 * ) and either a
	 * <tt><a href="output/Ext.Component.html#Ext.Component-fieldLabel" ext:member="fieldLabel" ext:cls="Ext.Component">fieldLabel</a></tt>
	 * is specified or <tt>isFormField=true</tt> is specified.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * See <a href="output/Ext.layout.FormLayout.html"
	 * ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>.<a
	 * href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-fieldTpl"
	 * ext:member="fieldTpl" ext:cls="Ext.layout.FormLayout">fieldTpl</a> also.
	 * </p>
	 */
	public String getClearCls() {
		if (null != this.clearCls) {
			return this.clearCls;
		}
		ValueExpression _ve = getValueExpression("clearCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>clearCls</code> property.
	 * </p>
	 */
	public void setClearCls(String clearCls) {
		this.clearCls = clearCls;
		this.handleConfig("clearCls", clearCls);
	}

	private String cls;

	/**
	 * An optional extra CSS class that will be added tothis component's Element
	 * (defaults to ''). This can be useful for adding customized styles to the
	 * component or any of its children using standard CSS rules.
	 */
	public String getCls() {
		if (null != this.cls) {
			return this.cls;
		}
		ValueExpression _ve = getValueExpression("cls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>cls</code> property.
	 * </p>
	 */
	public void setCls(String cls) {
		this.cls = cls;
		this.handleConfig("cls", cls);
	}

	private String ctCls;

	/**
	 * <p>
	 * An optional extra CSS class that will be added to this component's
	 * container. This can be useful for adding customized styles to the
	 * container or any of its children using standard CSS rules. See <a
	 * href="output/Ext.layout.ContainerLayout.html"
	 * ext:cls="Ext.layout.ContainerLayout">Ext.layout.ContainerLayout</a>.<a
	 * href=
	 * "output/Ext.layout.ContainerLayout.html#Ext.layout.ContainerLayout-extraCls"
	 * ext:member="extraCls" ext:cls="Ext.layout.ContainerLayout">extraCls</a>
	 * also.
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: <tt>ctCls</tt> defaults to <tt>''</tt> except for the following
	 * class which assigns a value by default:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><a href="output/Ext.layout.Box.html" ext:cls="Ext.layout.Box">Box
	 * Layout</a> : <tt>'x-box-layout-ct'</tt></li>
	 * </ul>
	 * </div>
	 * 
	 * To configure the above Class with an extra CSS class append to the
	 * default. For example, for BoxLayout (Hbox and Vbox):
	 * 
	 * <pre>
	 * &lt;code&gt;ctCls: &lt;em&gt;'x-box-layout-ct custom-class'&lt;/em&gt;&lt;/code&gt;
	 * </pre>
	 * 
	 * <br>
	 * <br>
	 */
	public String getCtCls() {
		if (null != this.ctCls) {
			return this.ctCls;
		}
		ValueExpression _ve = getValueExpression("ctCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>ctCls</code> property.
	 * </p>
	 */
	public void setCtCls(String ctCls) {
		this.ctCls = ctCls;
		this.handleConfig("ctCls", ctCls);
	}

	private Boolean disabled;

	/**
	 * Render this component disabled (default isfalse).
	 */
	public Boolean getDisabled() {
		if (null != this.disabled) {
			return this.disabled;
		}
		ValueExpression _ve = getValueExpression("disabled");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>disabled</code> property.
	 * </p>
	 */
	public void setDisabled(Boolean disabled) {
		this.disabled = disabled;
		this.handleConfig("disabled", disabled);
	}

	private String disabledClass;

	/**
	 * CSS class added to the component when it isdisabled (defaults to
	 * 'x-item-disabled').
	 */
	public String getDisabledClass() {
		if (null != this.disabledClass) {
			return this.disabledClass;
		}
		ValueExpression _ve = getValueExpression("disabledClass");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>disabledClass</code> property.
	 * </p>
	 */
	public void setDisabledClass(String disabledClass) {
		this.disabledClass = disabledClass;
		this.handleConfig("disabledClass", disabledClass);
	}

	private String fieldLabel;

	/**
	 * <p>
	 * The label text to display next to this Component (defaults to '').
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: this config is only used when this Component is rendered by
	 * a Container which has been configured to use the <b><a
	 * href="output/Ext.layout.FormLayout.html"
	 * ext:cls="Ext.layout.FormLayout">FormLayout</a></b> layout manager (e.g.
	 * <a href="output/Ext.form.FormPanel.html"
	 * ext:cls="Ext.form.FormPanel">Ext.form.FormPanel</a> or specifying <tt>layout:'form'</tt>
	 * ).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Also see
	 * <tt><a href="output/Ext.Component.html#Ext.Component-hideLabel" ext:member="hideLabel" ext:cls="Ext.Component">hideLabel</a></tt>
	 * and <a href="output/Ext.layout.FormLayout.html"
	 * ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>.<a
	 * href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-fieldTpl"
	 * ext:member="fieldTpl" ext:cls="Ext.layout.FormLayout">fieldTpl</a>.
	 * </p>
	 * 
	 * Example use:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.FormPanel({
	 *     height: 100,
	 *     renderTo: Ext.getBody(),
	 *     items: [{
	 *         xtype: &lt;em&gt;'textfield'&lt;/em&gt;,
	 *         fieldLabel: &lt;em&gt;'Name'&lt;/em&gt;
	 *     }]
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public String getFieldLabel() {
		if (null != this.fieldLabel) {
			return this.fieldLabel;
		}
		ValueExpression _ve = getValueExpression("fieldLabel");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>fieldLabel</code> property.
	 * </p>
	 */
	public void setFieldLabel(String fieldLabel) {
		this.fieldLabel = fieldLabel;
		this.handleConfig("fieldLabel", fieldLabel);
	}

	private Boolean hidden;

	/**
	 * Render this component hidden (default is false).If <tt>true</tt>, the <a
	 * href="output/Ext.Component.html#Ext.Component-hide" ext:member="hide"
	 * ext:cls="Ext.Component">hide</a> method will be called internally.
	 */
	public Boolean getHidden() {
		if (null != this.hidden) {
			return this.hidden;
		}
		ValueExpression _ve = getValueExpression("hidden");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hidden</code> property.
	 * </p>
	 */
	public void setHidden(Boolean hidden) {
		this.hidden = hidden;
		this.handleConfig("hidden", hidden);
	}

	private Boolean hideLabel;

	/**
	 * <p>
	 * <tt>true</tt> to completely hide the label element (<a
	 * href="output/Ext.Component.html#Ext.Component-fieldLabel"
	 * ext:member="fieldLabel" ext:cls="Ext.Component">label</a> and <a
	 * href="output/Ext.Component.html#Ext.Component-labelSeparator"
	 * ext:member="labelSeparator" ext:cls="Ext.Component">separator</a>).
	 * Defaults to <tt>false</tt>. By default, even if you do not specify a
	 * 
	 * <tt><a href="output/Ext.Component.html#Ext.Component-fieldLabel" ext:member="fieldLabel" ext:cls="Ext.Component">fieldLabel</a></tt>
	 * the space will still be reserved so that the field will line up with
	 * other fields that do have labels. Setting this to <tt>true</tt> will
	 * cause the field to not reserve that space.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: see the note for
	 * <tt><a href="output/Ext.Component.html#Ext.Component-clearCls" ext:member="clearCls" ext:cls="Ext.Component">clearCls</a></tt>
	 * .
	 * </p>
	 * 
	 * <br>
	 * Example use:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.FormPanel({
	 *     height: 100,
	 *     renderTo: Ext.getBody(),
	 *     items: [{
	 *         xtype: &lt;em&gt;'textfield'&lt;/em&gt;
	 *         hideLabel: true
	 *     }]
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public Boolean getHideLabel() {
		if (null != this.hideLabel) {
			return this.hideLabel;
		}
		ValueExpression _ve = getValueExpression("hideLabel");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideLabel</code> property.
	 * </p>
	 */
	public void setHideLabel(Boolean hideLabel) {
		this.hideLabel = hideLabel;
		this.handleConfig("hideLabel", hideLabel);
	}

	private String hideMode;

	/**
	 * <p>
	 * How this component should be hidden. Supported values are <tt>'visibility'</tt> (css
	 * visibility), <tt>'offsets'</tt> (negative offset position) and <tt>'display'</tt> (css display).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: the default of <tt>'display'</tt> is generally preferred since items are
	 * automatically laid out when they are first shown (no sizing is done while
	 * hidden).
	 * </p>
	 */
	public String getHideMode() {
		if (null != this.hideMode) {
			return this.hideMode;
		}
		ValueExpression _ve = getValueExpression("hideMode");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideMode</code> property.
	 * </p>
	 */
	public void setHideMode(String hideMode) {
		this.hideMode = hideMode;
		this.handleConfig("hideMode", hideMode);
	}

	private Boolean hideParent;

	/**
	 * True to hide and show the component's containerwhen hide/show is called
	 * on the component, false to hide and show the component itself (defaults
	 * to false). For example, this can be used as a shortcut for a hide button
	 * on a window by setting hide:true on the button when adding it to its
	 * parent container.
	 */
	public Boolean getHideParent() {
		if (null != this.hideParent) {
			return this.hideParent;
		}
		ValueExpression _ve = getValueExpression("hideParent");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideParent</code> property.
	 * </p>
	 */
	public void setHideParent(Boolean hideParent) {
		this.hideParent = hideParent;
		this.handleConfig("hideParent", hideParent);
	}

	private String id;

	/**
	 * <p>
	 * The <b>unique</b> id of this component (defaults to an <a
	 * href="output/Ext.Component.html#Ext.Component-getId" ext:member="getId"
	 * ext:cls="Ext.Component">auto-assigned id</a>). You should assign an id if
	 * you need to be able to access the component later and you do not have an
	 * object reference available (e.g., using <a href="output/Ext.html"
	 * ext:cls="Ext">Ext</a>.<a href="output/Ext.html#Ext-getCmp"
	 * ext:member="getCmp" ext:cls="Ext">getCmp</a>).
	 * </p>
	 * 
	 * <p>
	 * Note that this id will also be used as the element id for the containing
	 * HTML element that is rendered to the page for this component. This allows
	 * you to write id-based CSS rules to style the specific instance of this
	 * component uniquely, and also to select sub-elements using this
	 * component's id as the parent.
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: to avoid complications imposed by a unique <tt>id</tt> also
	 * see
	 * <code><a href="output/Ext.Component.html#Ext.Component-itemId" ext:member="itemId" ext:cls="Ext.Component">itemId</a></code>
	 * and
	 * <code><a href="output/Ext.Component.html#Ext.Component-ref" ext:member="ref" ext:cls="Ext.Component">ref</a></code>
	 * .
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: to access the container of an item see
	 * <code><a href="output/Ext.Component.html#Ext.Component-ownerCt" ext:member="ownerCt" ext:cls="Ext.Component">ownerCt</a></code>
	 * .
	 * </p>
	 */
	public String getId() {
		if (null != this.id) {
			return this.id;
		}
		ValueExpression _ve = getValueExpression("id");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>id</code> property.
	 * </p>
	 */
	public void setId(String id) {
		this.id = id;
		this.handleConfig("id", id);
	}

	private String itemCls;

	/**
	 * <p>
	 * An additional CSS class to apply to the div wrapping the form item
	 * element of this field. If supplied, <tt>itemCls</tt> at the <b>field</b>
	 * level will override the default <tt>itemCls</tt> supplied at the
	 * <b>container</b> level. The value specified for <tt>itemCls</tt> will be
	 * added to the default class (<tt>'x-form-item'</tt>).
	 * </p>
	 * 
	 * <p>
	 * Since it is applied to the item wrapper (see <a
	 * href="output/Ext.layout.FormLayout.html"
	 * ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>.<a
	 * href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-fieldTpl"
	 * ext:member="fieldTpl" ext:cls="Ext.layout.FormLayout">fieldTpl</a>), it
	 * allows you to write standard CSS rules that can apply to the field, the
	 * label (if specified), or any other element within the markup for the
	 * field.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: see the note for
	 * <tt><a href="output/Ext.Component.html#Ext.Component-fieldLabel" ext:member="fieldLabel" ext:cls="Ext.Component">fieldLabel</a></tt>
	 * .
	 * </p>
	 * 
	 * <br>
	 * Example use:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;i&gt;// Apply a style to the field&lt;em&gt;'s &lt;b&gt;label&lt;/b&gt;:&lt;/em&gt;
	 * &lt;style&gt;
	 *     .required .x-form-item-&lt;b&gt;label&lt;/b&gt; {font-weight:bold;color:red;}
	 * &lt;/style&gt;
	 * 
	 * &lt;b&gt;new&lt;/b&gt; Ext.FormPanel({
	 *     height: 100,
	 *     renderTo: Ext.getBody(),
	 *     items: [{
	 *         xtype: '&lt;/i&gt;textfield&lt;em&gt;',
	 *         fieldLabel: '&lt;/em&gt;Name&lt;em&gt;',
	 *         itemCls: '&lt;/em&gt;required&lt;em&gt;' &lt;i&gt;//this &lt;b&gt;label&lt;/b&gt; will be styled&lt;/i&gt;
	 *     },{
	 *         xtype: '&lt;/em&gt;textfield&lt;em&gt;',
	 *         fieldLabel: '&lt;/em&gt;Favorite Color&lt;em&gt;'
	 *     }]
	 * });&lt;/em&gt;&lt;/code&gt;
	 * </pre>
	 */
	public String getItemCls() {
		if (null != this.itemCls) {
			return this.itemCls;
		}
		ValueExpression _ve = getValueExpression("itemCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>itemCls</code> property.
	 * </p>
	 */
	public void setItemCls(String itemCls) {
		this.itemCls = itemCls;
		this.handleConfig("itemCls", itemCls);
	}

	private String itemId;

	/**
	 * <p>
	 * An <tt>itemId</tt> can be used as an alternative way to get a reference
	 * to a component when no object reference is available. Instead of using an
	 * 
	 * <code><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></code>
	 * with <a href="output/Ext.html" ext:cls="Ext">Ext</a>.<a
	 * href="output/Ext.html#Ext-getCmp" ext:member="getCmp"
	 * ext:cls="Ext">getCmp</a>, use <code>itemId</code> with <a
	 * href="output/Ext.Container.html"
	 * ext:cls="Ext.Container">Ext.Container</a>.<a
	 * href="output/Ext.Container.html#Ext.Container-getComponent"
	 * ext:member="getComponent" ext:cls="Ext.Container">getComponent</a> which
	 * will retrieve <code>itemId</code>'s or
	 * <tt><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></tt>
	 * 's. Since <code>itemId</code>'s are an index to the container's internal
	 * MixedCollection, the <code>itemId</code> is scoped locally to the
	 * container -- avoiding potential conflicts with <a
	 * href="output/Ext.ComponentMgr.html"
	 * ext:cls="Ext.ComponentMgr">Ext.ComponentMgr</a> which requires a
	 * <b>unique</b>
	 * <code><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></code>
	 * .
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; c = &lt;b&gt;new&lt;/b&gt; Ext.Panel({ &lt;i&gt;//&lt;/i&gt;
	 *     &lt;a href=&quot;output/Ext.BoxComponent.html#Ext.BoxComponent-height&quot; ext:member=&quot;height&quot; ext:cls=&quot;Ext.BoxComponent&quot;&gt;height&lt;/a&gt;: 300,
	 *     &lt;a href=&quot;output/Ext.Component.html#Ext.Component-renderTo&quot; ext:member=&quot;renderTo&quot; ext:cls=&quot;Ext.Component&quot;&gt;renderTo&lt;/a&gt;: document.body,
	 *     &lt;a href=&quot;output/Ext.Container.html#Ext.Container-layout&quot; ext:member=&quot;layout&quot; ext:cls=&quot;Ext.Container&quot;&gt;layout&lt;/a&gt;: &lt;em&gt;'auto'&lt;/em&gt;,
	 *     &lt;a href=&quot;output/Ext.Container.html#Ext.Container-items&quot; ext:member=&quot;items&quot; ext:cls=&quot;Ext.Container&quot;&gt;items&lt;/a&gt;: [
	 *         {
	 *             itemId: &lt;em&gt;'p1'&lt;/em&gt;,
	 *             &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-title&quot; ext:member=&quot;title&quot; ext:cls=&quot;Ext.Panel&quot;&gt;title&lt;/a&gt;: &lt;em&gt;'Panel 1'&lt;/em&gt;,
	 *             &lt;a href=&quot;output/Ext.BoxComponent.html#Ext.BoxComponent-height&quot; ext:member=&quot;height&quot; ext:cls=&quot;Ext.BoxComponent&quot;&gt;height&lt;/a&gt;: 150
	 *         },
	 *         {
	 *             itemId: &lt;em&gt;'p2'&lt;/em&gt;,
	 *             &lt;a href=&quot;output/Ext.Panel.html#Ext.Panel-title&quot; ext:member=&quot;title&quot; ext:cls=&quot;Ext.Panel&quot;&gt;title&lt;/a&gt;: &lt;em&gt;'Panel 2'&lt;/em&gt;,
	 *             &lt;a href=&quot;output/Ext.BoxComponent.html#Ext.BoxComponent-height&quot; ext:member=&quot;height&quot; ext:cls=&quot;Ext.BoxComponent&quot;&gt;height&lt;/a&gt;: 150
	 *         }
	 *     ]
	 * })
	 * p1 = c.&lt;a href=&quot;output/Ext.Container.html#Ext.Container-getComponent&quot; ext:member=&quot;getComponent&quot; ext:cls=&quot;Ext.Container&quot;&gt;getComponent&lt;/a&gt;(&lt;em&gt;'p1'&lt;/em&gt;); &lt;i&gt;// not the same as &lt;a href=&quot;output/Ext.html#Ext-getCmp&quot; ext:member=&quot;getCmp&quot; ext:cls=&quot;Ext&quot;&gt;Ext.getCmp()&lt;/a&gt;&lt;/i&gt;
	 * p2 = p1.&lt;a href=&quot;output/Ext.Component.html#Ext.Component-ownerCt&quot; ext:member=&quot;ownerCt&quot; ext:cls=&quot;Ext.Component&quot;&gt;ownerCt&lt;/a&gt;.&lt;a href=&quot;output/Ext.Container.html#Ext.Container-getComponent&quot; ext:member=&quot;getComponent&quot; ext:cls=&quot;Ext.Container&quot;&gt;getComponent&lt;/a&gt;(&lt;em&gt;'p2'&lt;/em&gt;); &lt;i&gt;// reference via a sibling&lt;/i&gt;&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * Also see
	 * <tt><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></tt>
	 * and
	 * <code><a href="output/Ext.Component.html#Ext.Component-ref" ext:member="ref" ext:cls="Ext.Component">ref</a></code>
	 * .
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: to access the container of an item see
	 * <tt><a href="output/Ext.Component.html#Ext.Component-ownerCt" ext:member="ownerCt" ext:cls="Ext.Component">ownerCt</a></tt>
	 * .
	 * </p>
	 */
	public String getItemId() {
		if (null != this.itemId) {
			return this.itemId;
		}
		ValueExpression _ve = getValueExpression("itemId");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>itemId</code> property.
	 * </p>
	 */
	public void setItemId(String itemId) {
		this.itemId = itemId;
		this.handleConfig("itemId", itemId);
	}

	private String labelSeparator;

	/**
	 * <p>
	 * The separator to display after the text of each
	 * <tt><a href="output/Ext.Component.html#Ext.Component-fieldLabel" ext:member="fieldLabel" ext:cls="Ext.Component">fieldLabel</a></tt>
	 * . This property may be configured at various levels. The order of
	 * precedence is:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li>field / component level</li>
	 * 
	 * <li>container level</li>
	 * 
	 * <li><a href=
	 * "output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-labelSeparator"
	 * ext:member="labelSeparator" ext:cls="Ext.layout.FormLayout">layout
	 * level</a> (defaults to colon <tt>':'</tt>)</li>
	 * </ul>
	 * </div>
	 * 
	 * To display no separator for this field's label specify empty string ''.<br>
	 * <br>
	 * <br>
	 * <p>
	 * <b>Note</b>: see the note for
	 * <tt><a href="output/Ext.Component.html#Ext.Component-clearCls" ext:member="clearCls" ext:cls="Ext.Component">clearCls</a></tt>
	 * .
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Also see
	 * <tt><a href="output/Ext.Component.html#Ext.Component-hideLabel" ext:member="hideLabel" ext:cls="Ext.Component">hideLabel</a></tt>
	 * and <a href="output/Ext.layout.FormLayout.html"
	 * ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>.<a
	 * href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-fieldTpl"
	 * ext:member="fieldTpl" ext:cls="Ext.layout.FormLayout">fieldTpl</a>.
	 * </p>
	 * 
	 * Example use:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.FormPanel({
	 *     height: 100,
	 *     renderTo: Ext.getBody(),
	 *     layoutConfig: {
	 *         labelSeparator: &lt;em&gt;'&tilde;'&lt;/em&gt;   &lt;i&gt;// layout config has lowest priority (defaults to &lt;em&gt;':'&lt;/em&gt;)&lt;/i&gt;
	 *     },
	 *     &lt;a href=&quot;output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-labelSeparator&quot; ext:member=&quot;labelSeparator&quot; ext:cls=&quot;Ext.layout.FormLayout&quot;&gt;labelSeparator&lt;/a&gt;: &lt;em&gt;'&gt;&gt;'&lt;/em&gt;,     &lt;i&gt;// config at container level&lt;/i&gt;
	 *     items: [{
	 *         xtype: &lt;em&gt;'textfield'&lt;/em&gt;,
	 *         fieldLabel: &lt;em&gt;'Field 1'&lt;/em&gt;,
	 *         labelSeparator: &lt;em&gt;'...'&lt;/em&gt; &lt;i&gt;// field/component level config supersedes others&lt;/i&gt;
	 *     },{
	 *         xtype: &lt;em&gt;'textfield'&lt;/em&gt;,
	 *         fieldLabel: &lt;em&gt;'Field 2'&lt;/em&gt; &lt;i&gt;// labelSeparator will be &lt;em&gt;'='&lt;/em&gt;&lt;/i&gt;
	 *     }]
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public String getLabelSeparator() {
		if (null != this.labelSeparator) {
			return this.labelSeparator;
		}
		ValueExpression _ve = getValueExpression("labelSeparator");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>labelSeparator</code> property.
	 * </p>
	 */
	public void setLabelSeparator(String labelSeparator) {
		this.labelSeparator = labelSeparator;
		this.handleConfig("labelSeparator", labelSeparator);
	}

	private String labelStyle;

	/**
	 * <p>
	 * A CSS style specification string to apply directly to this field's label.
	 * Defaults to the container's labelStyle value if set (e.g.,
	 * 
	 * <tt><a href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-labelStyle" ext:member="labelStyle" ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout.labelStyle</a></tt>
	 * , or '').
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: see the note for
	 * <code><a href="output/Ext.Component.html#Ext.Component-clearCls" ext:member="clearCls" ext:cls="Ext.Component">clearCls</a></code>
	 * .
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Also see
	 * <code><a href="output/Ext.Component.html#Ext.Component-hideLabel" ext:member="hideLabel" ext:cls="Ext.Component">hideLabel</a></code>
	 * and
	 * 
	 * 
	 * <code><a href="output/Ext.layout.FormLayout.html" ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>.<a href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-fieldTpl" ext:member="fieldTpl" ext:cls="Ext.layout.FormLayout">fieldTpl</a>.</code>
	 * </p>
	 * 
	 * Example use:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.FormPanel({
	 *     height: 100,
	 *     renderTo: Ext.getBody(),
	 *     items: [{
	 *         xtype: &lt;em&gt;'textfield'&lt;/em&gt;,
	 *         fieldLabel: &lt;em&gt;'Name'&lt;/em&gt;,
	 *         labelStyle: &lt;em&gt;'font-weight:bold;'&lt;/em&gt;
	 *     }]
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public String getLabelStyle() {
		if (null != this.labelStyle) {
			return this.labelStyle;
		}
		ValueExpression _ve = getValueExpression("labelStyle");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>labelStyle</code> property.
	 * </p>
	 */
	public void setLabelStyle(String labelStyle) {
		this.labelStyle = labelStyle;
		this.handleConfig("labelStyle", labelStyle);
	}

	private String overCls;

	/**
	 * An optional extra CSS class that will be added tothis component's Element
	 * when the mouse moves over the Element, and removed when the mouse moves
	 * out. (defaults to ''). This can be useful for adding customized 'active'
	 * or 'hover' styles to the component or any of its children using standard
	 * CSS rules.
	 */
	public String getOverCls() {
		if (null != this.overCls) {
			return this.overCls;
		}
		ValueExpression _ve = getValueExpression("overCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>overCls</code> property.
	 * </p>
	 */
	public void setOverCls(String overCls) {
		this.overCls = overCls;
		this.handleConfig("overCls", overCls);
	}

	private Object plugins;

	/**
	 * An object or array of objects that will providecustom functionality for
	 * this component. The only requirement for a valid plugin is that it
	 * contain an init method that accepts a reference of type Ext.Component.
	 * When a component is created, if any plugins are available, the component
	 * will call the init method on each plugin, passing a reference to itself.
	 * Each plugin can then call methods or respond to events on the component
	 * as needed to provide its functionality.
	 */
	@ClientConfig(JsonMode.Array)
	public Object getPlugins() {
		if (null != this.plugins) {
			return this.plugins;
		}
		ValueExpression _ve = getValueExpression("plugins");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>plugins</code> property.
	 * </p>
	 */
	public void setPlugins(Object plugins) {
		this.plugins = plugins;
		this.handleConfig("plugins", plugins);
	}

	private String ptype;

	/**
	 * The registered <tt>ptype</tt> to create. Thisconfig option is not used
	 * when passing a config object into a constructor. This config option is
	 * used only when lazy instantiation is being used, and a Plugin is being
	 * specified not as a fully instantiated Component, but as a <i>Component
	 * config object</i>. The <tt>ptype</tt> will be looked up at render time up
	 * to determine what type of Plugin to create.<br>
	 * <br>
	 * If you create your own Plugins, you may register them using <a
	 * href="output/Ext.ComponentMgr.html#Ext.ComponentMgr-registerPlugin"
	 * ext:member="registerPlugin"
	 * ext:cls="Ext.ComponentMgr">Ext.ComponentMgr.registerPlugin</a> in order
	 * to be able to take advantage of lazy instantiation and rendering.
	 */
	public String getPtype() {
		if (null != this.ptype) {
			return this.ptype;
		}
		ValueExpression _ve = getValueExpression("ptype");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>ptype</code> property.
	 * </p>
	 */
	public void setPtype(String ptype) {
		this.ptype = ptype;
		this.handleConfig("ptype", ptype);
	}

	private String ref;

	/**
	 * <p>
	 * A path specification, relative to the Component's <a
	 * href="output/Ext.Component.html#Ext.Component-ownerCt"
	 * ext:member="ownerCt" ext:cls="Ext.Component">ownerCt</a> specifying into
	 * which ancestor Container to place a named reference to this Component.
	 * </p>
	 * 
	 * <p>
	 * The ancestor axis can be traversed by using '/' characters in the path.
	 * For example, to put a reference to a Toolbar Button into <i>the Panel
	 * which owns the Toolbar</i>:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myGrid = &lt;b&gt;new&lt;/b&gt; Ext.grid.EditorGridPanel({
	 *     title: &lt;em&gt;'My EditorGridPanel'&lt;/em&gt;,
	 *     store: myStore,
	 *     colModel: myColModel,
	 *     tbar: [{
	 *         text: &lt;em&gt;'Save'&lt;/em&gt;,
	 *         handler: saveChanges,
	 *         disabled: true,
	 *         ref: &lt;em&gt;'../saveButton'&lt;/em&gt;
	 *     }],
	 *     listeners: {
	 *         afteredit: &lt;b&gt;function&lt;/b&gt;() {
	 * &lt;i&gt;//          The button reference is &lt;b&gt;in&lt;/b&gt; the GridPanel&lt;/i&gt;
	 *             myGrid.saveButton.enable();
	 *         }
	 *     }
	 * });&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * In the code above, if the ref had been <code><em>'saveButton'</em></code> the reference would
	 * have been placed into the Toolbar. Each '/' in the ref moves up one level
	 * from the Component's <a
	 * href="output/Ext.Component.html#Ext.Component-ownerCt"
	 * ext:member="ownerCt" ext:cls="Ext.Component">ownerCt</a>.
	 * </p>
	 */
	public String getRef() {
		if (null != this.ref) {
			return this.ref;
		}
		ValueExpression _ve = getValueExpression("ref");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>ref</code> property.
	 * </p>
	 */
	public void setRef(String ref) {
		this.ref = ref;
		this.handleConfig("ref", ref);
	}

	private Object renderTo;

	/**
	 * <p>
	 * Specify the id of the element, a DOM element or an existing Element that
	 * this component will be rendered into.
	 * </p>
	 * 
	 * <div>
	 * <ul>
	 * <li><b>Notes</b> :
	 * 
	 * <div style="margin-left: 2em"> <div class="sub-desc">Do <u>not</u> use
	 * this option if the Component is to be a child item of a <a
	 * href="output/Ext.Container.html" ext:cls="Ext.Container">Container</a>.
	 * It is the responsibility of the <a href="output/Ext.Container.html"
	 * ext:cls="Ext.Container">Container</a>'s <a
	 * href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
	 * ext:cls="Ext.Container">layout manager</a> to render and manage its child
	 * items.</div>
	 * 
	 * <div class="sub-desc">When using this config, a call to render() is not
	 * required.</div> </div></li>
	 * </ul>
	 * </div>
	 * 
	 * <p>
	 * See
	 * <tt><a href="output/Ext.Component.html#Ext.Component-render" ext:member="render" ext:cls="Ext.Component">render</a></tt>
	 * also.
	 * </p>
	 */
	public Object getRenderTo() {
		if (null != this.renderTo) {
			return this.renderTo;
		}
		ValueExpression _ve = getValueExpression("renderTo");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>renderTo</code> property.
	 * </p>
	 */
	public void setRenderTo(Object renderTo) {
		this.renderTo = renderTo;
		this.handleConfig("renderTo", renderTo);
	}

	private Object stateEvents;

	/**
	 * <p>
	 * An array of events that, when fired, should trigger this component to
	 * save its state (defaults to none). <code>stateEvents</code> may be any
	 * type of event supported by this component, including browser or custom
	 * events (e.g., <tt>['click',
'customerchange']</tt>).
	 * </p>
	 * 
	 * <p>
	 * See
	 * <code><a href="output/Ext.Component.html#Ext.Component-stateful" ext:member="stateful" ext:cls="Ext.Component">stateful</a></code>
	 * for an explanation of saving and restoring Component state.
	 * </p>
	 */
	@ClientConfig(JsonMode.Array)
	public Object getStateEvents() {
		if (null != this.stateEvents) {
			return this.stateEvents;
		}
		ValueExpression _ve = getValueExpression("stateEvents");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>stateEvents</code> property.
	 * </p>
	 */
	public void setStateEvents(Object stateEvents) {
		this.stateEvents = stateEvents;
		this.handleConfig("stateEvents", stateEvents);
	}

	private String stateId;

	/**
	 * The unique id for this component to use for statemanagement purposes
	 * (defaults to the component id if one was set, otherwise null if the
	 * component is using a generated id).
	 * 
	 * <p>
	 * See
	 * <code><a href="output/Ext.Component.html#Ext.Component-stateful" ext:member="stateful" ext:cls="Ext.Component">stateful</a></code>
	 * for an explanation of saving and restoring Component state.
	 * </p>
	 */
	public String getStateId() {
		if (null != this.stateId) {
			return this.stateId;
		}
		ValueExpression _ve = getValueExpression("stateId");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>stateId</code> property.
	 * </p>
	 */
	public void setStateId(String stateId) {
		this.stateId = stateId;
		this.handleConfig("stateId", stateId);
	}

	private Boolean stateful;

	/**
	 * <p>
	 * A flag which causes the Component to attempt to restore the state of
	 * internal properties from a saved state on startup. The component must
	 * have either a
	 * <code><a href="output/Ext.Component.html#Ext.Component-stateId" ext:member="stateId" ext:cls="Ext.Component">stateId</a></code>
	 * or
	 * <code><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></code>
	 * assigned for state to be managed. Auto-generated ids are not guaranteed
	 * to be stable across page loads and cannot be relied upon to save and
	 * restore the same state for a component.
	 * </p>
	 * 
	 * <p>
	 * For state saving to work, the state manager's provider must have been set
	 * to an implementation of <a href="output/Ext.state.Provider.html"
	 * ext:cls="Ext.state.Provider">Ext.state.Provider</a> which overrides the
	 * <a href="output/Ext.state.Provider.html#Ext.state.Provider-set"
	 * ext:member="set" ext:cls="Ext.state.Provider">set</a> and <a
	 * href="output/Ext.state.Provider.html#Ext.state.Provider-get"
	 * ext:member="get" ext:cls="Ext.state.Provider">get</a> methods to save and
	 * recall name/value pairs. A built-in implementation, <a
	 * href="output/Ext.state.CookieProvider.html"
	 * ext:cls="Ext.state.CookieProvider">Ext.state.CookieProvider</a> is
	 * available.
	 * </p>
	 * 
	 * <p>
	 * To set the state provider for the current page:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;Ext.state.Manager.setProvider(&lt;b&gt;new&lt;/b&gt; Ext.state.CookieProvider({
	 *     expires: &lt;b&gt;new&lt;/b&gt; Date(&lt;b&gt;new&lt;/b&gt; Date().getTime()+(1000*60*60*24*7)), &lt;i&gt;//7 days from now&lt;/i&gt;
	 * }));&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * A stateful Component attempts to save state when one of the events listed
	 * in the
	 * <code><a href="output/Ext.Component.html#Ext.Component-stateEvents" ext:member="stateEvents" ext:cls="Ext.Component">stateEvents</a></code>
	 * configuration fires.
	 * </p>
	 * 
	 * <p>
	 * To save state, a stateful Component first serializes its state by calling
	 * <b><code>getState</code></b>. By default, this function does nothing. The
	 * developer must provide an implementation which returns an object hash
	 * which represents the Component's restorable state.
	 * </p>
	 * 
	 * <p>
	 * The value yielded by getState is passed to <a
	 * href="output/Ext.state.Manager.html#Ext.state.Manager-set"
	 * ext:member="set" ext:cls="Ext.state.Manager">Ext.state.Manager.set</a>
	 * which uses the configured <a href="output/Ext.state.Provider.html"
	 * ext:cls="Ext.state.Provider">Ext.state.Provider</a> to save the object
	 * keyed by the Component's
	 * <code><a href="output/stateId.html" ext:cls="stateId">stateId</a></code>,
	 * or, if that is not specified, its
	 * <code><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></code>
	 * .
	 * </p>
	 * 
	 * <p>
	 * During construction, a stateful Component attempts to <i>restore</i> its
	 * state by calling <a
	 * href="output/Ext.state.Manager.html#Ext.state.Manager-get"
	 * ext:member="get" ext:cls="Ext.state.Manager">Ext.state.Manager.get</a>
	 * passing the
	 * <code><a href="output/Ext.Component.html#Ext.Component-stateId" ext:member="stateId" ext:cls="Ext.Component">stateId</a></code>
	 * , or, if that is not specified, the
	 * <code><a href="output/Ext.Component.html#Ext.Component-id" ext:member="id" ext:cls="Ext.Component">id</a></code>
	 * .
	 * </p>
	 * 
	 * <p>
	 * The resulting object is passed to <b><code>applyState</code></b>. The
	 * default implementation of <code>applyState</code> simply copies
	 * properties into the object, but a developer may override this to support
	 * more behaviour.
	 * </p>
	 * 
	 * <p>
	 * You can perform extra processing on state save and restore by attaching
	 * handlers to the <a
	 * href="output/Ext.Component.html#Ext.Component-beforestaterestore"
	 * ext:member="beforestaterestore"
	 * ext:cls="Ext.Component">beforestaterestore</a>, <a
	 * href="output/Ext.Component.html#Ext.Component-staterestore"
	 * ext:member="staterestore" ext:cls="Ext.Component">staterestore</a>, <a
	 * href="output/Ext.Component.html#Ext.Component-beforestatesave"
	 * ext:member="beforestatesave" ext:cls="Ext.Component">beforestatesave</a>
	 * and <a href="output/Ext.Component.html#Ext.Component-statesave"
	 * ext:member="statesave" ext:cls="Ext.Component">statesave</a> events.
	 * </p>
	 */
	public Boolean getStateful() {
		if (null != this.stateful) {
			return this.stateful;
		}
		ValueExpression _ve = getValueExpression("stateful");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>stateful</code> property.
	 * </p>
	 */
	public void setStateful(Boolean stateful) {
		this.stateful = stateful;
		this.handleConfig("stateful", stateful);
	}

	private String style;

	/**
	 * A custom style specification to be applied tothis component's Element.
	 * Should be a valid argument to <a
	 * href="output/Ext.Element.html#Ext.Element-applyStyles"
	 * ext:member="applyStyles"
	 * ext:cls="Ext.Element">Ext.Element.applyStyles</a>.
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.Panel({
	 *     title: &lt;em&gt;'Some Title'&lt;/em&gt;,
	 *     renderTo: Ext.getBody(),
	 *     width: 400, height: 300,
	 *     layout: &lt;em&gt;'form'&lt;/em&gt;,
	 *     items: [{
	 *         xtype: &lt;em&gt;'textarea'&lt;/em&gt;,
	 *         style: {
	 *             width: &lt;em&gt;'95%'&lt;/em&gt;,
	 *             marginBottom: &lt;em&gt;'10px'&lt;/em&gt;
	 *         }
	 *     },
	 *         &lt;b&gt;new&lt;/b&gt; Ext.Button({
	 *             text: &lt;em&gt;'Send'&lt;/em&gt;,
	 *             minWidth: &lt;em&gt;'100'&lt;/em&gt;,
	 *             style: {
	 *                 marginBottom: &lt;em&gt;'10px'&lt;/em&gt;
	 *             }
	 *         })
	 *     ]
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public String getStyle() {
		if (null != this.style) {
			return this.style;
		}
		ValueExpression _ve = getValueExpression("style");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>style</code> property.
	 * </p>
	 */
	public void setStyle(String style) {
		this.style = style;
		this.handleConfig("style", style);
	}

	private String xtype;

	/**
	 * The registered <tt>xtype</tt> to create. Thisconfig option is not used
	 * when passing a config object into a constructor. This config option is
	 * used only when lazy instantiation is being used, and a child item of a
	 * Container is being specified not as a fully instantiated Component, but
	 * as a <i>Component config object</i>. The <tt>xtype</tt> will be looked up
	 * at render time up to determine what type of child Component to create.<br>
	 * <br>
	 * The predefined xtypes are listed <a href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">here</a>.<br>
	 * <br>
	 * If you subclass Components to create your own Components, you may
	 * register them using <a
	 * href="output/Ext.ComponentMgr.html#Ext.ComponentMgr-registerType"
	 * ext:member="registerType"
	 * ext:cls="Ext.ComponentMgr">Ext.ComponentMgr.registerType</a> in order to
	 * be able to take advantage of lazy instantiation and rendering.
	 */
	public String getXtype() {
		if (null != this.xtype) {
			return this.xtype;
		}
		ValueExpression _ve = getValueExpression("xtype");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>xtype</code> property.
	 * </p>
	 */
	public void setXtype(String xtype) {
		this.xtype = xtype;
		this.handleConfig("xtype", xtype);
	}
	
	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[31];
		}
		_values[0] = super.saveState(_context);
		_values[1] = allowDomMove;
		_values[2] = anchor;
		_values[3] = applyTo;
		_values[4] = autoEl;
		_values[5] = autoShow;
		_values[6] = clearCls;
		_values[7] = cls;
		_values[8] = ctCls;
		_values[9] = disabled;
		_values[10] = disabledClass;
		_values[11] = fieldLabel;
		_values[12] = hidden;
		_values[13] = hideLabel;
		_values[14] = hideMode;
		_values[15] = hideParent;
		_values[16] = id;
		_values[17] = itemCls;
		_values[18] = itemId;
		_values[19] = labelSeparator;
		_values[20] = labelStyle;
		_values[21] = overCls;
		_values[22] = plugins;
		_values[23] = ptype;
		_values[24] = ref;
		_values[25] = renderTo;
		_values[26] = stateEvents;
		_values[27] = stateId;
		_values[28] = stateful;
		_values[29] = style;
		_values[30] = xtype;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.allowDomMove = (Boolean) _values[1];
		this.handleConfig("allowDomMove", this.allowDomMove);
		this.anchor = (String) _values[2];
		this.handleConfig("anchor", this.anchor);
		this.applyTo = (Object) _values[3];
		this.handleConfig("applyTo", this.applyTo);
		this.autoEl = (Object) _values[4];
		this.handleConfig("autoEl", this.autoEl);
		this.autoShow = (Boolean) _values[5];
		this.handleConfig("autoShow", this.autoShow);
		this.clearCls = (String) _values[6];
		this.handleConfig("clearCls", this.clearCls);
		this.cls = (String) _values[7];
		this.handleConfig("cls", this.cls);
		this.ctCls = (String) _values[8];
		this.handleConfig("ctCls", this.ctCls);
		this.disabled = (Boolean) _values[9];
		this.handleConfig("disabled", this.disabled);
		this.disabledClass = (String) _values[10];
		this.handleConfig("disabledClass", this.disabledClass);
		this.fieldLabel = (String) _values[11];
		this.handleConfig("fieldLabel", this.fieldLabel);
		this.hidden = (Boolean) _values[12];
		this.handleConfig("hidden", this.hidden);
		this.hideLabel = (Boolean) _values[13];
		this.handleConfig("hideLabel", this.hideLabel);
		this.hideMode = (String) _values[14];
		this.handleConfig("hideMode", this.hideMode);
		this.hideParent = (Boolean) _values[15];
		this.handleConfig("hideParent", this.hideParent);
		this.id = (String) _values[16];
		this.handleConfig("id", this.id);
		this.itemCls = (String) _values[17];
		this.handleConfig("itemCls", this.itemCls);
		this.itemId = (String) _values[18];
		this.handleConfig("itemId", this.itemId);
		this.labelSeparator = (String) _values[19];
		this.handleConfig("labelSeparator", this.labelSeparator);
		this.labelStyle = (String) _values[20];
		this.handleConfig("labelStyle", this.labelStyle);
		this.overCls = (String) _values[21];
		this.handleConfig("overCls", this.overCls);
		this.plugins = (Object) _values[22];
		this.handleConfig("plugins", this.plugins);
		this.ptype = (String) _values[23];
		this.handleConfig("ptype", this.ptype);
		this.ref = (String) _values[24];
		this.handleConfig("ref", this.ref);
		this.renderTo = (Object) _values[25];
		this.handleConfig("renderTo", this.renderTo);
		this.stateEvents = (Object) _values[26];
		this.handleConfig("stateEvents", this.stateEvents);
		this.stateId = (String) _values[27];
		this.handleConfig("stateId", this.stateId);
		this.stateful = (Boolean) _values[28];
		this.handleConfig("stateful", this.stateful);
		this.style = (String) _values[29];
		this.handleConfig("style", this.style);
		this.xtype = (String) _values[30];
		this.handleConfig("xtype", this.xtype);

	}
}