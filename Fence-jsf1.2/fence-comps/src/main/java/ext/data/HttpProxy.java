package ext.data;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.InstanceOf;
import ext.annotation.ParseConfigMode;
import ext.annotation.PersistenceMode;
import ext.annotation.ReferenceMode;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * An implementation of <a href="output/Ext.data.DataProxy.html"
 * ext:cls="Ext.data.DataProxy">Ext.data.DataProxy</a> that processes data
 * requests within the same domain of the originating page.
 * </p>
 * 
 * <p>
 * <b>Note</b>: this class cannot be used to retrieve data from a domain other
 * than the domain from which the running page was served. For cross-domain
 * requests, use a <a href="output/Ext.data.ScriptTagProxy.html"
 * ext:cls="Ext.data.ScriptTagProxy">ScriptTagProxy</a>.
 * </p>
 * 
 * <p>
 * Be aware that to enable the browser to parse an XML document, the server must
 * set the Content-Type header in the HTTP response to "<tt>text/xml</tt>".
 * </p>
 */
@InstanceOf("Ext.data.HttpProxy")
@ParseConfigMode(ui = false, name = "proxy", pmode = PersistenceMode.ParentProperty, rmode = ReferenceMode.Var)
public class HttpProxy extends DataProxy {
	public static final String COMPONENT_TYPE = "Ext.data.HttpProxy";
	public static final String COMPONENT_FAMILY = "Ext.data.HttpProxy";

	/**
	 * <p>
	 * Create a new {@link HttpProxy} instance with default property values.
	 * </p>
	 */
	public HttpProxy() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean restful;

	/**
	 * <p>
	 * If set to <tt>true</tt>, a <a
	 * href="output/Ext.data.Record.html#Ext.data.Record-phantom"
	 * ext:member="phantom" ext:cls="Ext.data.Record">non-phantom</a> record's
	 * <a href="output/Ext.data.Record.html#Ext.data.Record-id" ext:member="id"
	 * ext:cls="Ext.data.Record">id</a> will be appended to the url (defaults to
	 * <tt>false</tt>).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * The url is built based upon the action being executed
	 * <tt>[load|create|save|destroy]</tt> using the commensurate
	 * <tt><a href="output/Ext.data.HttpProxy.html#Ext.data.HttpProxy-api" ext:member="api" ext:cls="Ext.data.HttpProxy">api</a></tt>
	 * property, or if undefined default to the configured <a
	 * href="output/Ext.data.Store.html"
	 * ext:cls="Ext.data.Store">Ext.data.Store</a>.<a
	 * href="output/Ext.data.Store.html#Ext.data.Store-url" ext:member="url"
	 * ext:cls="Ext.data.Store">url</a>.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Some MVC (e.g., Ruby on Rails, Merb and Django) support this style of
	 * segment based urls where the segments in the URL follow the
	 * Model-View-Controller approach.
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;someSite.com/controller/action/id&lt;/code&gt;
	 * </pre>
	 * 
	 * Where the segments in the url are typically:
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li>The first segment : represents the controller class that should be
	 * invoked.</li>
	 * 
	 * <li>The second segment : represents the class function, or method, that
	 * should be called.</li>
	 * 
	 * <li>The third segment : represents the ID (a variable typically passed to
	 * the method).</li>
	 * </ul>
	 * </div>
	 * 
	 * <br>
	 * <br>
	 * 
	 * 
	 * <p>
	 * For example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;api: {
	 *     load :    &lt;em&gt;'/controller/load'&lt;/em&gt;,
	 *     create :  &lt;em&gt;'/controller/&lt;b&gt;new&lt;/b&gt;'&lt;/em&gt;,  &lt;i&gt;// Server MUST &lt;b&gt;return&lt;/b&gt; idProperty of &lt;b&gt;new&lt;/b&gt; record
	 * &lt;/i&gt;
	 *     save :    &lt;em&gt;'/controller/update'&lt;/em&gt;,
	 *     destroy : &lt;em&gt;'/controller/destroy_action'&lt;/em&gt;
	 * }
	 * 
	 * &lt;i&gt;// Alternatively, one can use the object-form to specify each API-action
	 * &lt;/i&gt;
	 * api: {
	 *     load: {url: &lt;em&gt;'read.php'&lt;/em&gt;, method: &lt;em&gt;'GET'&lt;/em&gt;},
	 *     create: &lt;em&gt;'create.php'&lt;/em&gt;,
	 *     destroy: &lt;em&gt;'destroy.php'&lt;/em&gt;,
	 *     save: &lt;em&gt;'update.php'&lt;/em&gt;
	 * }&lt;/code&gt;
	 * </pre>
	 */
	public Boolean getRestful() {
		if (null != this.restful) {
			return this.restful;
		}
		ValueExpression _ve = getValueExpression("restful");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>restful</code> property.
	 * </p>
	 */
	public void setRestful(Boolean restful) {
		this.restful = restful;
		this.handleConfig("restful", restful);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[2];
		}
		_values[0] = super.saveState(_context);
		_values[1] = restful;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.restful = (Boolean) _values[1];
		this.handleConfig("restful", this.restful);

	}
}