package ext.form;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.data.DataReader;
import ext.util.Observable;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * Encapsulates the DOM &lt;form&gt; element at the heart of the <a
 * href="output/Ext.form.FormPanel.html"
 * ext:cls="Ext.form.FormPanel">FormPanel</a> class, and provides input field
 * management, validation, submission, and form loading services.
 * </p>
 * 
 * <p>
 * By default, Ext Forms are submitted through Ajax, using an instance of <a
 * href="output/Ext.form.Action.Submit.html"
 * ext:cls="Ext.form.Action.Submit">Ext.form.Action.Submit</a>. To enable normal
 * browser submission of an Ext Form, use the <a
 * href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-standardSubmit"
 * ext:member="standardSubmit" ext:cls="Ext.form.BasicForm">standardSubmit</a>
 * config option.
 * </p>
 * 
 * <p>
 * <b><u>File Uploads</u></b>
 * </p>
 * 
 * <p>
 * <a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-fileUpload"
 * ext:member="fileUpload" ext:cls="Ext.form.BasicForm">File uploads</a> are not
 * performed using Ajax submission, that is they are <b>not</b> performed using
 * XMLHttpRequests. Instead the form is submitted in the standard manner with
 * the DOM <tt>&lt;form&gt;</tt> element temporarily modified to have its <a
 * href="http://www.w3.org/TR/REC-html40/present/frames.html#adef-target">
 * target</a> set to refer to a dynamically generated, hidden
 * <tt>&lt;iframe&gt;</tt> which is inserted into the document but removed after
 * the return data has been gathered.
 * </p>
 * 
 * <p>
 * The server response is parsed by the browser to create the document for the
 * IFRAME. If the server is using JSON to send the return object, then the <a
 * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
 * Content-Type</a> header must be set to "text/html" in order to tell the
 * browser to insert the text unchanged into the document body.
 * </p>
 * 
 * <p>
 * Characters which are significant to an HTML parser must be sent as HTML
 * entities, so encode "&lt;" as "&amp;lt;", "&amp;" as "&amp;amp;" etc.
 * </p>
 * 
 * <p>
 * The response text is retrieved from the document, and a fake XMLHttpRequest
 * object is created containing a <tt>responseText</tt> property in order to
 * conform to the requirements of event handlers and callbacks.
 * </p>
 * 
 * <p>
 * Be aware that file upload packets are sent with the content type <a
 * href="http://www.faqs.org/rfcs/rfc2388.html">multipart/form</a> and some
 * server technologies (notably JEE) may require some custom processing in order
 * to retrieve parameter names and parameter values from the packet content.
 * </p>
 */
@InstanceOf("Ext.form.BasicForm")
public class BasicForm extends Observable {
	public static final String COMPONENT_TYPE = "Ext.form.BasicForm";
	public static final String COMPONENT_FAMILY = "Ext.form.BasicForm";

	/**
	 * <p>
	 * Create a new {@link BasicForm} instance with default property values.
	 * </p>
	 */
	public BasicForm() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Object api;

	/**
	 * If specified load and submit actions will behandled with <a
	 * href="output/Ext.form.Action.DirectLoad.html"
	 * ext:cls="Ext.form.Action.DirectLoad">Ext.form.Action.DirectLoad</a> and
	 * <a href="output/Ext.form.Action.DirectSubmit.html"
	 * ext:cls="Ext.form.Action.DirectSubmit">Ext.form.Action.DirectSubmit</a>.
	 * Methods which have been imported by Ext.Direct can be specified here to
	 * load and submit forms. Such as the following:
	 * 
	 * <pre>
	 * &lt;code&gt;api: {
	 *     load: App.ss.MyProfile.load,
	 *     submit: App.ss.MyProfile.submit
	 * }&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * Load actions can use
	 * 
	 * <code><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-paramOrder" ext:member="paramOrder" ext:cls="Ext.form.BasicForm">paramOrder</a></code>
	 * or
	 * 
	 * <code><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-paramsAsHash" ext:member="paramsAsHash" ext:cls="Ext.form.BasicForm">paramsAsHash</a></code>
	 * to customize how the load method is invoked. Submit actions will always
	 * use a standard form submit. The formHandler configuration must be set on
	 * the associated server-side method which has been imported by Ext.Direct
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getApi() {
		if (null != this.api) {
			return this.api;
		}
		ValueExpression _ve = getValueExpression("api");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>api</code> property.
	 * </p>
	 */
	public void setApi(Object api) {
		this.api = api;
		this.handleConfig("api", api);
	}

	private Object baseParams;

	/**
	 * <p>
	 * Parameters to pass with all requests. e.g. baseParams: {id: '123', foo:
	 * 'bar'}.
	 * </p>
	 * 
	 * <p>
	 * Parameters are encoded as standard HTTP parameters using <a
	 * href="output/Ext.html#Ext-urlEncode" ext:member="urlEncode"
	 * ext:cls="Ext">Ext.urlEncode</a>.
	 * </p>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getBaseParams() {
		if (null != this.baseParams) {
			return this.baseParams;
		}
		ValueExpression _ve = getValueExpression("baseParams");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>baseParams</code> property.
	 * </p>
	 */
	public void setBaseParams(Object baseParams) {
		this.baseParams = baseParams;
		this.handleConfig("baseParams", baseParams);
	}

	private DataReader errorReader;

	/**
	 * <p>
	 * An Ext.data.DataReader (e.g. <a href="output/Ext.data.XmlReader.html"
	 * ext:cls="Ext.data.XmlReader">Ext.data.XmlReader</a>) to be used to read
	 * field error messages returned from 'submit' actions. This is optional as
	 * there is built-in support for processing JSON.
	 * </p>
	 * 
	 * <p>
	 * The Records which provide messages for the invalid Fields must use the
	 * Field name (or id) as the Record ID, and must contain a field called
	 * 'msg' which contains the error message.
	 * </p>
	 * 
	 * <p>
	 * The errorReader does not have to be a full-blown implementation of a
	 * DataReader. It simply needs to implement a <tt>read(xhr)</tt> function
	 * which returns an Array of Records in an object with the following
	 * structure:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{
	 *     records: recordArray
	 * }&lt;/code&gt;
	 * </pre>
	 */
	public DataReader getErrorReader() {
		if (null != this.errorReader) {
			return this.errorReader;
		}
		ValueExpression _ve = getValueExpression("errorReader");
		if (_ve != null) {
			return (DataReader) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>errorReader</code> property.
	 * </p>
	 */
	public void setErrorReader(DataReader errorReader) {
		this.errorReader = errorReader;
		this.handleConfig("errorReader", errorReader);
	}

	private Boolean fileUpload;

	/**
	 * Set to true if this form is a file upload.
	 * <p>
	 * File uploads are not performed using normal 'Ajax' techniques, that is
	 * they are <b>not</b> performed using XMLHttpRequests. Instead the form is
	 * submitted in the standard manner with the DOM <tt>&lt;form&gt;</tt>
	 * element temporarily modified to have its <a
	 * href="http://www.w3.org/TR/REC-html40/present/frames.html#adef-target">
	 * target</a> set to refer to a dynamically generated, hidden
	 * <tt>&lt;iframe&gt;</tt> which is inserted into the document but removed
	 * after the return data has been gathered.
	 * </p>
	 * 
	 * <p>
	 * The server response is parsed by the browser to create the document for
	 * the IFRAME. If the server is using JSON to send the return object, then
	 * the <a
	 * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
	 * Content-Type</a> header must be set to "text/html" in order to tell the
	 * browser to insert the text unchanged into the document body.
	 * </p>
	 * 
	 * <p>
	 * Characters which are significant to an HTML parser must be sent as HTML
	 * entities, so encode "&lt;" as "&amp;lt;", "&amp;" as "&amp;amp;" etc.
	 * </p>
	 * 
	 * <p>
	 * The response text is retrieved from the document, and a fake
	 * XMLHttpRequest object is created containing a <tt>responseText</tt>
	 * property in order to conform to the requirements of event handlers and
	 * callbacks.
	 * </p>
	 * 
	 * <p>
	 * Be aware that file upload packets are sent with the content type <a
	 * href="http://www.faqs.org/rfcs/rfc2388.html">multipart/form</a> and some
	 * server technologies (notably JEE) may require some custom processing in
	 * order to retrieve parameter names and parameter values from the packet
	 * content.
	 * </p>
	 */
	public Boolean getFileUpload() {
		if (null != this.fileUpload) {
			return this.fileUpload;
		}
		ValueExpression _ve = getValueExpression("fileUpload");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>fileUpload</code> property.
	 * </p>
	 */
	public void setFileUpload(Boolean fileUpload) {
		this.fileUpload = fileUpload;
		this.handleConfig("fileUpload", fileUpload);
	}

	private String method;

	/**
	 * The request method to use (GET or POST) for formactions if one isn't
	 * supplied in the action options.
	 */
	public String getMethod() {
		if (null != this.method) {
			return this.method;
		}
		ValueExpression _ve = getValueExpression("method");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>method</code> property.
	 * </p>
	 */
	public void setMethod(String method) {
		this.method = method;
		this.handleConfig("method", method);
	}

	private Object paramOrder;

	/**
	 * <p>
	 * A list of params to be executed server side. Defaults to
	 * <tt>undefined</tt>. Only used for the
	 * <code><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-api" ext:member="api" ext:cls="Ext.form.BasicForm">api</a></code>
	 * <code>load</code> configuration.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Specify the params in the order in which they must be executed on the
	 * server-side as either (1) an Array of String values, or (2) a String of
	 * params delimited by either whitespace, comma, or pipe. For example, any
	 * of the following would be acceptable:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;paramOrder: [&lt;em&gt;'param1'&lt;/em&gt;,&lt;em&gt;'param2'&lt;/em&gt;,&lt;em&gt;'param3'&lt;/em&gt;]
	 * paramOrder: &lt;em&gt;'param1 param2 param3'&lt;/em&gt;
	 * paramOrder: &lt;em&gt;'param1,param2,param3'&lt;/em&gt;
	 * paramOrder: &lt;em&gt;'param1|param2|param'&lt;/em&gt;&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Array)
	public Object getParamOrder() {
		if (null != this.paramOrder) {
			return this.paramOrder;
		}
		ValueExpression _ve = getValueExpression("paramOrder");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>paramOrder</code> property.
	 * </p>
	 */
	public void setParamOrder(Object paramOrder) {
		this.paramOrder = paramOrder;
		this.handleConfig("paramOrder", paramOrder);
	}

	private Boolean paramsAsHash;

	/**
	 * Only used for the
	 * <code><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-api" ext:member="api" ext:cls="Ext.form.BasicForm">api</a></code>
	 * <code>load</code> configuration. Send parameters as a collection of named
	 * arguments (defaults to <tt>false</tt>). Providing a
	 * <tt><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-paramOrder" ext:member="paramOrder" ext:cls="Ext.form.BasicForm">paramOrder</a></tt>
	 * nullifies this configuration.
	 */
	public Boolean getParamsAsHash() {
		if (null != this.paramsAsHash) {
			return this.paramsAsHash;
		}
		ValueExpression _ve = getValueExpression("paramsAsHash");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>paramsAsHash</code> property.
	 * </p>
	 */
	public void setParamsAsHash(Boolean paramsAsHash) {
		this.paramsAsHash = paramsAsHash;
		this.handleConfig("paramsAsHash", paramsAsHash);
	}

	private DataReader reader;

	/**
	 * An Ext.data.DataReader (e.g. <a href="output/Ext.data.XmlReader.html"
	 * ext:cls="Ext.data.XmlReader">Ext.data.XmlReader</a>) to be used toread
	 * data when executing 'load' actions. This is optional as there is built-in
	 * support for processing JSON. For additional information on using an
	 * XMLReader see the example provided in examples/form/xml-form.html.
	 */
	public DataReader getReader() {
		if (null != this.reader) {
			return this.reader;
		}
		ValueExpression _ve = getValueExpression("reader");
		if (_ve != null) {
			return (DataReader) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>reader</code> property.
	 * </p>
	 */
	public void setReader(DataReader reader) {
		this.reader = reader;
		this.handleConfig("reader", reader);
	}

	private Boolean standardSubmit;

	/**
	 * If set to true, standard HTML form submits areused instead of XHR (Ajax)
	 * style form submissions. (defaults to false)<br>
	 * <p>
	 * <b>Note:</b> When using standardSubmit, the options to <a
	 * href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-submit"
	 * ext:member="submit" ext:cls="Ext.form.BasicForm">submit</a> are ignored
	 * because Ext's Ajax infrastracture is bypassed. To pass extra parameters
	 * (baseParams and params), you will need to create hidden fields within the
	 * form.
	 * </p>
	 * 
	 * <p>
	 * The url config option is also bypassed, so set the action as well:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;PANEL.getForm().getEl().dom.action = &lt;em&gt;'URL'&lt;/em&gt;&lt;/code&gt;
	 * </pre>
	 * 
	 * An example encapsulating the above:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.FormPanel({
	 *     standardSubmit: true,
	 *     baseParams: {
	 *         foo: &lt;em&gt;'bar'&lt;/em&gt;
	 *     },
	 *     url: &lt;em&gt;'myProcess.php'&lt;/em&gt;,
	 *     items: [{
	 *         xtype: &lt;em&gt;'textfield'&lt;/em&gt;,
	 *         name: &lt;em&gt;'userName'&lt;/em&gt;
	 *     }],
	 *     buttons: [{
	 *         text: &lt;em&gt;'Save'&lt;/em&gt;,
	 *         handler: &lt;b&gt;function&lt;/b&gt;(){
	 *             &lt;b&gt;var&lt;/b&gt; O = this.ownerCt;
	 *             &lt;b&gt;if&lt;/b&gt; (O.getForm().isValid()) {
	 *                 &lt;b&gt;if&lt;/b&gt; (O.url)
	 *                     O.getForm().getEl().dom.action = O.url;
	 *                 &lt;b&gt;if&lt;/b&gt; (O.baseParams) {
	 *                     &lt;b&gt;for&lt;/b&gt; (i &lt;b&gt;in&lt;/b&gt; O.baseParams) {
	 *                         O.add({
	 *                             xtype: &lt;em&gt;'hidden'&lt;/em&gt;,
	 *                             name: i,
	 *                             value: O.baseParams[i]
	 *                         })
	 *                     }
	 *                     O.doLayout();
	 *                 }
	 *                 O.getForm().submit();
	 *             }
	 *         }
	 *     }]
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public Boolean getStandardSubmit() {
		if (null != this.standardSubmit) {
			return this.standardSubmit;
		}
		ValueExpression _ve = getValueExpression("standardSubmit");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>standardSubmit</code> property.
	 * </p>
	 */
	public void setStandardSubmit(Boolean standardSubmit) {
		this.standardSubmit = standardSubmit;
		this.handleConfig("standardSubmit", standardSubmit);
	}

	private Integer timeout;

	/**
	 * Timeout for form actions in seconds (default is30 seconds).
	 */
	public Integer getTimeout() {
		if (null != this.timeout) {
			return this.timeout;
		}
		ValueExpression _ve = getValueExpression("timeout");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>timeout</code> property.
	 * </p>
	 */
	public void setTimeout(Integer timeout) {
		this.timeout = timeout;
		this.handleConfig("timeout", timeout);
	}

	private Boolean trackResetOnLoad;

	/**
	 * If set to <tt>true</tt>, <a
	 * href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-reset"
	 * ext:member="reset" ext:cls="Ext.form.BasicForm">reset</a>() resetsto the
	 * last loaded or <a
	 * href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-setValues"
	 * ext:member="setValues" ext:cls="Ext.form.BasicForm">setValues</a>() data
	 * instead of when the form was first created. Defaults to <tt>false</tt>.
	 */
	public Boolean getTrackResetOnLoad() {
		if (null != this.trackResetOnLoad) {
			return this.trackResetOnLoad;
		}
		ValueExpression _ve = getValueExpression("trackResetOnLoad");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>trackResetOnLoad</code> property.
	 * </p>
	 */
	public void setTrackResetOnLoad(Boolean trackResetOnLoad) {
		this.trackResetOnLoad = trackResetOnLoad;
		this.handleConfig("trackResetOnLoad", trackResetOnLoad);
	}

	private String url;

	/**
	 * The URL to use for form actions if one isn'tsupplied in the
	 * 
	 * <code><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-doAction" ext:member="doAction" ext:cls="Ext.form.BasicForm">doAction</a>
options</code>.
	 */
	public String getUrl() {
		if (null != this.url) {
			return this.url;
		}
		ValueExpression _ve = getValueExpression("url");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>url</code> property.
	 * </p>
	 */
	public void setUrl(String url) {
		this.url = url;
		this.handleConfig("url", url);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[13];
		}
		_values[0] = super.saveState(_context);
		_values[1] = api;
		_values[2] = baseParams;
		_values[3] = errorReader;
		_values[4] = fileUpload;
		_values[5] = method;
		_values[6] = paramOrder;
		_values[7] = paramsAsHash;
		_values[8] = reader;
		_values[9] = standardSubmit;
		_values[10] = timeout;
		_values[11] = trackResetOnLoad;
		_values[12] = url;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.api = (Object) _values[1];
		this.handleConfig("api", this.api);
		this.baseParams = (Object) _values[2];
		this.handleConfig("baseParams", this.baseParams);
		this.errorReader = (DataReader) _values[3];
		this.handleConfig("errorReader", this.errorReader);
		this.fileUpload = (Boolean) _values[4];
		this.handleConfig("fileUpload", this.fileUpload);
		this.method = (String) _values[5];
		this.handleConfig("method", this.method);
		this.paramOrder = (Object) _values[6];
		this.handleConfig("paramOrder", this.paramOrder);
		this.paramsAsHash = (Boolean) _values[7];
		this.handleConfig("paramsAsHash", this.paramsAsHash);
		this.reader = (DataReader) _values[8];
		this.handleConfig("reader", this.reader);
		this.standardSubmit = (Boolean) _values[9];
		this.handleConfig("standardSubmit", this.standardSubmit);
		this.timeout = (Integer) _values[10];
		this.handleConfig("timeout", this.timeout);
		this.trackResetOnLoad = (Boolean) _values[11];
		this.handleConfig("trackResetOnLoad", this.trackResetOnLoad);
		this.url = (String) _values[12];
		this.handleConfig("url", this.url);

	}
}