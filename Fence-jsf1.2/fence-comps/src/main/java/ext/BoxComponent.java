package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.InstanceOf;
import ext.annotation.XType;
import ext.base.AjaxZone;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * Base class for any <a href="output/Ext.Component.html"
 * ext:cls="Ext.Component">Component</a> that is to be sized as a box, using
 * width and height.
 * </p>
 * 
 * <p>
 * BoxComponent provides automatic box model adjustments for sizing and
 * positioning and will work correctly within the Component rendering model.
 * </p>
 * 
 * <p>
 * A BoxComponent may be created as a custom Component which encapsulates any
 * HTML element, either a pre-existing element, or one that is created to your
 * specifications at render time. Usually, to participate in layouts, a
 * Component will need to be a <b>Box</b>Component in order to have its width
 * and height managed.
 * </p>
 * 
 * <p>
 * To use a pre-existing element as a BoxComponent, configure it so that you
 * preset the <b>el</b> property to the element to reference:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; pageHeader = &lt;b&gt;new&lt;/b&gt; Ext.BoxComponent({
 *     el: &lt;em&gt;'my-header-div'&lt;/em&gt;
 * });&lt;/code&gt;
 * </pre>
 * 
 * This may then be <a href="output/Ext.Container.html#Ext.Container-add"
 * ext:member="add" ext:cls="Ext.Container">added</a> to a <a
 * href="output/Ext.Container.html" ext:cls="Ext.Container">Container</a> as a
 * child item.<br>
 * <br>
 * 
 * 
 * <p>
 * To create a BoxComponent based around a HTML element to be created at render
 * time, use the <a href="output/Ext.Component.html#Ext.Component-autoEl"
 * ext:member="autoEl" ext:cls="Ext.Component">autoEl</a> config option which
 * takes the form of a <a href="output/Ext.DomHelper.html"
 * ext:cls="Ext.DomHelper">DomHelper</a> specification:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myImage = &lt;b&gt;new&lt;/b&gt; Ext.BoxComponent({
 *     autoEl: {
 *         tag: &lt;em&gt;'img'&lt;/em&gt;,
 *         src: &lt;em&gt;'/images/my-image.jpg'&lt;/em&gt;
 *     }
 * });&lt;/code&gt;
 * </pre>
 * 
 * <br>
 * <br>
 */
@XType("box")
@InstanceOf("Ext.BoxComponent")
public class BoxComponent extends Component implements AjaxZone{
	public static final String COMPONENT_TYPE = "Ext.BoxComponent";
	public static final String COMPONENT_FAMILY = "Ext.BoxComponent";

	/**
	 * <p>
	 * Create a new {@link BoxComponent} instance with default property values.
	 * </p>
	 */
	public BoxComponent() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean autoHeight;

	/**
	 * <p>
	 * True to use height:'auto', false to use fixed height (or allow it to be
	 * managed by its parent Container's <a
	 * href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
	 * ext:cls="Ext.Container">layout manager</a>. Defaults to false.
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: Although many components inherit this config option, not all
	 * will function as expected with a height of 'auto'. Setting
	 * autoHeight:true means that the browser will manage height based on the
	 * element's contents, and that Ext will not manage it at all.
	 * </p>
	 * 
	 * <p>
	 * If the <i>browser</i> is managing the height, be aware that resizes
	 * performed by the browser in response to changes within the structure of
	 * the Component cannot be detected. Therefore changes to the height might
	 * result in elements needing to be synchronized with the new height.
	 * Example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; w = &lt;b&gt;new&lt;/b&gt; Ext.Window({
	 *     title: &lt;em&gt;'Window'&lt;/em&gt;,
	 *     width: 600,
	 *     autoHeight: true,
	 *     items: {
	 *         title: &lt;em&gt;'Collapse Me'&lt;/em&gt;,
	 *         height: 400,
	 *         collapsible: true,
	 *         border: false,
	 *         listeners: {
	 *             beforecollapse: &lt;b&gt;function&lt;/b&gt;() {
	 *                 w.el.shadow.hide();
	 *             },
	 *             beforeexpand: &lt;b&gt;function&lt;/b&gt;() {
	 *                 w.el.shadow.hide();
	 *             },
	 *             collapse: &lt;b&gt;function&lt;/b&gt;() {
	 *                 w.syncShadow();
	 *             },
	 *             expand: &lt;b&gt;function&lt;/b&gt;() {
	 *                 w.syncShadow();
	 *             }
	 *         }
	 *     }
	 * }).show();&lt;/code&gt;
	 * </pre>
	 */
	public Boolean getAutoHeight() {
		if (null != this.autoHeight) {
			return this.autoHeight;
		}
		ValueExpression _ve = getValueExpression("autoHeight");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoHeight</code> property.
	 * </p>
	 */
	public void setAutoHeight(Boolean autoHeight) {
		this.autoHeight = autoHeight;
		this.handleConfig("autoHeight", autoHeight);
	}

	private Boolean autoWidth;

	/**
	 * <p>
	 * True to use width:'auto', false to use fixed width (or allow it to be
	 * managed by its parent Container's <a
	 * href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
	 * ext:cls="Ext.Container">layout manager</a>. Defaults to false.
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: Although many components inherit this config option, not all
	 * will function as expected with a width of 'auto'. Setting autoWidth:true
	 * means that the browser will manage width based on the element's contents,
	 * and that Ext will not manage it at all.
	 * </p>
	 * 
	 * <p>
	 * If the <i>browser</i> is managing the width, be aware that resizes
	 * performed by the browser in response to changes within the structure of
	 * the Component cannot be detected. Therefore changes to the width might
	 * result in elements needing to be synchronized with the new width. For
	 * example, where the target element is:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;div id=&lt;em&gt;'grid-container'&lt;/em&gt; style=&lt;em&gt;'margin-left:25%;width:50%'&lt;/em&gt;&gt;&lt;/div&gt;&lt;/code&gt;
	 * </pre>
	 * 
	 * A Panel rendered into that target element must listen for browser window
	 * resize in order to relay its child items when the browser changes its
	 * width:
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; myPanel = &lt;b&gt;new&lt;/b&gt; Ext.Panel({
	 *     renderTo: &lt;em&gt;'grid-container'&lt;/em&gt;,
	 *     monitorResize: true, &lt;i&gt;// relay on browser resize&lt;/i&gt;
	 *     title: &lt;em&gt;'Panel'&lt;/em&gt;,
	 *     height: 400,
	 *     autoWidth: true,
	 *     layout: &lt;em&gt;'hbox'&lt;/em&gt;,
	 *     layoutConfig: {
	 *         align: &lt;em&gt;'stretch'&lt;/em&gt;
	 *     },
	 *     defaults: {
	 *         flex: 1
	 *     },
	 *     items: [{
	 *         title: &lt;em&gt;'Box 1'&lt;/em&gt;,
	 *     }, {
	 *         title: &lt;em&gt;'Box 2'&lt;/em&gt;
	 *     }, {
	 *         title: &lt;em&gt;'Box 3'&lt;/em&gt;
	 *     }],
	 * });&lt;/code&gt;
	 * </pre>
	 */
	public Boolean getAutoWidth() {
		if (null != this.autoWidth) {
			return this.autoWidth;
		}
		ValueExpression _ve = getValueExpression("autoWidth");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoWidth</code> property.
	 * </p>
	 */
	public void setAutoWidth(Boolean autoWidth) {
		this.autoWidth = autoWidth;
		this.handleConfig("autoWidth", autoWidth);
	}

	private Integer height;

	/**
	 * The height of this component in pixels (defaultsto auto). <b>Note</b> to
	 * express this dimension as a percentage or offset see <a
	 * href="output/Ext.Component.html#Ext.Component-anchor" ext:member="anchor"
	 * ext:cls="Ext.Component">Ext.Component.anchor</a>.
	 */
	public Integer getHeight() {
		if (null != this.height) {
			return this.height;
		}
		ValueExpression _ve = getValueExpression("height");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>height</code> property.
	 * </p>
	 */
	public void setHeight(Integer height) {
		this.height = height;
		this.handleConfig("height", height);
	}

	private String margins;

	/**
	 * <p>
	 * <b>Note</b>: this config is only used when this BoxComponent is rendered
	 * by a Container which has been configured to use the <b><a
	 * href="output/Ext.layout.BorderLayout.html"
	 * ext:cls="Ext.layout.BorderLayout">BorderLayout</a></b> or one of the two
	 * <b><a href="output/Ext.layout.BoxLayout.html"
	 * ext:cls="Ext.layout.BoxLayout">BoxLayout</a> subclasses.</b>
	 * </p>
	 * 
	 * <p>
	 * An object containing margins to apply to this BoxComponent in the format:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{
	 *     top: (top margin),
	 *     right: (right margin),
	 *     bottom: (bottom margin),
	 *     left: (left margin)
	 * }&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * May also be a string containing space-separated, numeric margin values.
	 * The order of the sides associated with each value matches the way CSS
	 * processes margin values:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li>If there is only one value, it applies to all sides.</li>
	 * 
	 * <li>If there are two values, the top and bottom borders are set to the
	 * first value and the right and left are set to the second.</li>
	 * 
	 * <li>If there are three values, the top is set to the first value, the
	 * left and right are set to the second, and the bottom is set to the third.
	 * </li>
	 * 
	 * <li>If there are four values, they apply to the top, right, bottom, and
	 * left, respectively.</li>
	 * </ul>
	 * </div>
	 * 
	 * <br>
	 * <br>
	 * 
	 * 
	 * <p>
	 * Defaults to:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{top:0, right:0, bottom:0, left:0}&lt;/code&gt;
	 * </pre>
	 */
	public String getMargins() {
		if (null != this.margins) {
			return this.margins;
		}
		ValueExpression _ve = getValueExpression("margins");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>margins</code> property.
	 * </p>
	 */
	public void setMargins(String margins) {
		this.margins = margins;
		this.handleConfig("margins", margins);
	}

	private Integer pageX;

	/**
	 * The page level x coordinate for this componentif contained within a
	 * positioning container.
	 */
	public Integer getPageX() {
		if (null != this.pageX) {
			return this.pageX;
		}
		ValueExpression _ve = getValueExpression("pageX");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>pageX</code> property.
	 * </p>
	 */
	public void setPageX(Integer pageX) {
		this.pageX = pageX;
		this.handleConfig("pageX", pageX);
	}

	private Integer pageY;

	/**
	 * The page level y coordinate for this componentif contained within a
	 * positioning container.
	 */
	public Integer getPageY() {
		if (null != this.pageY) {
			return this.pageY;
		}
		ValueExpression _ve = getValueExpression("pageY");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>pageY</code> property.
	 * </p>
	 */
	public void setPageY(Integer pageY) {
		this.pageY = pageY;
		this.handleConfig("pageY", pageY);
	}

	private String region;

	/**
	 * <p>
	 * <b>Note</b>: this config is only used when this BoxComponent is rendered
	 * by a Container which has been configured to use the <b><a
	 * href="output/Ext.layout.BorderLayout.html"
	 * ext:cls="Ext.layout.BorderLayout">BorderLayout</a></b> layout manager
	 * (e.g. specifying <tt>layout:'border'</tt>).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * See <a href="output/Ext.layout.BorderLayout.html"
	 * ext:cls="Ext.layout.BorderLayout">Ext.layout.BorderLayout</a> also.
	 * </p>
	 */
	public String getRegion() {
		if (null != this.region) {
			return this.region;
		}
		ValueExpression _ve = getValueExpression("region");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>region</code> property.
	 * </p>
	 */
	public void setRegion(String region) {
		this.region = region;
		this.handleConfig("region", region);
	}

	private Integer width;

	/**
	 * The width of this component in pixels (defaultsto auto). <b>Note</b> to
	 * express this dimension as a percentage or offset see <a
	 * href="output/Ext.Component.html#Ext.Component-anchor" ext:member="anchor"
	 * ext:cls="Ext.Component">Ext.Component.anchor</a>.
	 */
	public Integer getWidth() {
		if (null != this.width) {
			return this.width;
		}
		ValueExpression _ve = getValueExpression("width");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>width</code> property.
	 * </p>
	 */
	public void setWidth(Integer width) {
		this.width = width;
		this.handleConfig("width", width);
	}

	private Integer x;

	/**
	 * The local x (left) coordinate for this componentif contained within a
	 * positioning container.
	 */
	public Integer getX() {
		if (null != this.x) {
			return this.x;
		}
		ValueExpression _ve = getValueExpression("x");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>x</code> property.
	 * </p>
	 */
	public void setX(Integer x) {
		this.x = x;
		this.handleConfig("x", x);
	}

	private Integer y;

	/**
	 * The local y (top) coordinate for this componentif contained within a
	 * positioning container.
	 */
	public Integer getY() {
		if (null != this.y) {
			return this.y;
		}
		ValueExpression _ve = getValueExpression("y");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>y</code> property.
	 * </p>
	 */
	public void setY(Integer y) {
		this.y = y;
		this.handleConfig("y", y);
	}
	
	/**
	 * <p>
	 * The name of a JavaScript function to be called after the new content from
	 * the server for this zone has been installed into the view.
	 * </p>
	 */
	private String postReplace = null;

	/**
	 * <p>
	 * Get the name of a JavaScript function to be called after the new content
	 * from the server for this zone has been installed into the view.
	 * </p>
	 */
	public String getPostReplace() {
		if (this.postReplace != null) {
			return this.postReplace;
		}
		ValueExpression ve = getValueExpression("postReplace");
		if (ve != null) {
			return (String) ve.getValue(getFacesContext().getELContext());
		}
		return null;
	}

	/**
	 * <p>
	 * Set the name of a JavaScript function to be called after the new content
	 * from the server for this zone has been installed into the view.
	 * </p>
	 * 
	 * @see #getPostReplace()
	 */
	public void setPostReplace(String postReplace) {
		this.postReplace = postReplace;
	}
	
	/**
	 * <p>
	 * The name of a JavaScript function that will be called when the system
	 * needs to replace a chunk of markup in the view based on the return from
	 * the server.
	 * </p>
	 */
	private String replaceElement = null;

	/**
	 * <p>
	 * Get the name of a JavaScript function that will be called when the system
	 * needs to replace a chunk of markup in the view based on the return from
	 * the server.
	 * </p>
	 */
	public String getReplaceElement() {
		if (this.replaceElement != null) {
			return this.replaceElement;
		}
		ValueExpression ve = getValueExpression("replaceElement");
		if (ve != null) {
			return (String) ve.getValue(getFacesContext().getELContext());
		}
		return null;
	}

	/**
	 * <p>
	 * Set the name of a JavaScript function that will be called when the system
	 * needs to replace a chunk of markup in the view based on the return from
	 * the server.
	 * </p>
	 * 
	 * @see #getReplaceElement()
	 */
	public void setReplaceElement(String replaceElement) {
		this.replaceElement = replaceElement;
	}
	
	/**
	 * <p>
	 * The name of a JavaScript function to be called to provide a closure
	 * argument that will be passed to the Ajax request and made available to
	 * the Ajax response in the <code>replaceElement</code> or
	 * <code>postReplace</code> functions.
	 * </p>
	 */
	private String dataCallback = null;

	/**
	 * <p>
	 * Get the name of a JavaScript function to be called to provide a closure
	 * argument that will be passed to the Ajax request and made available to
	 * the Ajax response in the <code>replaceElement</code> or
	 * <code>postReplace</code> functions.
	 * </p>
	 */
	public String getDataCallback() {
		if (this.dataCallback != null) {
			return this.dataCallback;
		}
		ValueExpression ve = getValueExpression("dataCallback");
		if (ve != null) {
			return (String) ve.getValue(getFacesContext().getELContext());
		}
		return null;
	}

	/**
	 * <p>
	 * Set the name of a JavaScript function to be called to provide a closure
	 * argument that will be passed to the Ajax request and made available to
	 * the Ajax response in the <code>replaceElement</code> or
	 * <code>postReplace</code> functions.
	 * </p>
	 * 
	 * @see #dataCallback()
	 */
	public void setDataCallback(String dataCallback) {
		this.dataCallback = dataCallback;
	}


	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[14];
		}
		_values[0] = super.saveState(_context);
		_values[1] = autoHeight;
		_values[2] = autoWidth;
		_values[3] = height;
		_values[4] = margins;
		_values[5] = pageX;
		_values[6] = pageY;
		_values[7] = region;
		_values[8] = width;
		_values[9] = x;
		_values[10]= y;
		
		_values[11] = this.postReplace;
		_values[12] = this.replaceElement;
		_values[13] = this.dataCallback;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.autoHeight = (Boolean) _values[1];
		this.handleConfig("autoHeight", this.autoHeight);
		this.autoWidth = (Boolean) _values[2];
		this.handleConfig("autoWidth", this.autoWidth);
		this.height = (Integer) _values[3];
		this.handleConfig("height", this.height);
		this.margins = (String) _values[4];
		this.handleConfig("margins", this.margins);
		this.pageX = (Integer) _values[5];
		this.handleConfig("pageX", this.pageX);
		this.pageY = (Integer) _values[6];
		this.handleConfig("pageY", this.pageY);
		this.region = (String) _values[7];
		this.handleConfig("region", this.region);
		this.width = (Integer) _values[8];
		this.handleConfig("width", this.width);
		this.x = (Integer) _values[9];
		this.handleConfig("x", this.x);
		this.y = (Integer) _values[10];
		this.handleConfig("y", this.y);

		this.postReplace = (String) _values[11];
		this.replaceElement = (String) _values[12];
		this.dataCallback = (String) _values[13];
	}
}