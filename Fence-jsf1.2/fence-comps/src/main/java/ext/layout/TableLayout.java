package ext.layout;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.Layout;
import ext.annotation.LayoutType;
import ext.annotation.ParseConfigMode;
import ext.annotation.PersistenceMode;
import ext.annotation.ReferenceMode;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * This layout allows you to easily render content into an HTML table. The total
 * number of columns can be specified, and rowspan and colspan can be used to
 * create complex layouts within the table. This class is intended to be
 * extended or created via the layout:'table' <a
 * href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 * ext:cls="Ext.Container">Ext.Container.layout</a> config, and should generally
 * not need to be created directly via the new keyword.
 * </p>
 * 
 * <p>
 * Note that when creating a layout via config, the layout-specific config
 * properties must be passed in via the <a
 * href="output/Ext.Container.html#Ext.Container-layoutConfig"
 * ext:member="layoutConfig"
 * ext:cls="Ext.Container">Ext.Container.layoutConfig</a> object which will then
 * be applied internally to the layout. In the case of TableLayout, the only
 * valid layout config property is <a
 * href="output/Ext.layout.TableLayout.html#Ext.layout.TableLayout-columns"
 * ext:member="columns" ext:cls="Ext.layout.TableLayout">columns</a>. However,
 * the items added to a TableLayout can supply the following table-specific
 * config properties:
 * </p>
 * 
 * <ul>
 * <li><b>rowspan</b> Applied to the table cell containing the item.</li>
 * 
 * <li><b>colspan</b> Applied to the table cell containing the item.</li>
 * 
 * <li><b>cellId</b> An id applied to the table cell containing the item.</li>
 * 
 * <li><b>cellCls</b> A CSS class name added to the table cell containing the
 * item.</li>
 * </ul>
 * 
 * <p>
 * The basic concept of building up a TableLayout is conceptually very similar
 * to building up a standard HTML table. You simply add each panel (or "cell")
 * that you want to include along with any span attributes specified as the
 * special config properties of rowspan and colspan which work exactly like
 * their HTML counterparts. Rather than explicitly creating and nesting rows and
 * columns as you would in HTML, you simply specify the total column count in
 * the layoutConfig and start adding panels in their natural order from left to
 * right, top to bottom. The layout will automatically figure out, based on the
 * column count, rowspans and colspans, how to position each panel within the
 * table. Just like with HTML tables, your rowspans and colspans must add up
 * correctly in your overall layout or you'll end up with missing and/or extra
 * cells! Example usage:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;i&gt;// This code will generate a layout table that is 3 columns by 2 rows
 * &lt;/i&gt;
 * &lt;i&gt;// &lt;b&gt;with&lt;/b&gt; some spanning included.  The basic layout will be:
 * &lt;/i&gt;
 * &lt;i&gt;// +--------+-----------------+
 * &lt;/i&gt;
 * &lt;i&gt;// |   A    |   B             |
 * &lt;/i&gt;
 * &lt;i&gt;// |        |--------+--------|
 * &lt;/i&gt;
 * &lt;i&gt;// |        |   C    |   D    |
 * &lt;/i&gt;
 * &lt;i&gt;// +--------+--------+--------+
 * &lt;/i&gt;
 * &lt;b&gt;var&lt;/b&gt; table = &lt;b&gt;new&lt;/b&gt; Ext.Panel({
 *     title: &lt;em&gt;'Table Layout'&lt;/em&gt;,
 *     layout:&lt;em&gt;'table'&lt;/em&gt;,
 *     defaults: {
 *         &lt;i&gt;// applied to each contained panel
 * &lt;/i&gt;
 *         bodyStyle:&lt;em&gt;'padding:20px'&lt;/em&gt;
 *     },
 *     layoutConfig: {
 *         &lt;i&gt;// The total column count must be specified here
 * &lt;/i&gt;
 *         columns: 3
 *     },
 *     items: [{
 *         html: &lt;em&gt;'&lt;p&gt;Cell A content&lt;/p&gt;'&lt;/em&gt;,
 *         rowspan: 2
 *     },{
 *         html: &lt;em&gt;'&lt;p&gt;Cell B content&lt;/p&gt;'&lt;/em&gt;,
 *         colspan: 2
 *     },{
 *         html: &lt;em&gt;'&lt;p&gt;Cell C content&lt;/p&gt;'&lt;/em&gt;,
 *         cellCls: &lt;em&gt;'highlight'&lt;/em&gt;
 *     },{
 *         html: &lt;em&gt;'&lt;p&gt;Cell D content&lt;/p&gt;'&lt;/em&gt;
 *     }]
 * });&lt;/code&gt;
 * </pre>
 */
@Layout(LayoutType.table)
@InstanceOf("Ext.layout.TableLayout")
@ParseConfigMode(ui = false, pmode = PersistenceMode.InnerProperty, rmode = ReferenceMode.Config)
public class TableLayout extends ContainerLayout {
	public static final String COMPONENT_TYPE = "Ext.layout.TableLayout";
	public static final String COMPONENT_FAMILY = "Ext.layout.TableLayout";

	/**
	 * <p>
	 * Create a new {@link TableLayout} instance with default property values.
	 * </p>
	 */
	public TableLayout() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Integer columns;

	/**
	 * The total number of columns to create in thetable for this layout. If not
	 * specified, all Components added to this layout will be rendered into a
	 * single row using one column per Component.
	 */
	public Integer getColumns() {
		if (null != this.columns) {
			return this.columns;
		}
		ValueExpression _ve = getValueExpression("columns");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>columns</code> property.
	 * </p>
	 */
	public void setColumns(Integer columns) {
		this.columns = columns;
		this.handleConfig("columns", columns);
	}

	private Object tableAttrs;

	/**
	 * <p>
	 * An object containing properties which are added to the <a
	 * href="output/Ext.DomHelper.html" ext:cls="Ext.DomHelper">DomHelper</a>
	 * specification used to create the layout's <tt>&lt;table&gt;</tt> element.
	 * Example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;{
	 *     xtype: &lt;em&gt;'panel'&lt;/em&gt;,
	 *     layout: &lt;em&gt;'table'&lt;/em&gt;,
	 *     layoutConfig: {
	 *         tableAttrs: {
	 *             style: {
	 *                 width: &lt;em&gt;'100%'&lt;/em&gt;
	 *             }
	 *         },
	 *         columns: 3
	 *     }
	 * }&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getTableAttrs() {
		if (null != this.tableAttrs) {
			return this.tableAttrs;
		}
		ValueExpression _ve = getValueExpression("tableAttrs");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>tableAttrs</code> property.
	 * </p>
	 */
	public void setTableAttrs(Object tableAttrs) {
		this.tableAttrs = tableAttrs;
		this.handleConfig("tableAttrs", tableAttrs);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[3];
		}
		_values[0] = super.saveState(_context);
		_values[1] = columns;
		_values[2] = tableAttrs;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.columns = (Integer) _values[1];
		this.handleConfig("columns", this.columns);
		this.tableAttrs = (Object) _values[2];
		this.handleConfig("tableAttrs", this.tableAttrs);

	}
}