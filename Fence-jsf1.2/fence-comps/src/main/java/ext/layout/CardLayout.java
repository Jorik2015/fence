package ext.layout;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.InstanceOf;
import ext.annotation.Layout;
import ext.annotation.LayoutType;
import ext.annotation.ParseConfigMode;
import ext.annotation.PersistenceMode;
import ext.annotation.ReferenceMode;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * This layout manages multiple child Components, each fitted to the Container,
 * where only a single child Component can be visible at any given time. This
 * layout style is most commonly used for wizards, tab implementations, etc.
 * This class is intended to be extended or created via the layout:'card' <a
 * href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 * ext:cls="Ext.Container">Ext.Container.layout</a> config, and should generally
 * not need to be created directly via the new keyword.
 * </p>
 * 
 * <p>
 * The CardLayout's focal method is <a href=
 * "output/Ext.layout.CardLayout.html#Ext.layout.CardLayout-setActiveItem"
 * ext:member="setActiveItem" ext:cls="Ext.layout.CardLayout">setActiveItem</a>.
 * Since only one panel is displayed at a time, the only way to move from one
 * Component to the next is by calling setActiveItem, passing the id or index of
 * the next panel to display. The layout itself does not provide a user
 * interface for handling this navigation, so that functionality must be
 * provided by the developer.
 * </p>
 * 
 * <p>
 * In the following example, a simplistic wizard setup is demonstrated. A button
 * bar is added to the footer of the containing panel to provide navigation
 * buttons. The buttons will be handled by a common navigation routine -- for
 * this example, the implementation of that routine has been ommitted since it
 * can be any type of custom logic. Note that other uses of a CardLayout (like a
 * tab control) would require a completely different implementation. For serious
 * implementations, a better approach would be to extend CardLayout to provide
 * the custom functionality needed. Example usage:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; navHandler = &lt;b&gt;function&lt;/b&gt;(direction){
 *     &lt;i&gt;// This routine could contain business logic required to manage the navigation steps.
 * &lt;/i&gt;
 *     &lt;i&gt;// It would call setActiveItem as needed, manage navigation button state, handle any
 * &lt;/i&gt;
 *     &lt;i&gt;// branching logic that might be required, handle alternate actions like cancellation
 * &lt;/i&gt;
 *     &lt;i&gt;// or finalization, etc.  A complete wizard implementation could get pretty
 * &lt;/i&gt;
 *     &lt;i&gt;// sophisticated depending on the complexity required, and should probably be
 * &lt;/i&gt;
 *     &lt;i&gt;// done as a subclass of CardLayout &lt;b&gt;in&lt;/b&gt; a real-world implementation.
 * &lt;/i&gt;
 * };
 * 
 * &lt;b&gt;var&lt;/b&gt; card = &lt;b&gt;new&lt;/b&gt; Ext.Panel({
 *     title: &lt;em&gt;'Example Wizard'&lt;/em&gt;,
 *     layout:&lt;em&gt;'card'&lt;/em&gt;,
 *     activeItem: 0, &lt;i&gt;// make sure the active item is set on the container config!
 * &lt;/i&gt;
 *     bodyStyle: &lt;em&gt;'padding:15px'&lt;/em&gt;,
 *     defaults: {
 *         &lt;i&gt;// applied to each contained panel
 * &lt;/i&gt;
 *         border:false
 *     },
 *     &lt;i&gt;// just an example of one possible navigation scheme, using buttons
 * &lt;/i&gt;
 *     bbar: [
 *         {
 *             id: &lt;em&gt;'move-prev'&lt;/em&gt;,
 *             text: &lt;em&gt;'Back'&lt;/em&gt;,
 *             handler: navHandler.createDelegate(this, [-1]),
 *             disabled: true
 *         },
 *         &lt;em&gt;'-&gt;'&lt;/em&gt;, &lt;i&gt;// greedy spacer so that the buttons are aligned to each side
 * &lt;/i&gt;
 *         {
 *             id: &lt;em&gt;'move-next'&lt;/em&gt;,
 *             text: &lt;em&gt;'Next'&lt;/em&gt;,
 *             handler: navHandler.createDelegate(this, [1])
 *         }
 *     ],
 *     &lt;i&gt;// the panels (or &lt;em&gt;&quot;cards&quot;&lt;/em&gt;) within the layout
 * &lt;/i&gt;
 *     items: [{
 *         id: &lt;em&gt;'card-0'&lt;/em&gt;,
 *         html: &lt;em&gt;'&lt;h1&gt;Welcome to the Wizard!&lt;/h1&gt;&lt;p&gt;Step 1 of 3&lt;/p&gt;'&lt;/em&gt;
 *     },{
 *         id: &lt;em&gt;'card-1'&lt;/em&gt;,
 *         html: &lt;em&gt;'&lt;p&gt;Step 2 of 3&lt;/p&gt;'&lt;/em&gt;
 *     },{
 *         id: &lt;em&gt;'card-2'&lt;/em&gt;,
 *         html: &lt;em&gt;'&lt;h1&gt;Congratulations!&lt;/h1&gt;&lt;p&gt;Step 3 of 3 - Complete&lt;/p&gt;'&lt;/em&gt;
 *     }]
 * });&lt;/code&gt;
 * </pre>
 */
@Layout(LayoutType.card)
@InstanceOf("Ext.layout.CardLayout")
@ParseConfigMode(ui = false, pmode = PersistenceMode.InnerProperty, rmode = ReferenceMode.Config)
public class CardLayout extends FitLayout {
	public static final String COMPONENT_TYPE = "Ext.layout.CardLayout";
	public static final String COMPONENT_FAMILY = "Ext.layout.CardLayout";

	/**
	 * <p>
	 * Create a new {@link CardLayout} instance with default property values.
	 * </p>
	 */
	public CardLayout() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private Boolean deferredRender;

	/**
	 * True to render each contained item at the time itbecomes active, false to
	 * render all contained items as soon as the layout is rendered (defaults to
	 * false). If there is a significant amount of content or a lot of heavy
	 * controls being rendered into panels that are not displayed by default,
	 * setting this to true might improve performance.
	 */
	public Boolean getDeferredRender() {
		if (null != this.deferredRender) {
			return this.deferredRender;
		}
		ValueExpression _ve = getValueExpression("deferredRender");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>deferredRender</code> property.
	 * </p>
	 */
	public void setDeferredRender(Boolean deferredRender) {
		this.deferredRender = deferredRender;
		this.handleConfig("deferredRender", deferredRender);
	}

	private Boolean layoutOnCardChange;

	/**
	 * True to force a layout of the active item whenthe active card is changed.
	 * Defaults to false.
	 */
	public Boolean getLayoutOnCardChange() {
		if (null != this.layoutOnCardChange) {
			return this.layoutOnCardChange;
		}
		ValueExpression _ve = getValueExpression("layoutOnCardChange");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>layoutOnCardChange</code> property.
	 * </p>
	 */
	public void setLayoutOnCardChange(Boolean layoutOnCardChange) {
		this.layoutOnCardChange = layoutOnCardChange;
		this.handleConfig("layoutOnCardChange", layoutOnCardChange);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[3];
		}
		_values[0] = super.saveState(_context);
		_values[1] = deferredRender;
		_values[2] = layoutOnCardChange;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.deferredRender = (Boolean) _values[1];
		this.handleConfig("deferredRender", this.deferredRender);
		this.layoutOnCardChange = (Boolean) _values[2];
		this.handleConfig("layoutOnCardChange", this.layoutOnCardChange);

	}
}