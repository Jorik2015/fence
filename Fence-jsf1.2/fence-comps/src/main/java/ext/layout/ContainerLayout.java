package ext.layout;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.InstanceOf;
import ext.annotation.Layout;
import ext.annotation.LayoutType;
import ext.annotation.ParseConfigMode;
import ext.annotation.PersistenceMode;
import ext.annotation.ReferenceMode;
import ext.base.ExtOutput;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * The ContainerLayout class is the default layout manager delegated by <a
 * href="output/Ext.Container.html" ext:cls="Ext.Container">Ext.Container</a> to
 * render any child Components when no
 * <tt><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></tt>
 * is configured into a <a href="output/Ext.Container.html"
 * ext:cls="Ext.Container">Container</a>. ContainerLayout provides the basic
 * foundation for all other layout classes in Ext. It simply renders all child
 * Components into the Container, performing no sizing or positioning services.
 * To utilize a layout that provides sizing and positioning of child Components,
 * specify an appropriate
 * <tt><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></tt>
 * .
 * </p>
 * 
 * <p>
 * This class is intended to be extended or created via the
 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt>
 * configuration property. See
 * 
 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">Ext.Container.layout</a></b></tt>
 * for additional details.
 * </p>
 */
@Layout(LayoutType.container)
@InstanceOf("Ext.layout.ContainerLayout")
@ParseConfigMode(ui = false, pmode = PersistenceMode.InnerProperty, rmode = ReferenceMode.Config)
public class ContainerLayout extends ExtOutput {
	public static final String COMPONENT_TYPE = "Ext.layout.ContainerLayout";
	public static final String COMPONENT_FAMILY = "Ext.layout.ContainerLayout";

	/**
	 * <p>
	 * Create a new {@link ContainerLayout} instance with default property
	 * values.
	 * </p>
	 */
	public ContainerLayout() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String extraCls;

	/**
	 * <p>
	 * An optional extra CSS class that will be added to the container. This can
	 * be useful for adding customized styles to the container or any of its
	 * children using standard CSS rules. See <a
	 * href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">Ext.Component</a>.<a
	 * href="output/Ext.Component.html#Ext.Component-ctCls" ext:member="ctCls"
	 * ext:cls="Ext.Component">ctCls</a> also.
	 * </p>
	 * 
	 * <p>
	 * <b>Note</b>: <tt>extraCls</tt> defaults to <tt>''</tt> except for the following
	 * classes which assign a value by default:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><a href="output/Ext.layout.AbsoluteLayout.html"
	 * ext:cls="Ext.layout.AbsoluteLayout">Absolute Layout</a> : <tt>'x-abs-layout-item'</tt></li>
	 * 
	 * <li><a href="output/Ext.layout.Box.html" ext:cls="Ext.layout.Box">Box
	 * Layout</a> : <tt>'x-box-item'</tt></li>
	 * 
	 * <li><a href="output/Ext.layout.ColumnLayout.html"
	 * ext:cls="Ext.layout.ColumnLayout">Column Layout</a> : <tt>'x-column'</tt></li>
	 * </ul>
	 * </div>
	 * 
	 * To configure the above Classes with an extra CSS class append to the
	 * default. For example, for ColumnLayout:
	 * 
	 * <pre>
	 * &lt;code&gt;extraCls: &lt;em&gt;'x-column custom-class'&lt;/em&gt;&lt;/code&gt;
	 * </pre>
	 * 
	 * <br>
	 * <br>
	 */
	public String getExtraCls() {
		if (null != this.extraCls) {
			return this.extraCls;
		}
		ValueExpression _ve = getValueExpression("extraCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>extraCls</code> property.
	 * </p>
	 */
	public void setExtraCls(String extraCls) {
		this.extraCls = extraCls;
		this.handleConfig("extraCls", extraCls);
	}

	private Boolean renderHidden;

	/**
	 * True to hide each contained item on render(defaults to false).
	 */
	public Boolean getRenderHidden() {
		if (null != this.renderHidden) {
			return this.renderHidden;
		}
		ValueExpression _ve = getValueExpression("renderHidden");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>renderHidden</code> property.
	 * </p>
	 */
	public void setRenderHidden(Boolean renderHidden) {
		this.renderHidden = renderHidden;
		this.handleConfig("renderHidden", renderHidden);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[3];
		}
		_values[0] = super.saveState(_context);
		_values[1] = extraCls;
		_values[2] = renderHidden;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.extraCls = (String) _values[1];
		this.handleConfig("extraCls", this.extraCls);
		this.renderHidden = (Boolean) _values[2];
		this.handleConfig("renderHidden", this.renderHidden);

	}
}