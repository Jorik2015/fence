package ext.util;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.JsonMode;
import ext.base.ExtOutput;

/**
 *Note:This java code is auto generated by abner,do not edit it. Base class
 * that provides a common interface for publishing events. Subclasses are
 * expected to to have a property "events" with all the events defined, and,
 * optionally, a property "listeners" with configured listeners defined.<br>
 * For example:
 * 
 * <pre>
 * &lt;code&gt;Employee = Ext.extend(Ext.util.Observable, {
 *     constructor: &lt;b&gt;function&lt;/b&gt;(config){
 *         this.name = config.name;
 *         this.addEvents({
 *             &lt;em&gt;&quot;fired&quot;&lt;/em&gt; : true,
 *             &lt;em&gt;&quot;quit&quot;&lt;/em&gt; : true
 *         });
 * 
 *         &lt;i&gt;// Copy configured listeners into *this* object so that the base class's&lt;/i&gt;
 *         &lt;i&gt;// constructor will add them.&lt;/i&gt;
 *         this.listeners = config.listeners;
 * 
 *         &lt;i&gt;// Call our superclass constructor to complete construction process.&lt;/i&gt;
 *         Employee.superclass.constructor.call(config)
 *     }
 * });&lt;/code&gt;
 * </pre>
 * 
 * This could then be used like this:
 * 
 * <pre>
 * &lt;code&gt;&lt;b&gt;var&lt;/b&gt; newEmployee = &lt;b&gt;new&lt;/b&gt; Employee({
 *     name: employeeName,
 *     listeners: {
 *         quit: &lt;b&gt;function&lt;/b&gt;() {
 *             &lt;i&gt;// By &lt;b&gt;default&lt;/b&gt;, &lt;em&gt;&quot;this&quot;&lt;/em&gt; will be the object that fired the event.&lt;/i&gt;
 *             alert(this.name + &lt;em&gt;&quot; has quit!&quot;&lt;/em&gt;);
 *         }
 *     }
 * });&lt;/code&gt;
 * </pre>
 */
public class Observable extends ExtOutput {
	public static final String COMPONENT_TYPE = "Ext.util.Observable";

	/**
	 * <p>
	 * Create a new {@link Observable} instance with default property values.
	 * </p>
	 */
	public Observable() {
		super();
		setRendererType(COMPONENT_TYPE);
	}

	public String getFamily() {
		return (COMPONENT_TYPE);
	}

	private Object listeners;

	/**
	 * <p>
	 * A config object containing one or more event handlers to be added to this
	 * object during initialization. This should be a valid listeners config
	 * object as specified in the <a
	 * href="output/Ext.util.Observable.html#Ext.util.Observable-addListener"
	 * ext:member="addListener" ext:cls="Ext.util.Observable">addListener</a>
	 * example for attaching multiple handlers at once.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b><u>DOM events from ExtJs <a href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">Components</a></u></b>
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * While <i>some</i> ExtJs Component classes export selected DOM events
	 * (e.g. "click", "mouseover" etc), this is usually only done when extra
	 * value can be added. For example the <a href="output/Ext.DataView.html"
	 * ext:cls="Ext.DataView">DataView</a>'s <b>
	 * <code><a href="output/Ext.DataView.html#Ext.DataView-click" ext:member="click" ext:cls="Ext.DataView">click</a></code>
	 * </b> event passing the node clicked on. To access DOM events directly
	 * from a Component's HTMLElement, listeners must be added to the <i><a
	 * href="output/Ext.Component.html#Ext.Component-getEl" ext:member="getEl"
	 * ext:cls="Ext.Component">Element</a></i> after the Component has been
	 * rendered. A plugin can simplify this step:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;i&gt;// Plugin is configured &lt;b&gt;with&lt;/b&gt; a listeners config object.&lt;/i&gt;
	 * &lt;i&gt;// The Component is appended to the argument list of all handler functions.&lt;/i&gt;
	 * Ext.DomObserver = Ext.extend(Object, {
	 *     constructor: &lt;b&gt;function&lt;/b&gt;(config) {
	 *         this.listeners = config.listeners ? config.listeners : config;
	 *     },
	 * 
	 *     &lt;i&gt;// Component passes itself into plugin's init method&lt;/i&gt;
	 *     init: &lt;b&gt;function&lt;/b&gt;(c) {
	 *         &lt;b&gt;var&lt;/b&gt; p, l = this.listeners;
	 *         &lt;b&gt;for&lt;/b&gt; (p &lt;b&gt;in&lt;/b&gt; l) {
	 *             &lt;b&gt;if&lt;/b&gt; (Ext.isFunction(l[p])) {
	 *                 l[p] = this.createHandler(l[p], c);
	 *             } &lt;b&gt;else&lt;/b&gt; {
	 *                 l[p].fn = this.createHandler(l[p].fn, c);
	 *             }
	 *         }
	 * 
	 *         &lt;i&gt;// Add the listeners to the Element immediately following the render call&lt;/i&gt;
	 *         c.render = c.render.&lt;a href=&quot;output/Function.html#Function-createSequence&quot; ext:member=&quot;createSequence&quot; ext:cls=&quot;Function&quot;&gt;createSequence&lt;/a&gt;(&lt;b&gt;function&lt;/b&gt;() {
	 *             &lt;b&gt;var&lt;/b&gt; e = c.getEl();
	 *             &lt;b&gt;if&lt;/b&gt; (e) {
	 *                 e.on(l);
	 *             }
	 *         });
	 *     },
	 * 
	 *     createHandler: &lt;b&gt;function&lt;/b&gt;(fn, c) {
	 *         &lt;b&gt;return&lt;/b&gt; &lt;b&gt;function&lt;/b&gt;(e) {
	 *             fn.call(this, e, c);
	 *         };
	 *     }
	 * });
	 * 
	 * &lt;b&gt;var&lt;/b&gt; combo = &lt;b&gt;new&lt;/b&gt; Ext.form.ComboBox({
	 * 
	 *     &lt;i&gt;// Collapse combo when its element is clicked on&lt;/i&gt;
	 *     plugins: [ &lt;b&gt;new&lt;/b&gt; Ext.DomObserver({
	 *         click: &lt;b&gt;function&lt;/b&gt;(evt, comp) {
	 *             comp.collapse();
	 *         }
	 *     })],
	 *     store: myStore,
	 *     typeAhead: true,
	 *     mode: &lt;em&gt;'local'&lt;/em&gt;,
	 *     triggerAction: &lt;em&gt;'all'&lt;/em&gt;
	 * });&lt;/code&gt;
	 * </pre>
	 * 
	 * <br>
	 * <br>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getListeners() {
		if (null != this.listeners) {
			return this.listeners;
		}
		ValueExpression _ve = getValueExpression("listeners");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>listeners</code> property.
	 * </p>
	 */
	public void setListeners(Object listeners) {
		this.listeners = listeners;
		handleConfig("listeners", listeners);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[2];
		}
		_values[0] = super.saveState(_context);
		_values[1] = listeners;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.listeners = (Object) _values[1];
		this.handleConfig("listeners", this.listeners);

	}
}