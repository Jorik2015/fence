package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * Base class for any <a href="output/Ext.BoxComponent.html"
 * ext:cls="Ext.BoxComponent">Ext.BoxComponent</a> that may contain other
 * Components. Containers handle the basic behavior of containing items, namely
 * adding, inserting and removing items.
 * </p>
 * 
 * <p>
 * The most commonly used Container classes are <a href="output/Ext.Panel.html"
 * ext:cls="Ext.Panel">Ext.Panel</a>, <a href="output/Ext.Window.html"
 * ext:cls="Ext.Window">Ext.Window</a> and <a href="output/Ext.TabPanel.html"
 * ext:cls="Ext.TabPanel">Ext.TabPanel</a>. If you do not need the capabilities
 * offered by the aforementioned classes you can create a lightweight Container
 * to be encapsulated by an HTML element to your specifications by using the
 * 
 * <tt><b><a href="output/Ext.Component.html#Ext.Component-autoEl" ext:member="autoEl" ext:cls="Ext.Component">autoEl</a></b></tt>
 * config option. This is a useful technique when creating embedded <a
 * href="output/Ext.layout.ColumnLayout.html"
 * ext:cls="Ext.layout.ColumnLayout">column</a> layouts inside <a
 * href="output/Ext.form.FormPanel.html"
 * ext:cls="Ext.form.FormPanel">FormPanels</a> for example.
 * </p>
 * 
 * <p>
 * The code below illustrates both how to explicitly create a Container, and how
 * to implicitly create one using the <b><tt>'container'</tt></b> xtype:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;i&gt;// explicitly create a Container&lt;/i&gt;
 * &lt;b&gt;var&lt;/b&gt; embeddedColumns = &lt;b&gt;new&lt;/b&gt; Ext.Container({
 *     autoEl: &lt;em&gt;'div'&lt;/em&gt;,  &lt;i&gt;// This is the &lt;b&gt;default&lt;/b&gt;&lt;/i&gt;
 *     layout: &lt;em&gt;'column'&lt;/em&gt;,
 *     defaults: {
 *         &lt;i&gt;// implicitly create Container by specifying xtype&lt;/i&gt;
 *         xtype: &lt;em&gt;'container'&lt;/em&gt;,
 *         autoEl: &lt;em&gt;'div'&lt;/em&gt;, &lt;i&gt;// This is the &lt;b&gt;default&lt;/b&gt;.&lt;/i&gt;
 *         layout: &lt;em&gt;'form'&lt;/em&gt;,
 *         columnWidth: 0.5,
 *         style: {
 *             padding: &lt;em&gt;'10px'&lt;/em&gt;
 *         }
 *     },
 * &lt;i&gt;//  The two items below will be Ext.Containers, each encapsulated by a &lt;DIV&gt; element.&lt;/i&gt;
 *     items: [{
 *         items: {
 *             xtype: &lt;em&gt;'datefield'&lt;/em&gt;,
 *             name: &lt;em&gt;'startDate'&lt;/em&gt;,
 *             fieldLabel: &lt;em&gt;'Start date'&lt;/em&gt;
 *         }
 *     }, {
 *         items: {
 *             xtype: &lt;em&gt;'datefield'&lt;/em&gt;,
 *             name: &lt;em&gt;'endDate'&lt;/em&gt;,
 *             fieldLabel: &lt;em&gt;'End date'&lt;/em&gt;
 *         }
 *     }]
 * });&lt;/code&gt;
 * </pre>
 * 
 * <br>
 * <br>
 * 
 * 
 * <p>
 * <u><b>Layout</b></u>
 * </p>
 * 
 * <p>
 * Container classes delegate the rendering of child Components to a layout
 * manager class which must be configured into the Container using the
 * 
 * <code><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></code>
 * configuration property.
 * </p>
 * 
 * <p>
 * When either specifying child
 * <code><a href="output/Ext.Container.html#Ext.Container-items" ext:member="items" ext:cls="Ext.Container">items</a></code>
 * of a Container, or dynamically <a
 * href="output/Ext.Container.html#Ext.Container-add" ext:member="add"
 * ext:cls="Ext.Container">adding</a> Components to a Container, remember to
 * consider how you wish the Container to arrange those child elements, and
 * whether those child elements need to be sized using one of Ext's built-in <b>
 * 
 * <code><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code>
 * </b> schemes. By default, Containers use the <a
 * href="output/Ext.layout.ContainerLayout.html"
 * ext:cls="Ext.layout.ContainerLayout">ContainerLayout</a> scheme which only
 * renders child components, appending them one after the other inside the
 * Container, and <b>does not apply any sizing</b> at all.
 * </p>
 * 
 * <p>
 * A common mistake is when a developer neglects to specify a <b>
 * <code><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code>
 * </b> (e.g. widgets like GridPanels or TreePanels are added to Containers for
 * which no
 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt>
 * has been specified). If a Container is left to use the default <a
 * href="output/Ext.layout.ContainerLayout.html"
 * ext:cls="Ext.layout.ContainerLayout">ContainerLayout</a> scheme, none of its
 * child components will be resized, or changed in any way when the Container is
 * resized.
 * </p>
 * 
 * <p>
 * Certain layout managers allow dynamic addition of child components. Those
 * that do include <a href="output/Ext.layout.CardLayout.html"
 * ext:cls="Ext.layout.CardLayout">Ext.layout.CardLayout</a>, <a
 * href="output/Ext.layout.AnchorLayout.html"
 * ext:cls="Ext.layout.AnchorLayout">Ext.layout.AnchorLayout</a>, <a
 * href="output/Ext.layout.FormLayout.html"
 * ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>, and <a
 * href="output/Ext.layout.TableLayout.html"
 * ext:cls="Ext.layout.TableLayout">Ext.layout.TableLayout</a>. For example:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;i&gt;//  Create the GridPanel.&lt;/i&gt;
 * &lt;b&gt;var&lt;/b&gt; myNewGrid = &lt;b&gt;new&lt;/b&gt; Ext.grid.GridPanel({
 *     store: myStore,
 *     columns: myColumnModel,
 *     title: &lt;em&gt;'Results'&lt;/em&gt;, &lt;i&gt;// the title becomes the title of the tab&lt;/i&gt;
 * });
 * 
 * myTabPanel.add(myNewGrid); &lt;i&gt;// &lt;a href=&quot;output/Ext.TabPanel.html&quot; ext:cls=&quot;Ext.TabPanel&quot;&gt;Ext.TabPanel&lt;/a&gt; implicitly uses &lt;a href=&quot;output/Ext.layout.CardLayout.html&quot; ext:cls=&quot;Ext.layout.CardLayout&quot;&gt;CardLayout&lt;/a&gt;&lt;/i&gt;
 * myTabPanel.&lt;a href=&quot;output/Ext.TabPanel.html#Ext.TabPanel-setActiveTab&quot; ext:member=&quot;setActiveTab&quot; ext:cls=&quot;Ext.TabPanel&quot;&gt;setActiveTab&lt;/a&gt;(myNewGrid);&lt;/code&gt;
 * </pre>
 * 
 * <br>
 * <br>
 * 
 * 
 * <p>
 * The example above adds a newly created GridPanel to a TabPanel. Note that a
 * TabPanel uses <a href="output/Ext.layout.CardLayout.html"
 * ext:cls="Ext.layout.CardLayout">Ext.layout.CardLayout</a> as its layout
 * manager which means all its child items are sized to <a
 * href="output/Ext.layout.FitLayout.html"
 * ext:cls="Ext.layout.FitLayout">fit</a> exactly into its client area.
 * </p>
 * 
 * <p>
 * <b><u>Overnesting is a common problem</u></b>. An example of overnesting
 * occurs when a GridPanel is added to a TabPanel by wrapping the GridPanel
 * <i>inside</i> a wrapping Panel (that has no
 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt>
 * specified) and then add that wrapping Panel to the TabPanel. The point to
 * realize is that a GridPanel <b>is</b> a Component which can be added directly
 * to a Container. If the wrapping Panel has no
 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt>
 * configuration, then the overnested GridPanel will not be sized as expected.
 * </p>
 * 
 * <p>
 * <u><b>Adding via remote configuration</b></u>
 * </p>
 * 
 * <p>
 * A server side script can be used to add Components which are generated
 * dynamically on the server. An example of adding a GridPanel to a TabPanel
 * where the GridPanel is generated by the server based on certain parameters:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;&lt;i&gt;// execute an Ajax request to invoke server side script:&lt;/i&gt;
 * Ext.Ajax.request({
 *     url: &lt;em&gt;'gen-invoice-grid.php'&lt;/em&gt;,
 *     &lt;i&gt;// send additional parameters to instruct server script&lt;/i&gt;
 *     params: {
 *         startDate: Ext.getCmp(&lt;em&gt;'start-date'&lt;/em&gt;).getValue(),
 *         endDate: Ext.getCmp(&lt;em&gt;'end-date'&lt;/em&gt;).getValue()
 *     },
 *     &lt;i&gt;// process the response object to add it to the TabPanel:&lt;/i&gt;
 *     success: &lt;b&gt;function&lt;/b&gt;(xhr) {
 *         &lt;b&gt;var&lt;/b&gt; newComponent = eval(xhr.responseText); &lt;i&gt;// see discussion below&lt;/i&gt;
 *         myTabPanel.add(newComponent); &lt;i&gt;// add the component to the TabPanel&lt;/i&gt;
 *         myTabPanel.setActiveTab(newComponent);
 *     },
 *     failure: &lt;b&gt;function&lt;/b&gt;() {
 *         Ext.Msg.alert(&lt;em&gt;&quot;Grid create failed&quot;&lt;/em&gt;, &lt;em&gt;&quot;Server communication failure&quot;&lt;/em&gt;);
 *     }
 * });&lt;/code&gt;
 * </pre>
 * 
 * <p>
 * The server script needs to return an executable Javascript statement which,
 * when processed using <tt>eval()</tt>, will return either a config object with
 * an <a href="output/Ext.Component.html#Ext.Component-xtype" ext:member="xtype"
 * ext:cls="Ext.Component">xtype</a>, or an instantiated Component. The server
 * might return this for example:
 * </p>
 * 
 * <pre>
 * &lt;code&gt;(&lt;b&gt;function&lt;/b&gt;() {
 *     &lt;b&gt;function&lt;/b&gt; formatDate(value){
 *         &lt;b&gt;return&lt;/b&gt; value ? value.dateFormat(&lt;em&gt;'M d, Y'&lt;/em&gt;) : &lt;em&gt;''&lt;/em&gt;;
 *     };
 * 
 *     &lt;b&gt;var&lt;/b&gt; store = &lt;b&gt;new&lt;/b&gt; Ext.data.Store({
 *         url: &lt;em&gt;'get-invoice-data.php'&lt;/em&gt;,
 *         baseParams: {
 *             startDate: &lt;em&gt;'01/01/2008'&lt;/em&gt;,
 *             endDate: &lt;em&gt;'01/31/2008'&lt;/em&gt;
 *         },
 *         reader: &lt;b&gt;new&lt;/b&gt; Ext.data.JsonReader({
 *             record: &lt;em&gt;'transaction'&lt;/em&gt;,
 *             idProperty: &lt;em&gt;'id'&lt;/em&gt;,
 *             totalRecords: &lt;em&gt;'total'&lt;/em&gt;
 *         }, [
 *            &lt;em&gt;'customer'&lt;/em&gt;,
 *            &lt;em&gt;'invNo'&lt;/em&gt;,
 *            {name: &lt;em&gt;'date'&lt;/em&gt;, type: &lt;em&gt;'date'&lt;/em&gt;, dateFormat: &lt;em&gt;'m/d/Y'&lt;/em&gt;},
 *            {name: &lt;em&gt;'value'&lt;/em&gt;, type: &lt;em&gt;'float'&lt;/em&gt;}
 *         ])
 *     });
 * 
 *     &lt;b&gt;var&lt;/b&gt; grid = &lt;b&gt;new&lt;/b&gt; Ext.grid.GridPanel({
 *         title: &lt;em&gt;'Invoice Report'&lt;/em&gt;,
 *         bbar: &lt;b&gt;new&lt;/b&gt; Ext.PagingToolbar(store),
 *         store: store,
 *         columns: [
 *             {header: &lt;em&gt;&quot;Customer&quot;&lt;/em&gt;, width: 250, dataIndex: &lt;em&gt;'customer'&lt;/em&gt;, sortable: true},
 *             {header: &lt;em&gt;&quot;Invoice Number&quot;&lt;/em&gt;, width: 120, dataIndex: &lt;em&gt;'invNo'&lt;/em&gt;, sortable: true},
 *             {header: &lt;em&gt;&quot;Invoice Date&quot;&lt;/em&gt;, width: 100, dataIndex: &lt;em&gt;'date'&lt;/em&gt;, renderer: formatDate, sortable: true},
 *             {header: &lt;em&gt;&quot;Value&quot;&lt;/em&gt;, width: 120, dataIndex: &lt;em&gt;'value'&lt;/em&gt;, renderer: &lt;em&gt;'usMoney'&lt;/em&gt;, sortable: true}
 *         ],
 *     });
 *     store.load();
 *     &lt;b&gt;return&lt;/b&gt; grid;  &lt;i&gt;// &lt;b&gt;return&lt;/b&gt; instantiated component&lt;/i&gt;
 * })();&lt;/code&gt;
 * </pre>
 * 
 * <p>
 * When the above code fragment is passed through the <tt>eval</tt> function in
 * the success handler of the Ajax request, the code is executed by the
 * Javascript processor, and the anonymous function runs, and returns the
 * instantiated grid component.
 * </p>
 * 
 * <p>
 * Note: since the code above is <i>generated</i> by a server script, the
 * <tt>baseParams</tt> for the Store, the metadata to allow generation of the
 * Record layout, and the ColumnModel can all be generated into the code since
 * these are all known on the server.
 * </p>
 */
@XType("container")
@InstanceOf("Ext.Container")
public class Container extends BoxComponent {
	public static final String COMPONENT_TYPE = "Ext.Container";
	public static final String COMPONENT_FAMILY = "Ext.Container";

	/**
	 * <p>
	 * Create a new {@link Container} instance with default property values.
	 * </p>
	 */
	public Container() {
		super();
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String activeItem;

	/**
	 * A string component id or the numeric index of thecomponent that should be
	 * initially activated within the container's layout on render. For example,
	 * activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the
	 * container's collection). activeItem only applies to layout styles that
	 * can display items one at a time (like <a
	 * href="output/Ext.layout.AccordionLayout.html"
	 * ext:cls="Ext.layout.AccordionLayout">Ext.layout.AccordionLayout</a>, <a
	 * href="output/Ext.layout.CardLayout.html"
	 * ext:cls="Ext.layout.CardLayout">Ext.layout.CardLayout</a> and <a
	 * href="output/Ext.layout.FitLayout.html"
	 * ext:cls="Ext.layout.FitLayout">Ext.layout.FitLayout</a>). Related to <a
	 * href=
	 * "output/Ext.layout.ContainerLayout.html#Ext.layout.ContainerLayout-activeItem"
	 * ext:member="activeItem"
	 * ext:cls="Ext.layout.ContainerLayout">Ext.layout.ContainerLayout
	 * .activeItem</a>.
	 */
	public String getActiveItem() {
		if (null != this.activeItem) {
			return this.activeItem;
		}
		ValueExpression _ve = getValueExpression("activeItem");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>activeItem</code> property.
	 * </p>
	 */
	public void setActiveItem(String activeItem) {
		this.activeItem = activeItem;
		this.handleConfig("activeItem", activeItem);
	}

	private Boolean autoDestroy;

	/**
	 * If true the container will automatically destroyany contained component
	 * that is removed from it, else destruction must be handled manually
	 * (defaults to true).
	 */
	public Boolean getAutoDestroy() {
		if (null != this.autoDestroy) {
			return this.autoDestroy;
		}
		ValueExpression _ve = getValueExpression("autoDestroy");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>autoDestroy</code> property.
	 * </p>
	 */
	public void setAutoDestroy(Boolean autoDestroy) {
		this.autoDestroy = autoDestroy;
		this.handleConfig("autoDestroy", autoDestroy);
	}

	private Boolean bufferResize;

	/**
	 * When set to true (100 milliseconds) or a numberof milliseconds, the
	 * layout assigned for this container will buffer the frequency it
	 * calculates and does a re-layout of components. This is useful for heavy
	 * containers or containers with a large quantity of sub-components for
	 * which frequent layout calls would be expensive.
	 */
	public Boolean getBufferResize() {
		if (null != this.bufferResize) {
			return this.bufferResize;
		}
		ValueExpression _ve = getValueExpression("bufferResize");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>bufferResize</code> property.
	 * </p>
	 */
	public void setBufferResize(Boolean bufferResize) {
		this.bufferResize = bufferResize;
		this.handleConfig("bufferResize", bufferResize);
	}

	private String defaultType;

	/**
	 * <p>
	 * The default <a href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">xtype</a> of child Components to create in this
	 * Container when a child item is specified as a raw configuration object,
	 * rather than as an instantiated Component.
	 * </p>
	 * 
	 * <p>
	 * Defaults to <tt>'panel'</tt>, except <a href="output/Ext.menu.Menu.html"
	 * ext:cls="Ext.menu.Menu">Ext.menu.Menu</a> which defaults to <tt>'menuitem'</tt>, and <a
	 * href="output/Ext.Toolbar.html" ext:cls="Ext.Toolbar">Ext.Toolbar</a> and
	 * <a href="output/Ext.ButtonGroup.html"
	 * ext:cls="Ext.ButtonGroup">Ext.ButtonGroup</a> which default to <tt>'button'</tt>.
	 * </p>
	 */
	public String getDefaultType() {
		if (null != this.defaultType) {
			return this.defaultType;
		}
		ValueExpression _ve = getValueExpression("defaultType");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>defaultType</code> property.
	 * </p>
	 */
	public void setDefaultType(String defaultType) {
		this.defaultType = defaultType;
		this.handleConfig("defaultType", defaultType);
	}

	private Object defaults;

	/**
	 * <p>
	 * A config object that will be applied to all components added to this
	 * container either via the <a
	 * href="output/Ext.Container.html#Ext.Container-items" ext:member="items"
	 * ext:cls="Ext.Container">items</a> config or via the <a
	 * href="output/Ext.Container.html#Ext.Container-add" ext:member="add"
	 * ext:cls="Ext.Container">add</a> or <a
	 * href="output/Ext.Container.html#Ext.Container-insert" ext:member="insert"
	 * ext:cls="Ext.Container">insert</a> methods. The <tt>defaults</tt> config
	 * can contain any number of name/value property pairs to be added to each
	 * item, and should be valid for the types of items being added to the
	 * container. For example, to automatically apply padding to the body of
	 * each of a set of contained <a href="output/Ext.Panel.html"
	 * ext:cls="Ext.Panel">Ext.Panel</a> items, you could pass: <tt>defaults: {bodyStyle:'padding:15px'}</tt>
	 * .
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b>Note</b>: <tt>defaults</tt> will not be applied to config objects if
	 * the option is already specified. For example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;defaults: {               &lt;i&gt;// defaults are applied to items, not the container&lt;/i&gt;
	 *     autoScroll:true
	 * },
	 * items: [
	 *     {
	 *         xtype: &lt;em&gt;'panel'&lt;/em&gt;,   &lt;i&gt;// defaults &lt;b&gt;do not&lt;/b&gt; have precedence over&lt;/i&gt;
	 *         id: &lt;em&gt;'panel1'&lt;/em&gt;,     &lt;i&gt;// options &lt;b&gt;in&lt;/b&gt; config objects, so the defaults&lt;/i&gt;
	 *         autoScroll: false &lt;i&gt;// will not be applied here, panel1 will be autoScroll:false&lt;/i&gt;
	 *     },
	 *     &lt;b&gt;new&lt;/b&gt; Ext.Panel({       &lt;i&gt;// defaults &lt;b&gt;do&lt;/b&gt; have precedence over options&lt;/i&gt;
	 *         id: &lt;em&gt;'panel2'&lt;/em&gt;,     &lt;i&gt;// options &lt;b&gt;in&lt;/b&gt; components, so the defaults&lt;/i&gt;
	 *         autoScroll: false &lt;i&gt;// will be applied here, panel2 will be autoScroll:true.&lt;/i&gt;
	 *     })
	 * ]&lt;/code&gt;
	 * </pre>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getDefaults() {
		if (null != this.defaults) {
			return this.defaults;
		}
		ValueExpression _ve = getValueExpression("defaults");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>defaults</code> property.
	 * </p>
	 */
	public void setDefaults(Object defaults) {
		this.defaults = defaults;
		this.handleConfig("defaults", defaults);
	}

	private Boolean forceLayout;

	/**
	 * If true the container will force a layoutinitially even if hidden or
	 * collapsed. This option is useful for forcing forms to render in collapsed
	 * or hidden containers. (defaults to false).
	 */
	public Boolean getForceLayout() {
		if (null != this.forceLayout) {
			return this.forceLayout;
		}
		ValueExpression _ve = getValueExpression("forceLayout");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>forceLayout</code> property.
	 * </p>
	 */
	public void setForceLayout(Boolean forceLayout) {
		this.forceLayout = forceLayout;
		this.handleConfig("forceLayout", forceLayout);
	}

	private Boolean hideBorders;

	/**
	 * True to hide the borders of each containedcomponent, false to defer to
	 * the component's existing border settings (defaults to false).
	 */
	public Boolean getHideBorders() {
		if (null != this.hideBorders) {
			return this.hideBorders;
		}
		ValueExpression _ve = getValueExpression("hideBorders");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>hideBorders</code> property.
	 * </p>
	 */
	public void setHideBorders(Boolean hideBorders) {
		this.hideBorders = hideBorders;
		this.handleConfig("hideBorders", hideBorders);
	}

	private Object items;

	/**
	 * <pre>
	 * &lt;b&gt;** IMPORTANT&lt;/b&gt;: be sure to &lt;b&gt;&lt;a href=&quot;output/Ext.Container.html#Ext.Container-layout&quot; ext:member=&quot;layout&quot; ext:cls=&quot;Ext.Container&quot;&gt;specify a &lt;code&gt;layout&lt;/code&gt;&lt;/a&gt; if needed ! **&lt;/b&gt;
	 * </pre>
	 * 
	 * <p>
	 * A single item, or an array of child Components to be added to this
	 * container, for example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;i&gt;// specifying a single item&lt;/i&gt;
	 * items: {...},
	 * layout: &lt;em&gt;'fit'&lt;/em&gt;,    &lt;i&gt;// specify a layout!&lt;/i&gt;
	 * 
	 * &lt;i&gt;// specifying multiple items&lt;/i&gt;
	 * items: [{...}, {...}],
	 * layout: &lt;em&gt;'anchor'&lt;/em&gt;, &lt;i&gt;// specify a layout!&lt;/i&gt;&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * Each item may be:
	 * </p>
	 * 
	 * <div>
	 * <ul class="mdetail-params">
	 * <li>any type of object based on <a href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">Ext.Component</a></li>
	 * 
	 * <li>a fully instanciated object or</li>
	 * 
	 * <li>an object literal that:</li>
	 * 
	 * <li style="list-style: none">
	 * <div>
	 * <ul class="mdetail-params">
	 * <li>has a specified
	 * <code><a href="output/Ext.Component.html#Ext.Component-xtype" ext:member="xtype" ext:cls="Ext.Component">xtype</a></code>
	 * </li>
	 * 
	 * <li>the <a href="output/Ext.Component.html#Ext.Component-xtype"
	 * ext:member="xtype" ext:cls="Ext.Component">Ext.Component.xtype</a>
	 * specified is associated with the Component desired and should be chosen
	 * from one of the available xtypes as listed in <a
	 * href="output/Ext.Component.html"
	 * ext:cls="Ext.Component">Ext.Component</a>.</li>
	 * 
	 * <li>If an
	 * <code><a href="output/Ext.Component.html#Ext.Component-xtype" ext:member="xtype" ext:cls="Ext.Component">xtype</a></code>
	 * is not explicitly specified, the <a
	 * href="output/Ext.Container.html#Ext.Container-defaultType"
	 * ext:member="defaultType" ext:cls="Ext.Container">defaultType</a> for that
	 * Container is used.</li>
	 * 
	 * <li>will be "lazily instanciated", avoiding the overhead of constructing
	 * a fully instanciated Component object</li>
	 * </ul>
	 * </div></li>
	 * </ul>
	 * </div>
	 * 
	 * <p>
	 * <b>Notes</b>:
	 * </p>
	 * 
	 * <div>
	 * <ul class="mdetail-params">
	 * <li>Ext uses lazy rendering. Child Components will only be rendered
	 * should it become necessary. Items are automatically laid out when they
	 * are first shown (no sizing is done while hidden), or in response to a <a
	 * href="output/Ext.Container.html#Ext.Container-doLayout"
	 * ext:member="doLayout" ext:cls="Ext.Container">doLayout</a> call.</li>
	 * 
	 * <li>Do not specify
	 * <code><a href="output/Ext.Panel.html#Ext.Panel-contentEl" ext:member="contentEl" ext:cls="Ext.Panel">contentEl</a></code>/
	 * <code><a href="output/Ext.Panel.html#Ext.Panel-html" ext:member="html" ext:cls="Ext.Panel">html</a></code>
	 * with <code>items</code>.</li>
	 * </ul>
	 * </div>
	 */
	@ClientConfig(JsonMode.Array)
	public Object getItems() {
		if (null != this.items) {
			return this.items;
		}
		ValueExpression _ve = getValueExpression("items");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>items</code> property.
	 * </p>
	 */
	public void setItems(Object items) {
		this.items = items;
		this.handleConfig("items", items);
	}

	private String layout;

	/**
	 * <p>
	 * <b>*Important</b>: In order for child items to be correctly sized and
	 * positioned, typically a layout manager <b>must</b> be specified through
	 * the <code>layout</code> configuration option.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * The sizing and positioning of child <a href="output/items.html"
	 * ext:cls="items">items</a> is the responsibility of the Container's layout
	 * manager which creates and manages the type of layout you have in mind.
	 * For example:
	 * </p>
	 * 
	 * <pre>
	 * &lt;code&gt;&lt;b&gt;new&lt;/b&gt; Ext.Window({
	 *     width:300, height: 300,
	 *     layout: &lt;em&gt;'fit'&lt;/em&gt;, &lt;i&gt;// explicitly set layout manager: override the &lt;b&gt;default&lt;/b&gt; (layout:&lt;em&gt;'auto'&lt;/em&gt;)&lt;/i&gt;
	 *     items: [{
	 *         title: &lt;em&gt;'Panel inside a Window'&lt;/em&gt;
	 *     }]
	 * }).show();&lt;/code&gt;
	 * </pre>
	 * 
	 * <p>
	 * If the <a href="output/Ext.Container.html#Ext.Container-layout"
	 * ext:member="layout" ext:cls="Ext.Container">layout</a> configuration is
	 * not explicitly specified for a general purpose container (e.g. Container
	 * or Panel) the <a href="output/Ext.layout.ContainerLayout.html"
	 * ext:cls="Ext.layout.ContainerLayout">default layout manager</a> will be
	 * used which does nothing but render child components sequentially into the
	 * Container (no sizing or positioning will be performed in this situation).
	 * Some container classes implicitly specify a default layout (e.g.
	 * FormPanel specifies <code>layout:<em>'form'</em></code>). Other specific purpose classes
	 * internally specify/manage their internal layout (e.g. GridPanel,
	 * TabPanel, TreePanel, Toolbar, Menu, etc.).
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * <b><code>layout</code></b> may be specified as either as an Object or as
	 * a String:
	 * </p>
	 * 
	 * <div>
	 * <ul class="mdetail-params">
	 * <li><u>Specify as an Object</u></li>
	 * 
	 * <li style="list-style: none">
	 * <div>
	 * <ul class="mdetail-params">
	 * <li>Example usage:</li>
	 * 
	 * <li style="list-style: none">
	 * 
	 * <pre>
	 * &lt;code&gt;layout: {
	 *     type: &lt;em&gt;'vbox'&lt;/em&gt;,
	 *     padding: &lt;em&gt;'5'&lt;/em&gt;,
	 *     align: &lt;em&gt;'left'&lt;/em&gt;
	 * }&lt;/code&gt;
	 * </pre>
	 * 
	 * </li>
	 * 
	 * <li><tt><b>type</b></tt></li>
	 * 
	 * <li style="list-style: none"><br>
	 * <p>
	 * The layout type to be used for this container. If not specified, a
	 * default <a href="output/Ext.layout.ContainerLayout.html"
	 * ext:cls="Ext.layout.ContainerLayout">Ext.layout.ContainerLayout</a> will
	 * be created and used.
	 * </p>
	 * 
	 * <br>
	 * <p>
	 * Valid layout <tt>type</tt> values are:
	 * </p>
	 * 
	 * <div class="sub-desc">
	 * <ul class="mdetail-params">
	 * <li>
	 * <tt><b><a href="output/Ext.layout.AbsoluteLayout.html" ext:cls="Ext.layout.AbsoluteLayout">absolute</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.AccordionLayout.html" ext:cls="Ext.layout.AccordionLayout">accordion</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.AnchorLayout.html" ext:cls="Ext.layout.AnchorLayout">anchor</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.ContainerLayout.html" ext:cls="Ext.layout.ContainerLayout">auto</a></b></tt>
	 * &nbsp;&nbsp;&nbsp; <b>Default</b></li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.BorderLayout.html" ext:cls="Ext.layout.BorderLayout">border</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.CardLayout.html" ext:cls="Ext.layout.CardLayout">card</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.ColumnLayout.html" ext:cls="Ext.layout.ColumnLayout">column</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.FitLayout.html" ext:cls="Ext.layout.FitLayout">fit</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.FormLayout.html" ext:cls="Ext.layout.FormLayout">form</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.HBoxLayout.html" ext:cls="Ext.layout.HBoxLayout">hbox</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.MenuLayout.html" ext:cls="Ext.layout.MenuLayout">menu</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.TableLayout.html" ext:cls="Ext.layout.TableLayout">table</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.ToolbarLayout.html" ext:cls="Ext.layout.ToolbarLayout">toolbar</a></b></tt>
	 * </li>
	 * 
	 * <li>
	 * <tt><b><a href="output/Ext.layout.VBoxLayout.html" ext:cls="Ext.layout.VBoxLayout">vbox</a></b></tt>
	 * </li>
	 * </ul>
	 * </div></li>
	 * 
	 * <li>Layout specific configuration properties</li>
	 * 
	 * <li style="list-style: none"><br>
	 * <p>
	 * Additional layout specific configuration properties may also be
	 * specified. For complete details regarding the valid config options for
	 * each layout type, see the layout class corresponding to the <tt>type</tt>
	 * specified.
	 * </p>
	 * </li>
	 * </ul>
	 * </div></li>
	 * 
	 * <li><u>Specify as a String</u></li>
	 * 
	 * <li style="list-style: none">
	 * <div>
	 * <ul class="mdetail-params">
	 * <li>Example usage:</li>
	 * 
	 * <li style="list-style: none">
	 * 
	 * <pre>
	 * &lt;code&gt;layout: &lt;em&gt;'vbox'&lt;/em&gt;,
	 * layoutConfig: {
	 *     padding: &lt;em&gt;'5'&lt;/em&gt;,
	 *     align: &lt;em&gt;'left'&lt;/em&gt;
	 * }&lt;/code&gt;
	 * </pre>
	 * 
	 * </li>
	 * 
	 * <li><tt><b>layout</b></tt></li>
	 * 
	 * <li style="list-style: none"><br>
	 * <p>
	 * The layout <tt>type</tt> to be used for this container (see list of valid
	 * layout type values above).
	 * </p>
	 * 
	 * <br>
	 * </li>
	 * 
	 * <li>
	 * 
	 * <tt><b><a href="output/Ext.Container.html#Ext.Container-layoutConfig" ext:member="layoutConfig" ext:cls="Ext.Container">layoutConfig</a></b></tt>
	 * </li>
	 * 
	 * <li style="list-style: none"><br>
	 * <p>
	 * Additional layout specific configuration properties. For complete details
	 * regarding the valid config options for each layout type, see the layout
	 * class corresponding to the <tt>layout</tt> specified.
	 * </p>
	 * </li>
	 * </ul>
	 * </div></li>
	 * </ul>
	 * </div>
	 */
	public String getLayout() {
		if (null != this.layout) {
			return this.layout;
		}
		ValueExpression _ve = getValueExpression("layout");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>layout</code> property.
	 * </p>
	 */
	public void setLayout(String layout) {
		this.layout = layout;
		this.handleConfig("layout", layout);
	}

	private Object layoutConfig;

	/**
	 * This is a config object containing propertiesspecific to the chosen <b>
	 * 
	 * <code><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code>
	 * </b> if <b>
	 * <code><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code>
	 * </b> has been specified as a <i>string</i>.<br>
	 * <br>
	 */
	@ClientConfig(JsonMode.Object)
	public Object getLayoutConfig() {
		if (null != this.layoutConfig) {
			return this.layoutConfig;
		}
		ValueExpression _ve = getValueExpression("layoutConfig");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>layoutConfig</code> property.
	 * </p>
	 */
	public void setLayoutConfig(Object layoutConfig) {
		this.layoutConfig = layoutConfig;
		this.handleConfig("layoutConfig", layoutConfig);
	}

	private Boolean monitorResize;

	/**
	 * True to automatically monitor window resizeevents to handle anything that
	 * is sensitive to the current size of the viewport. This value is typically
	 * managed by the chosen
	 * <code><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code>
	 * and should not need to be set manually.
	 */
	public Boolean getMonitorResize() {
		if (null != this.monitorResize) {
			return this.monitorResize;
		}
		ValueExpression _ve = getValueExpression("monitorResize");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>monitorResize</code> property.
	 * </p>
	 */
	public void setMonitorResize(Boolean monitorResize) {
		this.monitorResize = monitorResize;
		this.handleConfig("monitorResize", monitorResize);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[12];
		}
		_values[0] = super.saveState(_context);
		_values[1] = activeItem;
		_values[2] = autoDestroy;
		_values[3] = bufferResize;
		_values[4] = defaultType;
		_values[5] = defaults;
		_values[6] = forceLayout;
		_values[7] = hideBorders;
		_values[8] = items;
		_values[9] = layout;
		_values[10]= layoutConfig;
		_values[11]= monitorResize;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.activeItem = (String) _values[1];
		this.handleConfig("activeItem", this.activeItem);
		this.autoDestroy = (Boolean) _values[2];
		this.handleConfig("autoDestroy", this.autoDestroy);
		this.bufferResize = (Boolean) _values[3];
		this.handleConfig("bufferResize", this.bufferResize);
		this.defaultType = (String) _values[4];
		this.handleConfig("defaultType", this.defaultType);
		this.defaults = (Object) _values[5];
		this.handleConfig("defaults", this.defaults);
		this.forceLayout = (Boolean) _values[6];
		this.handleConfig("forceLayout", this.forceLayout);
		this.hideBorders = (Boolean) _values[7];
		this.handleConfig("hideBorders", this.hideBorders);
		this.items = (Object) _values[8];
		this.handleConfig("items", this.items);
		this.layout = (String) _values[9];
		this.handleConfig("layout", this.layout);
		this.layoutConfig = (Object) _values[10];
		this.handleConfig("layoutConfig", this.layoutConfig);
		this.monitorResize = (Boolean) _values[11];
		this.handleConfig("monitorResize", this.monitorResize);

	}
}