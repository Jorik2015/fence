package ext;

import javax.el.ValueExpression;
import javax.faces.context.FacesContext;

import ext.annotation.ClientConfig;
import ext.annotation.InstanceOf;
import ext.annotation.JsonMode;
import ext.annotation.XType;

/**
 *Note:This java code is auto generated by abner,do not edit it.
 * 
 * <p>
 * A specialized panel intended for use as an application window. Windows are
 * floated, <a href="output/Ext.Window.html#Ext.Window-resizable"
 * ext:member="resizable" ext:cls="Ext.Window">resizable</a>, and <a
 * href="output/Ext.Window.html#Ext.Window-draggable" ext:member="draggable"
 * ext:cls="Ext.Window">draggable</a> by default. Windows can be <a
 * href="output/Ext.Window.html#Ext.Window-maximizable" ext:member="maximizable"
 * ext:cls="Ext.Window">maximized</a> to fill the viewport, restored to their
 * prior size, and can be <a href="output/Ext.Window.html#Ext.Window-minimize"
 * ext:member="minimize" ext:cls="Ext.Window">minimize</a>d.
 * </p>
 * 
 * <p>
 * Windows can also be linked to a <a href="output/Ext.WindowGroup.html"
 * ext:cls="Ext.WindowGroup">Ext.WindowGroup</a> or managed by the <a
 * href="output/Ext.WindowMgr.html" ext:cls="Ext.WindowMgr">Ext.WindowMgr</a> to
 * provide grouping, activation, to front, to back and other
 * application-specific behavior.
 * </p>
 * 
 * <p>
 * By default, Windows will be rendered to document.body. To <a
 * href="output/Ext.Window.html#Ext.Window-constrain" ext:member="constrain"
 * ext:cls="Ext.Window">constrain</a> a Window to another element specify <a
 * href="output/Ext.Component.html#Ext.Component-renderTo" ext:member="renderTo"
 * ext:cls="Ext.Component">renderTo</a>.
 * </p>
 * 
 * <p>
 * <b>Note:</b> By default, the
 * <code><a href="output/Ext.Window.html#Ext.Window-closable" ext:member="closable" ext:cls="Ext.Window">close</a></code>
 * header tool <i>destroys</i> the Window resulting in destruction of any child
 * Components. This makes the Window object, and all its descendants
 * <b>unusable</b>. To enable re-use of a Window, use <b>
 * <code><a href="output/Ext.Window.html#Ext.Window-closeAction" ext:member="closeAction" ext:cls="Ext.Window">closeAction:
<em>'hide'</em></a></code></b>.
 * </p>
 */
@XType("window")
@InstanceOf("Ext.Window")
public class Window extends Panel {
	public static final String COMPONENT_TYPE = "Ext.Window";
	public static final String COMPONENT_FAMILY = "Ext.Window";

	/**
	 * <p>
	 * Create a new {@link Window} instance with default property values.
	 * </p>
	 */
	public Window() {
		super();
		this.setNs("top");
		setRendererType(COMPONENT_FAMILY);
	}

	public String getFamily() {
		return (COMPONENT_FAMILY);
	}

	private String animateTarget;

	/**
	 * Id or element from which the window shouldanimate while opening (defaults
	 * to null with no animation).
	 */
	public String getAnimateTarget() {
		if (null != this.animateTarget) {
			return this.animateTarget;
		}
		ValueExpression _ve = getValueExpression("animateTarget");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>animateTarget</code> property.
	 * </p>
	 */
	public void setAnimateTarget(String animateTarget) {
		this.animateTarget = animateTarget;
		this.handleConfig("animateTarget", animateTarget);
	}

	private String baseCls;

	/**
	 * The base CSS class to apply to this panel'selement (defaults to
	 * 'x-window').
	 */
	public String getBaseCls() {
		if (null != this.baseCls) {
			return this.baseCls;
		}
		ValueExpression _ve = getValueExpression("baseCls");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>baseCls</code> property.
	 * </p>
	 */
	public void setBaseCls(String baseCls) {
		this.baseCls = baseCls;
		this.handleConfig("baseCls", baseCls);
	}

	private Boolean closable;

	/**
	 * <p>
	 * True to display the 'close' tool button and allow the user to close the
	 * window, false to hide the button and disallow closing the window
	 * (defaults to true).
	 * </p>
	 * 
	 * <p>
	 * By default, when close is requested by either clicking the close button
	 * in the header or pressing ESC when the Window has focus, the <a
	 * href="output/Ext.Window.html#Ext.Window-close" ext:member="close"
	 * ext:cls="Ext.Window">close</a> method will be called. This will <i><a
	 * href="output/Ext.Component.html#Ext.Component-destroy"
	 * ext:member="destroy" ext:cls="Ext.Component">destroy</a></i> the Window
	 * and its content meaning that it may not be reused.
	 * </p>
	 * 
	 * <p>
	 * To make closing a Window <i>hide</i> the Window so that it may be reused,
	 * set <a href="output/Ext.Window.html#Ext.Window-closeAction"
	 * ext:member="closeAction" ext:cls="Ext.Window">closeAction</a> to 'hide'.
	 * </p>
	 */
	public Boolean getClosable() {
		if (null != this.closable) {
			return this.closable;
		}
		ValueExpression _ve = getValueExpression("closable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>closable</code> property.
	 * </p>
	 */
	public void setClosable(Boolean closable) {
		this.closable = closable;
		this.handleConfig("closable", closable);
	}

	private String closeAction;

	/**
	 * <p>
	 * The action to take when the close header tool is clicked:
	 * </p>
	 * 
	 * <div class="mdetail-params">
	 * <ul>
	 * <li><b><code><em>'<a href="output/Ext.Window.html#Ext.Window-close" ext:member="close" ext:cls="Ext.Window">close</a>'</em></code></b> : <b>Default</b> <div class="sub-desc"><a
	 * href="output/Ext.Window.html#Ext.Window-close" ext:member="close"
	 * ext:cls="Ext.Window">remove</a> the window from the DOM and <a
	 * href="output/Ext.Component.html#Ext.Component-destroy"
	 * ext:member="destroy" ext:cls="Ext.Component">destroy</a> it and all
	 * descendant Components. The window will <b>not</b> be available to be
	 * redisplayed via the <a href="output/Ext.Window.html#Ext.Window-show"
	 * ext:member="show" ext:cls="Ext.Window">show</a> method.</div></li>
	 * 
	 * <li><b><code><em>'<a href="output/Ext.Window.html#Ext.Window-hide" ext:member="hide" ext:cls="Ext.Window">hide</a>'</em></code></b> :
	 * 
	 * <div class="sub-desc"><a href="output/Ext.Window.html#Ext.Window-hide"
	 * ext:member="hide" ext:cls="Ext.Window">hide</a> the window by setting
	 * visibility to hidden and applying negative offsets. The window will be
	 * available to be redisplayed via the <a
	 * href="output/Ext.Window.html#Ext.Window-show" ext:member="show"
	 * ext:cls="Ext.Window">show</a> method.</div></li>
	 * </ul>
	 * </div>
	 * 
	 * <p>
	 * <b>Note:</b> This setting does not affect the <a
	 * href="output/Ext.Window.html#Ext.Window-close" ext:member="close"
	 * ext:cls="Ext.Window">close</a> method which will always <a
	 * href="output/Ext.Component.html#Ext.Component-destroy"
	 * ext:member="destroy" ext:cls="Ext.Component">destroy</a> the window. To
	 * programatically <i>hide</i> a window, call <a
	 * href="output/Ext.Window.html#Ext.Window-hide" ext:member="hide"
	 * ext:cls="Ext.Window">hide</a>.
	 * </p>
	 */
	public String getCloseAction() {
		if (null != this.closeAction) {
			return this.closeAction;
		}
		ValueExpression _ve = getValueExpression("closeAction");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>closeAction</code> property.
	 * </p>
	 */
	public void setCloseAction(String closeAction) {
		this.closeAction = closeAction;
		this.handleConfig("closeAction", closeAction);
	}

	private Boolean collapsed;

	/**
	 * True to render the window collapsed, false torender it expanded (defaults
	 * to false). Note that if <a
	 * href="output/Ext.Window.html#Ext.Window-expandOnShow"
	 * ext:member="expandOnShow" ext:cls="Ext.Window">expandOnShow</a> is true
	 * (the default) it will override the <tt>collapsed</tt> config and the
	 * window will always be expanded when shown.
	 */
	public Boolean getCollapsed() {
		if (null != this.collapsed) {
			return this.collapsed;
		}
		ValueExpression _ve = getValueExpression("collapsed");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>collapsed</code> property.
	 * </p>
	 */
	public void setCollapsed(Boolean collapsed) {
		this.collapsed = collapsed;
		this.handleConfig("collapsed", collapsed);
	}

	private Boolean constrain;

	/**
	 * True to constrain the window within itscontaining element, false to allow
	 * it to fall outside of its containing element. By default the window will
	 * be rendered to document.body. To render and constrain the window within
	 * another element specify <a
	 * href="output/Ext.Window.html#Ext.Window-renderTo" ext:member="renderTo"
	 * ext:cls="Ext.Window">renderTo</a>. (defaults to false). Optionally the
	 * header only can be constrained using <a
	 * href="output/Ext.Window.html#Ext.Window-constrainHeader"
	 * ext:member="constrainHeader" ext:cls="Ext.Window">constrainHeader</a>.
	 */
	public Boolean getConstrain() {
		if (null != this.constrain) {
			return this.constrain;
		}
		ValueExpression _ve = getValueExpression("constrain");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>constrain</code> property.
	 * </p>
	 */
	public void setConstrain(Boolean constrain) {
		this.constrain = constrain;
		this.handleConfig("constrain", constrain);
	}

	private Boolean constrainHeader;

	/**
	 * True to constrain the window header within itscontaining element
	 * (allowing the window body to fall outside of its containing element) or
	 * false to allow the header to fall outside its containing element
	 * (defaults to false). Optionally the entire window can be constrained
	 * using <a href="output/Ext.Window.html#Ext.Window-constrain"
	 * ext:member="constrain" ext:cls="Ext.Window">constrain</a>.
	 */
	public Boolean getConstrainHeader() {
		if (null != this.constrainHeader) {
			return this.constrainHeader;
		}
		ValueExpression _ve = getValueExpression("constrainHeader");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>constrainHeader</code> property.
	 * </p>
	 */
	public void setConstrainHeader(Boolean constrainHeader) {
		this.constrainHeader = constrainHeader;
		this.handleConfig("constrainHeader", constrainHeader);
	}

	private String defaultButton;

	/**
	 * The id / index of a button or a button instanceto focus when this window
	 * received the focus.
	 */
	public String getDefaultButton() {
		if (null != this.defaultButton) {
			return this.defaultButton;
		}
		ValueExpression _ve = getValueExpression("defaultButton");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>defaultButton</code> property.
	 * </p>
	 */
	public void setDefaultButton(String defaultButton) {
		this.defaultButton = defaultButton;
		this.handleConfig("defaultButton", defaultButton);
	}

	private Boolean draggable;

	/**
	 * True to allow the window to be dragged by theheader bar, false to disable
	 * dragging (defaults to true). Note that by default the window will be
	 * centered in the viewport, so if dragging is disabled the window may need
	 * to be positioned programmatically after render (e.g.,
	 * myWindow.setPosition(100, 100);).
	 */
	public Boolean getDraggable() {
		if (null != this.draggable) {
			return this.draggable;
		}
		ValueExpression _ve = getValueExpression("draggable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>draggable</code> property.
	 * </p>
	 */
	public void setDraggable(Boolean draggable) {
		this.draggable = draggable;
		this.handleConfig("draggable", draggable);
	}

	private Boolean expandOnShow;

	/**
	 * True to always expand the window when it isdisplayed, false to keep it in
	 * its current state (which may be <a
	 * href="output/Ext.Window.html#Ext.Window-collapsed" ext:member="collapsed"
	 * ext:cls="Ext.Window">collapsed</a>) when displayed (defaults to true).
	 */
	public Boolean getExpandOnShow() {
		if (null != this.expandOnShow) {
			return this.expandOnShow;
		}
		ValueExpression _ve = getValueExpression("expandOnShow");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>expandOnShow</code> property.
	 * </p>
	 */
	public void setExpandOnShow(Boolean expandOnShow) {
		this.expandOnShow = expandOnShow;
		this.handleConfig("expandOnShow", expandOnShow);
	}

	private Boolean initHidden;

	/**
	 * True to hide the window until show() isexplicitly called (defaults to
	 * true).
	 */
	public Boolean getInitHidden() {
		if (null != this.initHidden) {
			return this.initHidden;
		}
		ValueExpression _ve = getValueExpression("initHidden");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>initHidden</code> property.
	 * </p>
	 */
	public void setInitHidden(Boolean initHidden) {
		this.initHidden = initHidden;
		this.handleConfig("initHidden", initHidden);
	}

	private Object manager;

	/**
	 * A reference to the WindowGroup that shouldmanage this window (defaults to
	 * <a href="output/Ext.WindowMgr.html"
	 * ext:cls="Ext.WindowMgr">Ext.WindowMgr</a>).
	 */
	@ClientConfig(JsonMode.Object)
	public Object getManager() {
		if (null != this.manager) {
			return this.manager;
		}
		ValueExpression _ve = getValueExpression("manager");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>manager</code> property.
	 * </p>
	 */
	public void setManager(Object manager) {
		this.manager = manager;
		this.handleConfig("manager", manager);
	}

	private Boolean maximizable;

	/**
	 * True to display the 'maximize' tool button andallow the user to maximize
	 * the window, false to hide the button and disallow maximizing the window
	 * (defaults to false). Note that when a window is maximized, the tool
	 * button will automatically change to a 'restore' button with the
	 * appropriate behavior already built-in that will restore the window to its
	 * previous size.
	 */
	public Boolean getMaximizable() {
		if (null != this.maximizable) {
			return this.maximizable;
		}
		ValueExpression _ve = getValueExpression("maximizable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maximizable</code> property.
	 * </p>
	 */
	public void setMaximizable(Boolean maximizable) {
		this.maximizable = maximizable;
		this.handleConfig("maximizable", maximizable);
	}

	private Boolean maximized;

	/**
	 * True to initially display the window in amaximized state. (Defaults to
	 * false).
	 */
	public Boolean getMaximized() {
		if (null != this.maximized) {
			return this.maximized;
		}
		ValueExpression _ve = getValueExpression("maximized");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>maximized</code> property.
	 * </p>
	 */
	public void setMaximized(Boolean maximized) {
		this.maximized = maximized;
		this.handleConfig("maximized", maximized);
	}

	private Integer minHeight;

	/**
	 * The minimum height in pixels allowed for thiswindow (defaults to 100).
	 * Only applies when resizable = true.
	 */
	public Integer getMinHeight() {
		if (null != this.minHeight) {
			return this.minHeight;
		}
		ValueExpression _ve = getValueExpression("minHeight");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>minHeight</code> property.
	 * </p>
	 */
	public void setMinHeight(Integer minHeight) {
		this.minHeight = minHeight;
		this.handleConfig("minHeight", minHeight);
	}

	private Integer minWidth;

	/**
	 * The minimum width in pixels allowed for thiswindow (defaults to 200).
	 * Only applies when resizable = true.
	 */
	public Integer getMinWidth() {
		if (null != this.minWidth) {
			return this.minWidth;
		}
		ValueExpression _ve = getValueExpression("minWidth");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>minWidth</code> property.
	 * </p>
	 */
	public void setMinWidth(Integer minWidth) {
		this.minWidth = minWidth;
		this.handleConfig("minWidth", minWidth);
	}

	private Boolean minimizable;

	/**
	 * True to display the 'minimize' tool button andallow the user to minimize
	 * the window, false to hide the button and disallow minimizing the window
	 * (defaults to false). Note that this button provides no implementation --
	 * the behavior of minimizing a window is implementation-specific, so the
	 * minimize event must be handled and a custom minimize behavior implemented
	 * for this option to be useful.
	 */
	public Boolean getMinimizable() {
		if (null != this.minimizable) {
			return this.minimizable;
		}
		ValueExpression _ve = getValueExpression("minimizable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>minimizable</code> property.
	 * </p>
	 */
	public void setMinimizable(Boolean minimizable) {
		this.minimizable = minimizable;
		this.handleConfig("minimizable", minimizable);
	}

	private Boolean modal;

	/**
	 * True to make the window modal and mask everythingbehind it when
	 * displayed, false to display it without restricting access to other UI
	 * elements (defaults to false).
	 */
	public Boolean getModal() {
		if (null != this.modal) {
			return this.modal;
		}
		ValueExpression _ve = getValueExpression("modal");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>modal</code> property.
	 * </p>
	 */
	public void setModal(Boolean modal) {
		this.modal = modal;
		this.handleConfig("modal", modal);
	}

	private Object onEsc;

	/**
	 * Allows override of the built-in processing forthe escape key. Default
	 * action is to close the Window (performing whatever action is specified in
	 * <a href="output/Ext.Window.html#Ext.Window-closeAction"
	 * ext:member="closeAction" ext:cls="Ext.Window">closeAction</a>. To prevent
	 * the Window closing when the escape key is pressed, specify this as
	 * Ext.emptyFn (See <a href="output/Ext.html#Ext-emptyFn"
	 * ext:member="emptyFn" ext:cls="Ext">Ext.emptyFn</a>).
	 */
	@ClientConfig(JsonMode.Function)
	public Object getOnEsc() {
		if (null != this.onEsc) {
			return this.onEsc;
		}
		ValueExpression _ve = getValueExpression("onEsc");
		if (_ve != null) {
			return (Object) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>onEsc</code> property.
	 * </p>
	 */
	public void setOnEsc(Object onEsc) {
		this.onEsc = onEsc;
		this.handleConfig("onEsc", onEsc);
	}

	private Boolean plain;

	/**
	 * True to render the window body with a transparentbackground so that it
	 * will blend into the framing elements, false to add a lighter background
	 * color to visually highlight the body element and separate it more
	 * distinctly from the surrounding frame (defaults to false).
	 */
	public Boolean getPlain() {
		if (null != this.plain) {
			return this.plain;
		}
		ValueExpression _ve = getValueExpression("plain");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>plain</code> property.
	 * </p>
	 */
	public void setPlain(Boolean plain) {
		this.plain = plain;
		this.handleConfig("plain", plain);
	}

	private Boolean resizable;

	/**
	 * True to allow user resizing at each edge andcorner of the window, false
	 * to disable resizing (defaults to true).
	 */
	public Boolean getResizable() {
		if (null != this.resizable) {
			return this.resizable;
		}
		ValueExpression _ve = getValueExpression("resizable");
		if (_ve != null) {
			return (Boolean) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>resizable</code> property.
	 * </p>
	 */
	public void setResizable(Boolean resizable) {
		this.resizable = resizable;
		this.handleConfig("resizable", resizable);
	}

	private String resizeHandles;

	/**
	 * A valid <a href="output/Ext.Resizable.html"
	 * ext:cls="Ext.Resizable">Ext.Resizable</a> handles config string(defaults
	 * to 'all'). Only applies when resizable = true.
	 */
	public String getResizeHandles() {
		if (null != this.resizeHandles) {
			return this.resizeHandles;
		}
		ValueExpression _ve = getValueExpression("resizeHandles");
		if (_ve != null) {
			return (String) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>resizeHandles</code> property.
	 * </p>
	 */
	public void setResizeHandles(String resizeHandles) {
		this.resizeHandles = resizeHandles;
		this.handleConfig("resizeHandles", resizeHandles);
	}

	private Integer x;

	/**
	 * The X position of the left edge of the window oninitial showing. Defaults
	 * to centering the Window within the width of the Window's container
	 * Ext.Element Element) (The Element that the Window is rendered to).
	 */
	public Integer getX() {
		if (null != this.x) {
			return this.x;
		}
		ValueExpression _ve = getValueExpression("x");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>x</code> property.
	 * </p>
	 */
	public void setX(Integer x) {
		this.x = x;
		this.handleConfig("x", x);
	}

	private Integer y;

	/**
	 * The Y position of the top edge of the window oninitial showing. Defaults
	 * to centering the Window within the height of the Window's container
	 * Ext.Element Element) (The Element that the Window is rendered to).
	 */
	public Integer getY() {
		if (null != this.y) {
			return this.y;
		}
		ValueExpression _ve = getValueExpression("y");
		if (_ve != null) {
			return (Integer) _ve.getValue(getFacesContext().getELContext());
		} else {
			return null;
		}
	}

	/**
	 * <p>
	 * Set the value of the <code>y</code> property.
	 * </p>
	 */
	public void setY(Integer y) {
		this.y = y;
		this.handleConfig("y", y);
	}

	private Object[] _values;

	public Object saveState(FacesContext _context) {
		if (_values == null) {
			_values = new Object[25];
		}
		_values[0] = super.saveState(_context);
		_values[1] = animateTarget;
		_values[2] = baseCls;
		_values[3] = closable;
		_values[4] = closeAction;
		_values[5] = collapsed;
		_values[6] = constrain;
		_values[7] = constrainHeader;
		_values[8] = defaultButton;
		_values[9] = draggable;
		_values[10] = expandOnShow;
		_values[11] = initHidden;
		_values[12] = manager;
		_values[13] = maximizable;
		_values[14] = maximized;
		_values[15] = minHeight;
		_values[16] = minWidth;
		_values[17] = minimizable;
		_values[18] = modal;
		_values[19] = onEsc;
		_values[20] = plain;
		_values[21] = resizable;
		_values[22] = resizeHandles;
		_values[23] = x;
		_values[24] = y;

		return _values;
	}

	public void restoreState(FacesContext _context, Object _state) {
		_values = (Object[]) _state;
		super.restoreState(_context, _values[0]);
		this.animateTarget = (String) _values[1];
		this.handleConfig("animateTarget", this.animateTarget);
		this.baseCls = (String) _values[2];
		this.handleConfig("baseCls", this.baseCls);
		this.closable = (Boolean) _values[3];
		this.handleConfig("closable", this.closable);
		this.closeAction = (String) _values[4];
		this.handleConfig("closeAction", this.closeAction);
		this.collapsed = (Boolean) _values[5];
		this.handleConfig("collapsed", this.collapsed);
		this.constrain = (Boolean) _values[6];
		this.handleConfig("constrain", this.constrain);
		this.constrainHeader = (Boolean) _values[7];
		this.handleConfig("constrainHeader", this.constrainHeader);
		this.defaultButton = (String) _values[8];
		this.handleConfig("defaultButton", this.defaultButton);
		this.draggable = (Boolean) _values[9];
		this.handleConfig("draggable", this.draggable);
		this.expandOnShow = (Boolean) _values[10];
		this.handleConfig("expandOnShow", this.expandOnShow);
		this.initHidden = (Boolean) _values[11];
		this.handleConfig("initHidden", this.initHidden);
		this.manager = (Object) _values[12];
		this.handleConfig("manager", this.manager);
		this.maximizable = (Boolean) _values[13];
		this.handleConfig("maximizable", this.maximizable);
		this.maximized = (Boolean) _values[14];
		this.handleConfig("maximized", this.maximized);
		this.minHeight = (Integer) _values[15];
		this.handleConfig("minHeight", this.minHeight);
		this.minWidth = (Integer) _values[16];
		this.handleConfig("minWidth", this.minWidth);
		this.minimizable = (Boolean) _values[17];
		this.handleConfig("minimizable", this.minimizable);
		this.modal = (Boolean) _values[18];
		this.handleConfig("modal", this.modal);
		this.onEsc = (Object) _values[19];
		this.handleConfig("onEsc", this.onEsc);
		this.plain = (Boolean) _values[20];
		this.handleConfig("plain", this.plain);
		this.resizable = (Boolean) _values[21];
		this.handleConfig("resizable", this.resizable);
		this.resizeHandles = (String) _values[22];
		this.handleConfig("resizeHandles", this.resizeHandles);
		this.x = (Integer) _values[23];
		this.handleConfig("x", this.x);
		this.y = (Integer) _values[24];
		this.handleConfig("y", this.y);

	}
}